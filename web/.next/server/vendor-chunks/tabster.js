"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tabster";
exports.ids = ["vendor-chunks/tabster"];
exports.modules = {

/***/ "(ssr)/./node_modules/tabster/dist/tabster.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/tabster/dist/tabster.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFocusSources: () => (/* binding */ AsyncFocusSources),\n/* harmony export */   DeloserFocusLostEvent: () => (/* binding */ DeloserFocusLostEvent),\n/* harmony export */   DeloserFocusLostEventName: () => (/* binding */ DeloserFocusLostEventName),\n/* harmony export */   DeloserRestoreFocusEvent: () => (/* binding */ DeloserRestoreFocusEvent),\n/* harmony export */   DeloserRestoreFocusEventName: () => (/* binding */ DeloserRestoreFocusEventName),\n/* harmony export */   DeloserStrategies: () => (/* binding */ DeloserStrategies),\n/* harmony export */   EventsTypes: () => (/* binding */ EventsTypes),\n/* harmony export */   FOCUSABLE_SELECTOR: () => (/* binding */ FOCUSABLE_SELECTOR),\n/* harmony export */   GroupperMoveFocusActions: () => (/* binding */ GroupperMoveFocusActions),\n/* harmony export */   GroupperMoveFocusEvent: () => (/* binding */ GroupperMoveFocusEvent),\n/* harmony export */   GroupperMoveFocusEventName: () => (/* binding */ GroupperMoveFocusEventName),\n/* harmony export */   GroupperTabbabilities: () => (/* binding */ GroupperTabbabilities),\n/* harmony export */   ModalizerActiveEvent: () => (/* binding */ ModalizerActiveEvent),\n/* harmony export */   ModalizerActiveEventName: () => (/* binding */ ModalizerActiveEventName),\n/* harmony export */   ModalizerFocusInEventName: () => (/* binding */ ModalizerFocusInEventName),\n/* harmony export */   ModalizerFocusOutEventName: () => (/* binding */ ModalizerFocusOutEventName),\n/* harmony export */   ModalizerInactiveEvent: () => (/* binding */ ModalizerInactiveEvent),\n/* harmony export */   ModalizerInactiveEventName: () => (/* binding */ ModalizerInactiveEventName),\n/* harmony export */   MoverDirections: () => (/* binding */ MoverDirections),\n/* harmony export */   MoverKeys: () => (/* binding */ MoverKeys),\n/* harmony export */   MoverMemorizedElementEvent: () => (/* binding */ MoverMemorizedElementEvent),\n/* harmony export */   MoverMemorizedElementEventName: () => (/* binding */ MoverMemorizedElementEventName),\n/* harmony export */   MoverMoveFocusEvent: () => (/* binding */ MoverMoveFocusEvent),\n/* harmony export */   MoverMoveFocusEventName: () => (/* binding */ MoverMoveFocusEventName),\n/* harmony export */   MoverStateEvent: () => (/* binding */ MoverStateEvent),\n/* harmony export */   MoverStateEventName: () => (/* binding */ MoverStateEventName),\n/* harmony export */   ObservedElementAccessibilities: () => (/* binding */ ObservedElementAccessibilities),\n/* harmony export */   ObservedElementRequestStatuses: () => (/* binding */ ObservedElementRequestStatuses),\n/* harmony export */   RestoreFocusOrders: () => (/* binding */ RestoreFocusOrders),\n/* harmony export */   RestorerRestoreFocusEvent: () => (/* binding */ RestorerRestoreFocusEvent),\n/* harmony export */   RestorerRestoreFocusEventName: () => (/* binding */ RestorerRestoreFocusEventName),\n/* harmony export */   RestorerTypes: () => (/* binding */ RestorerTypes),\n/* harmony export */   RootBlurEvent: () => (/* binding */ RootBlurEvent),\n/* harmony export */   RootBlurEventName: () => (/* binding */ RootBlurEventName),\n/* harmony export */   RootFocusEvent: () => (/* binding */ RootFocusEvent),\n/* harmony export */   RootFocusEventName: () => (/* binding */ RootFocusEventName),\n/* harmony export */   SysDummyInputsPositions: () => (/* binding */ SysDummyInputsPositions),\n/* harmony export */   TABSTER_ATTRIBUTE_NAME: () => (/* binding */ TABSTER_ATTRIBUTE_NAME),\n/* harmony export */   TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME: () => (/* binding */ TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME),\n/* harmony export */   TabsterCustomEvent: () => (/* binding */ TabsterCustomEvent),\n/* harmony export */   TabsterFocusInEvent: () => (/* binding */ TabsterFocusInEvent),\n/* harmony export */   TabsterFocusInEventName: () => (/* binding */ TabsterFocusInEventName),\n/* harmony export */   TabsterFocusOutEvent: () => (/* binding */ TabsterFocusOutEvent),\n/* harmony export */   TabsterFocusOutEventName: () => (/* binding */ TabsterFocusOutEventName),\n/* harmony export */   TabsterMoveFocusEvent: () => (/* binding */ TabsterMoveFocusEvent),\n/* harmony export */   TabsterMoveFocusEventName: () => (/* binding */ TabsterMoveFocusEventName),\n/* harmony export */   Types: () => (/* binding */ Types),\n/* harmony export */   Visibilities: () => (/* binding */ Visibilities),\n/* harmony export */   createTabster: () => (/* binding */ createTabster),\n/* harmony export */   dispatchGroupperMoveFocusEvent: () => (/* binding */ dispatchGroupperMoveFocusEvent),\n/* harmony export */   dispatchMoverMemorizedElementEvent: () => (/* binding */ dispatchMoverMemorizedElementEvent),\n/* harmony export */   dispatchMoverMoveFocusEvent: () => (/* binding */ dispatchMoverMoveFocusEvent),\n/* harmony export */   disposeTabster: () => (/* binding */ disposeTabster),\n/* harmony export */   forceCleanup: () => (/* binding */ forceCleanup),\n/* harmony export */   getCrossOrigin: () => (/* binding */ getCrossOrigin),\n/* harmony export */   getDeloser: () => (/* binding */ getDeloser),\n/* harmony export */   getDummyInputContainer: () => (/* binding */ getDummyInputContainer),\n/* harmony export */   getGroupper: () => (/* binding */ getGroupper),\n/* harmony export */   getInternal: () => (/* binding */ getInternal),\n/* harmony export */   getModalizer: () => (/* binding */ getModalizer),\n/* harmony export */   getMover: () => (/* binding */ getMover),\n/* harmony export */   getObservedElement: () => (/* binding */ getObservedElement),\n/* harmony export */   getOutline: () => (/* binding */ getOutline),\n/* harmony export */   getRestorer: () => (/* binding */ getRestorer),\n/* harmony export */   getShadowDOMAPI: () => (/* binding */ getShadowDOMAPI),\n/* harmony export */   getTabster: () => (/* binding */ getTabster),\n/* harmony export */   getTabsterAttribute: () => (/* binding */ getTabsterAttribute),\n/* harmony export */   isNoOp: () => (/* binding */ isNoOp),\n/* harmony export */   makeNoOp: () => (/* binding */ makeNoOp),\n/* harmony export */   mergeTabsterProps: () => (/* binding */ mergeTabsterProps),\n/* harmony export */   setTabsterAttribute: () => (/* binding */ setTabsterAttribute)\n/* harmony export */ });\n/* harmony import */ var keyborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keyborg */ \"(ssr)/./node_modules/keyborg/dist/esm/index.js\");\n\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst TABSTER_ATTRIBUTE_NAME = \"data-tabster\";\nconst TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = \"data-tabster-dummy\";\nconst FOCUSABLE_SELECTOR = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\", \"details > summary\", \"audio[controls]\", \"video[controls]\"].join(\", \");\nconst AsyncFocusSources = {\n  EscapeGroupper: 1,\n  Restorer: 2,\n  Deloser: 3\n};\nconst ObservedElementAccessibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst ObservedElementRequestStatuses = {\n  Waiting: 0,\n  Succeeded: 1,\n  Canceled: 2,\n  TimedOut: 3\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst DeloserStrategies = {\n  /**\n   * If the focus is lost, the focus will be restored automatically using all available focus history.\n   * This is the default strategy.\n   */\n  Auto: 0,\n  /**\n   * If the focus is lost from this Deloser instance, the focus will not be restored automatically.\n   * The application might listen to the event and restore the focus manually.\n   * But if it is lost from another Deloser instance, the history of this Deloser could be used finding\n   * the element to focus.\n   */\n  Manual: 1\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst RestorerTypes = {\n  Source: 0,\n  Target: 1\n};\nconst MoverDirections = {\n  Both: 0,\n  // Default, both left/up keys move to the previous, right/down move to the next.\n  Vertical: 1,\n  // Only up/down arrows move to the next/previous.\n  Horizontal: 2,\n  // Only left/right arrows move to the next/previous.\n  Grid: 3,\n  // Two-dimentional movement depending on the visual placement.\n  GridLinear: 4 // Two-dimentional movement depending on the visual placement. Allows linear movement.\n};\nconst MoverKeys = {\n  ArrowUp: 1,\n  ArrowDown: 2,\n  ArrowLeft: 3,\n  ArrowRight: 4,\n  PageUp: 5,\n  PageDown: 6,\n  Home: 7,\n  End: 8\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  // The tabbability is limited to the container and explicit Enter is needed to go inside.\n  LimitedTrapFocus: 2 // The focus is limited as above, plus trapped when inside.\n};\nconst GroupperMoveFocusActions = {\n  Enter: 1,\n  Escape: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n  Inside: 1,\n  // Tabster will always place dummy inputs inside the container.\n  Outside: 2 // Tabster will always place dummy inputs outside of the container.\n};\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (true) {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"restorer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n          break;\n        case \"observed\":\n          delete tabsterOnElement[key];\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n          break;\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (true) {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n        break;\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (true) {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n        break;\n      case \"restorer\":\n        if (tabsterOnElement.restorer) {\n          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);\n        } else {\n          if (tabster.restorer) {\n            if (newTabsterProps.restorer) {\n              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);\n            }\n          } else if (true) {\n            console.error(\"Restorer API used before initialization, please call `getRestorer()`\");\n          }\n        }\n        break;\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (true) {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n        break;\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (true) {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n        break;\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (true) {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n        break;\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (true) {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n        break;\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Events sent by Tabster.\n */\nconst TabsterFocusInEventName = \"tabster:focusin\";\nconst TabsterFocusOutEventName = \"tabster:focusout\";\n// Event is dispatched when Tabster wants to move focus as the result of\n// handling keyboard event. This allows to preventDefault() if you want to have\n// some custom logic.\nconst TabsterMoveFocusEventName = \"tabster:movefocus\";\n/**\n * Events sent by Deloser.\n */\nconst DeloserFocusLostEventName = \"tabster:deloser:focus-lost\";\n/**\n * Events to be sent to Deloser by the application.\n */\nconst DeloserRestoreFocusEventName = \"tabster:deloser:restore-focus\";\n/**\n * Events sent by Modalizer.\n */\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\n/**\n * Events sent by Mover.\n */\nconst MoverStateEventName = \"tabster:mover:state\";\n/**\n * Events to be sent to Mover by the application.\n */\n// Event that can be dispatched by the application to programmatically move\n// focus inside Mover.\nconst MoverMoveFocusEventName = \"tabster:mover:movefocus\";\n// Event that can be dispatched by the application to forget or modify\n// memorized element in Mover with memorizeCurrent property.\nconst MoverMemorizedElementEventName = \"tabster:mover:memorized-element\";\n/**\n * Events sent by Groupper.\n */\n/**\n * Events to be sent to Groupper by the application.\n */\n// Event that can be dispatched by the application to programmatically enter\n// or escape Groupper.\nconst GroupperMoveFocusEventName = \"tabster:groupper:movefocus\";\n/**\n * Events sent by Restorer.\n */\nconst RestorerRestoreFocusEventName = \"tabster:restorer:restore-focus\";\n/**\n * Events sent by Root.\n */\nconst RootFocusEventName = \"tabster:root:focus\";\nconst RootBlurEventName = \"tabster:root:blur\";\n// Node.js environments do not have CustomEvent and it is needed for the events to be\n// evaluated. It doesn't matter if it works or not in Node.js environment.\n// So, we just need to make sure that it doesn't throw undefined reference.\nconst CustomEvent_ = typeof CustomEvent !== \"undefined\" ? CustomEvent : function () {\n  /* no-op */\n};\nclass TabsterCustomEvent extends CustomEvent_ {\n  constructor(type, detail) {\n    super(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail\n    });\n    this.details = detail;\n  }\n}\nclass TabsterFocusInEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusInEventName, detail);\n  }\n}\nclass TabsterFocusOutEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusOutEventName, detail);\n  }\n}\nclass TabsterMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterMoveFocusEventName, detail);\n  }\n}\nclass MoverStateEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverStateEventName, detail);\n  }\n}\nclass MoverMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMoveFocusEventName, detail);\n  }\n}\nclass MoverMemorizedElementEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMemorizedElementEventName, detail);\n  }\n}\nclass GroupperMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(GroupperMoveFocusEventName, detail);\n  }\n}\nclass ModalizerActiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerActiveEventName, detail);\n  }\n}\nclass ModalizerInactiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerInactiveEventName, detail);\n  }\n}\nclass DeloserFocusLostEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(DeloserFocusLostEventName, detail);\n  }\n}\nclass DeloserRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(DeloserRestoreFocusEventName);\n  }\n}\nclass RestorerRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(RestorerRestoreFocusEventName);\n  }\n}\nclass RootFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootFocusEventName, detail);\n  }\n}\nclass RootBlurEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootBlurEventName, detail);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _createMutationObserver = callback => new MutationObserver(callback);\nconst _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);\nconst _getParentNode = node => node ? node.parentNode : null;\nconst _getParentElement = element => element ? element.parentElement : null;\nconst _nodeContains = (parent, child) => !!(child && (parent === null || parent === void 0 ? void 0 : parent.contains(child)));\nconst _getActiveElement = doc => doc.activeElement;\nconst _querySelector = (element, selector) => element.querySelector(selector);\nconst _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);\nconst _getElementById = (doc, id) => doc.getElementById(id);\nconst _getFirstChild = node => (node === null || node === void 0 ? void 0 : node.firstChild) || null;\nconst _getLastChild = node => (node === null || node === void 0 ? void 0 : node.lastChild) || null;\nconst _getNextSibling = node => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\nconst _getPreviousSibling = node => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;\nconst _getFirstElementChild = element => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;\nconst _getLastElementChild = element => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;\nconst _getNextElementSibling = element => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;\nconst _getPreviousElementSibling = element => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;\nconst _appendChild = (parent, child) => parent.appendChild(child);\nconst _insertBefore = (parent, child, referenceChild) => parent.insertBefore(child, referenceChild);\nconst _getSelection = ref => {\n  var _a;\n  return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;\n};\nconst _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);\nconst dom = {\n  createMutationObserver: _createMutationObserver,\n  createTreeWalker: _createTreeWalker,\n  getParentNode: _getParentNode,\n  getParentElement: _getParentElement,\n  nodeContains: _nodeContains,\n  getActiveElement: _getActiveElement,\n  querySelector: _querySelector,\n  querySelectorAll: _querySelectorAll,\n  getElementById: _getElementById,\n  getFirstChild: _getFirstChild,\n  getLastChild: _getLastChild,\n  getNextSibling: _getNextSibling,\n  getPreviousSibling: _getPreviousSibling,\n  getFirstElementChild: _getFirstElementChild,\n  getLastElementChild: _getLastElementChild,\n  getNextElementSibling: _getNextElementSibling,\n  getPreviousElementSibling: _getPreviousElementSibling,\n  appendChild: _appendChild,\n  insertBefore: _insertBefore,\n  getSelection: _getSelection,\n  getElementsByName: _getElementsByName\n};\nfunction setDOMAPI(domapi) {\n  for (const key of Object.keys(domapi)) {\n    dom[key] = domapi[key];\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet _isBrokenIE11;\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n};\nlet _uidCounter = 0;\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n} catch (e) {\n  _isBrokenIE11 = true;\n}\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\nfunction hasSubFocusable(element) {\n  return !!element.querySelector(FOCUSABLE_SELECTOR);\n}\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n  deref() {\n    return this._target;\n  }\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n    return false;\n  }\n}\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n    this._ref = ref;\n    this._data = data;\n  }\n  get() {\n    const ref = this._ref;\n    let element;\n    if (ref) {\n      element = ref.deref();\n      if (!element) {\n        delete this._ref;\n      }\n    }\n    return element;\n  }\n  getData() {\n    return this._data;\n  }\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  }\n  // TypeScript isn't aware of IE11 behaving badly.\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return dom.createTreeWalker(doc, root, NodeFilter.SHOW_ELEMENT, filter,\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false /* Last argument is not optional for IE11! */);\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n  if (cached) {\n    return cached.rect;\n  }\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n  if (!scrollingElement) {\n    return new _DOMRect();\n  }\n  // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n  if (!container) {\n    return false;\n  }\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n  if (doc) {\n    for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n    return doc.documentElement;\n  }\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n  const srnd = [];\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n    if (el && parent) {\n      if (!dom.nodeContains(parent, el)) {\n        continue;\n      }\n    }\n    delete context.elementByUId[key];\n  }\n}\n// IE11 doesn't have document.contains()...\nfunction documentContains(doc, element) {\n  return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = {\n      ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n  getElement() {\n    return this._element.get();\n  }\n  getProps() {\n    return this._props;\n  }\n  setProps(props) {\n    this._props = {\n      ...props\n    };\n  }\n}\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element, fixedTarget) {\n    var _a;\n    this._focusIn = e => {\n      if (this._fixedTarget) {\n        const target = this._fixedTarget.get();\n        if (target) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(target);\n        }\n        return;\n      }\n      const input = this.input;\n      if (this.onFocusIn && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n    this._focusOut = e => {\n      if (this._fixedTarget) {\n        return;\n      }\n      this.useDefaultAction = false;\n      const input = this.input;\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    this._fixedTarget = fixedTarget;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n    const input = this.input;\n    if (!input) {\n      return;\n    }\n    delete this._fixedTarget;\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n  setTopLeft(top, left) {\n    var _a;\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n  }\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n  moveOut(backwards) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n  }\n  moveOutWithDefaultAction(backwards, relatedEvent) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);\n  }\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n  setTabbable(tabbable) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n      delete this._instance;\n    }\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n  static moveWithPhantomDummy(tabster, element,\n  // The target element to move to or out of.\n  moveOutOfElement,\n  // Whether to move out of the element or into it.\n  isBackward,\n  // Are we tabbing of shift-tabbing?\n  relatedEvent // The event that triggered the move.\n  ) {\n    // Phantom dummy is a hack to use browser's default action to move\n    // focus from a specific point in the application to the next/previous\n    // element. Default action is needed because next focusable element\n    // is not always available to focus directly (for example, next focusable\n    // is inside isolated iframe) or for uncontrolled areas we want to make\n    // sure that something that controls it takes care of the focusing.\n    // It works in a way that during the Tab key handling, we create a dummy\n    // input element, place it to the specific place in the DOM and focus it,\n    // then the default action of the Tab press will move focus from our dummy\n    // input. And we remove it from the DOM right after that.\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n    if (input) {\n      let parent;\n      let insertBefore;\n      // Let's say we have a following DOM structure:\n      // <div>\n      //   <button>Button1</button>\n      //   <div id=\"uncontrolled\" data-tabster={uncontrolled: {}}>\n      //     <button>Button2</button>\n      //     <button>Button3</button>\n      //   </div>\n      //   <button>Button4</button>\n      // </div>\n      //\n      // We pass the \"uncontrolled\" div as the element to move to or out of.\n      //\n      // When we pass moveOutOfElement=true and isBackward=false,\n      // the phantom dummy input will be inserted before Button4.\n      //\n      // When we pass moveOutOfElement=true and isBackward=true, there are\n      // two cases. If the uncontrolled element is focusable (has tabindex=0),\n      // the phantom dummy input will be inserted after Button1. If the\n      // uncontrolled element is not focusable, the phantom dummy input will be\n      // inserted before Button2.\n      //\n      // When we pass moveOutOfElement=false and isBackward=false, the\n      // phantom dummy input will be inserted after Button1.\n      //\n      // When we pass moveOutOfElement=false and isBackward=true, the phantom\n      // dummy input will be inserted before Button4.\n      //\n      // And we have a corner case for <body> and we make sure that the inserted\n      // dummy is inserted properly when there are existing permanent dummies.\n      if (element.tagName === \"BODY\") {\n        // We cannot insert elements outside of BODY.\n        parent = element;\n        insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;\n      } else {\n        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {\n          parent = element;\n          insertBefore = isBackward ? element.firstElementChild : null;\n        } else {\n          parent = dom.getParentElement(element);\n          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);\n        }\n        let potentialDummy;\n        let dummyFor;\n        do {\n          // This is a safety pillow for the cases when someone, combines\n          // groupper with uncontrolled on the same node. Which is technically\n          // not correct, but moving into the container element via its dummy\n          // input would produce a correct behaviour in uncontrolled mode.\n          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;\n          dummyFor = getDummyInputContainer(potentialDummy);\n          if (dummyFor === element) {\n            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);\n          } else {\n            dummyFor = null;\n          }\n        } while (dummyFor);\n      }\n      if (parent === null || parent === void 0 ? void 0 : parent.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"root\",\n        owner: parent,\n        next: null,\n        relatedEvent\n      }))) {\n        dom.insertBefore(parent, input, insertBefore);\n        (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(input);\n      }\n    }\n  }\n  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    }, undefined, new WeakHTMLElement(tabster.getWindow, targetElement));\n    const input = dummy.input;\n    if (input) {\n      let dummyParent;\n      let insertBefore;\n      if (hasSubFocusable(sourceElement) && !isBackward) {\n        dummyParent = sourceElement;\n        insertBefore = dom.getFirstElementChild(sourceElement);\n      } else {\n        dummyParent = dom.getParentElement(sourceElement);\n        insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);\n      }\n      if (dummyParent) {\n        dom.insertBefore(dummyParent, input, insertBefore);\n      }\n    }\n  }\n}\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummyElements = [];\n    this._dummyCallbacks = new WeakMap();\n    this._domChanged = parent => {\n      var _a;\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n      this._changedParents.add(parent);\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n        for (const ref of this._dummyElements) {\n          const dummyElement = ref.get();\n          if (dummyElement) {\n            const callback = this._dummyCallbacks.get(dummyElement);\n            if (callback) {\n              const dummyParent = dom.getParentNode(dummyElement);\n              if (!dummyParent || this._changedParents.has(dummyParent)) {\n                callback();\n              }\n            }\n          }\n        }\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n    this._win = win;\n  }\n  add(dummy, callback) {\n    if (!this._dummyCallbacks.has(dummy) && this._win) {\n      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));\n      this._dummyCallbacks.set(dummy, callback);\n      this.domChanged = this._domChanged;\n    }\n  }\n  remove(dummy) {\n    this._dummyElements = this._dummyElements.filter(ref => {\n      const element = ref.get();\n      return element && element !== dummy;\n    });\n    this._dummyCallbacks.delete(dummy);\n    if (this._dummyElements.length === 0) {\n      delete this.domChanged;\n    }\n  }\n  dispose() {\n    var _a;\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n    this._changedParents = new WeakSet();\n    this._dummyCallbacks = new WeakMap();\n    this._dummyElements = [];\n    this._updateQueue.clear();\n    delete this.domChanged;\n    delete this._win;\n  }\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n    this._updateQueue.add(compute);\n    this._lastUpdateQueueTime = Date.now();\n    this._scheduledUpdatePositions();\n  }\n  _scheduledUpdatePositions() {\n    var _a;\n    if (this._updateTimer) {\n      return;\n    }\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer;\n      // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n        this._updateQueue.clear();\n        // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        }\n        // Explicitly clear to not hold references till the next garbage collection.\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n}\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n    this.moveOut = backwards => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n          }\n        }\n      }\n    };\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    this.moveOutWithDefaultAction = (backwards, relatedEvent) => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus && element.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: element,\n            next: null,\n            relatedEvent\n          }))) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n          }\n        }\n      }\n    };\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n      const wrapper = this._getCurrent();\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n      if (true) {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n        this._ensurePosition();\n        if (true) {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n        this._addTransformOffsets();\n      }, 0);\n    };\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n      const win = this._getWindow();\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = dom.getParentElement(element)) {\n        let scrollTopLeft = scrollTopLeftCache.get(element);\n        // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n    const el = element.get();\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n    if (instance) {\n      if (true) {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n      return instance;\n    }\n    el.__tabsterDummy = this;\n    // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element);\n    // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n    this._addDummyInputs();\n  }\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n    if (true) {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n      this._transformElements.clear();\n      const win = this._getWindow();\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n    const wrapper = this._getCurrent();\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n      return a.priority - b.priority;\n    });\n    return this._wrappers[0];\n  }\n  _ensurePosition() {\n    var _a, _b, _c;\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n    if (this._isOutside) {\n      const elementParent = dom.getParentNode(element);\n      if (elementParent) {\n        const nextSibling = dom.getNextSibling(element);\n        if (nextSibling !== lastDummyInput) {\n          dom.insertBefore(elementParent, lastDummyInput, nextSibling);\n        }\n        if (dom.getPreviousElementSibling(element) !== firstDummyInput) {\n          dom.insertBefore(elementParent, firstDummyInput, element);\n        }\n      }\n    } else {\n      if (dom.getLastElementChild(element) !== lastDummyInput) {\n        dom.appendChild(element, lastDummyInput);\n      }\n      const firstElementChild = dom.getFirstElementChild(element);\n      if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {\n        dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);\n      }\n    }\n  }\n}\nfunction getLastChild$2(container) {\n  let lastChild = null;\n  for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) {\n    lastChild = i;\n  }\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n  while (cur && !adjacent) {\n    adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);\n    cur = dom.getParentElement(cur);\n  }\n  return adjacent || undefined;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n    entry.aug = {};\n  }\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n      ret = true;\n    }\n  } else {\n    let origValue;\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n      ret = true;\n    }\n  }\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n  return ret;\n}\nfunction isDisplayNone(element) {\n  var _a, _b;\n  const elementDocument = element.ownerDocument;\n  const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);\n  // offsetParent is null for elements with display:none, display:fixed and for <body>.\n  if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== \"fixed\") {\n    return true;\n  }\n  // For our purposes of looking for focusable elements, visibility:hidden has the same\n  // effect as display:none.\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === \"hidden\") {\n    return true;\n  }\n  // if an element has display: fixed, we need to check if it is also hidden with CSS,\n  // or within a parent hidden with CSS\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === \"fixed\") {\n    if (computedStyle.display === \"none\") {\n      return true;\n    }\n    if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isRadio(element) {\n  return element.tagName === \"INPUT\" && !!element.name && element.type === \"radio\";\n}\nfunction getRadioButtonGroup(element) {\n  if (!isRadio(element)) {\n    return;\n  }\n  const name = element.name;\n  let radioButtons = Array.from(dom.getElementsByName(element, name));\n  let checked;\n  radioButtons = radioButtons.filter(el => {\n    if (isRadio(el)) {\n      if (el.checked) {\n        checked = el;\n      }\n      return true;\n    }\n    return false;\n  });\n  return {\n    name,\n    buttons: new Set(radioButtons),\n    checked\n  };\n}\n/**\n * If the passed element is Tabster dummy input, returns the container element this dummy input belongs to.\n * @param element Element to check for being dummy input.\n * @returns Dummy input container element (if the passed element is a dummy input) or null.\n */\nfunction getDummyInputContainer(element) {\n  var _a;\n  return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n  if (plain === true) {\n    return attr;\n  }\n  return {\n    [TABSTER_ATTRIBUTE_NAME]: attr\n  };\n}\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n  if (update) {\n    const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (true) {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n  if (!props) {\n    props = {};\n  }\n  mergeTabsterProps(props, newProps);\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TABSTER_ATTRIBUTE_NAME);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n        const element = this._element.get();\n        if (element) {\n          this._setFocused(true);\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n          if (toFocus) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n            return;\n          }\n        }\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n    this._setHandlers(this._onDummyInputFocus);\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n}\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n    this._setFocused = hasFocused => {\n      var _a;\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n        delete this._setFocusedTimer;\n      }\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n      const element = this._element.get();\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          element.dispatchEvent(new RootFocusEvent({\n            element\n          }));\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            var _a;\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n            element.dispatchEvent(new RootBlurEvent({\n              element\n            }));\n          }, 0);\n        }\n      }\n    };\n    this._onFocusIn = event => {\n      const getParent = this._tabster.getParent;\n      const rootElement = this._element.get();\n      let curElement = event.composedPath()[0];\n      do {\n        if (curElement === rootElement) {\n          this._setFocused(true);\n          return;\n        }\n        curElement = curElement && getParent(curElement);\n      } while (curElement);\n    };\n    this._onFocusOut = () => {\n      this._setFocused(false);\n    };\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n    const w = win();\n    const doc = w.document;\n    doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut);\n    this._add();\n  }\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const win = this._tabster.getWindow();\n    const doc = win.document;\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut);\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._remove();\n  }\n  moveOutWithDefaultAction(isBackward, relatedEvent) {\n    const dummyManager = this._dummyManager;\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);\n    } else {\n      const el = this.getElement();\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);\n      }\n    }\n  }\n  _add() {\n    if (true) {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n}\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n    this._autoRootCreate = () => {\n      var _a;\n      const doc = this._win().document;\n      const body = doc.body;\n      if (body) {\n        this._autoRootUnwait(doc);\n        const props = this._autoRoot;\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n      return undefined;\n    };\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n  dispose() {\n    const win = this._win();\n    this._autoRootUnwait(win.document);\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n  createRoot(element, props, sys) {\n    if (true) ;\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n    return newRoot;\n  }\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\n   * Fetches the tabster context for an element walking up its ancestors\n   *\n   * @param tabster Tabster instance\n   * @param element The element the tabster context should represent\n   * @param options Additional options\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n   */\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _a, _b, _c, _d;\n    if (!element.ownerDocument) {\n      return undefined;\n    }\n    const {\n      checkRtl,\n      referenceElement\n    } = options;\n    const getParent = tabster.getParent;\n    // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n    tabster.drainInitQueue();\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let excludedFromMover = false;\n    let groupperBeforeMover;\n    let modalizerInGroupper;\n    let dirRightToLeft;\n    let uncontrolled;\n    let curElement = referenceElement || element;\n    const ignoreKeydown = {};\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n      if (checkRtl && dirRightToLeft === undefined) {\n        const dir = curElement.dir;\n        if (dir) {\n          dirRightToLeft = dir.toLowerCase() === \"rtl\";\n        }\n      }\n      if (!tabsterOnElement) {\n        curElement = getParent(curElement);\n        continue;\n      }\n      const tagName = curElement.tagName;\n      if ((tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") && tabster.focusable.isVisible(curElement)) {\n        uncontrolled = curElement;\n      }\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        excludedFromMover = true;\n      }\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element) // Mover makes sense only for really inside elements, not for virutal out of the DOM order children.\n      ) {\n        mover = curMover;\n        groupperBeforeMover = !!groupper && groupper !== curGroupper;\n      }\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n      curElement = getParent(curElement);\n    }\n    // No root element could be found, try to get an auto root\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n    if (groupper && !mover) {\n      groupperBeforeMover = true;\n    }\n    if ( true && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      groupperBeforeMover,\n      modalizerInGroupper,\n      rtl: checkRtl ? !!dirRightToLeft : undefined,\n      uncontrolled,\n      excludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n  static getRoot(tabster, element) {\n    var _a;\n    const getParent = tabster.getParent;\n    for (let el = element; el; el = getParent(el)) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n      if (root) {\n        return root;\n      }\n    }\n    return undefined;\n  }\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n    const deloserElement = this._deloser.getElement();\n    if (available && deloserElement) {\n      if (!deloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"deloser\",\n        owner: deloserElement,\n        next: available\n      }))) {\n        // Default action is prevented, don't look further.\n        return null;\n      }\n      return this._tabster.focusedElement.focus(available);\n    }\n    return false;\n  }\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n  getLength() {\n    return this._history.length;\n  }\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n}\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n    item.unshift(element);\n    this._history.unshift(item);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip) {\n        const result = await i.focusAvailable();\n        // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    }\n    // Nothing is found, at least try to reset.\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass DeloserHistory {\n  constructor(tabster) {\n    this._history = [];\n    this._tabster = tabster;\n  }\n  dispose() {\n    this._history = [];\n  }\n  process(element) {\n    var _a;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n    return deloser;\n  }\n  make(rootUId, createInstance) {\n    let historyByRoot;\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n    this._history.unshift(historyByRoot);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n    return historyByRoot;\n  }\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip) {\n        const result = await h.focusAvailable(from);\n        // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n  const elementId = element.getAttribute(\"id\");\n  if (elementId) {\n    selector.push(\"#\" + elementId.replace(escapeRegExp, escapeReplaceValue));\n  }\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n  let index = 0;\n  let el;\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n  const selector = [buildElementSelector(element)];\n  let node = dom.getParentNode(element);\n  while (node && node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n    // Stop at the shadow root as cross shadow selectors won't work.\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const isBody = node.tagName === \"BODY\";\n      selector.unshift(buildElementSelector(node, false, !isBody));\n      if (isBody) {\n        break;\n      }\n    }\n    node = dom.getParentNode(node);\n  }\n  return selector.join(\" \");\n}\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n    this.isActive = () => {\n      return this._isActive;\n    };\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n      if (true) {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n    this.focusFirst = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n    this.focusDefault = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n    this.resetFocus = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? dom.nodeContains(element, e) : false;\n      });\n    };\n    this.uid = getElementUId(tabster.getWindow, element);\n    this.strategy = props.strategy || DeloserStrategies.Auto;\n    this._onDispose = onDispose;\n    if (true) {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  dispose() {\n    this._remove();\n    this._onDispose(this);\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n  setActive(active) {\n    this._isActive = active;\n    if (true) {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n  findAvailable() {\n    const element = this._element.get();\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    if (!ctx) {\n      return null;\n    }\n    const root = ctx.root;\n    const rootElement = root.getElement();\n    if (!rootElement) {\n      return null;\n    }\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n    if (available) {\n      return available;\n    }\n    const availableInHistory = this._findInHistory();\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n    const availableFirst = this._findFirst(element);\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n  customFocusLostHandler(element) {\n    return element.dispatchEvent(new DeloserFocusLostEvent(this.getActions()));\n  }\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n    this.clearHistory(true);\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n      const element = this._element.get();\n      if (e && element && dom.nodeContains(element, e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n        if (selector && element) {\n          let els;\n          try {\n            els = dom.querySelectorAll(element.ownerDocument, selector);\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          } catch (e) {\n            if (true) {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n            continue;\n          }\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        useActiveModalizer: true\n      });\n      if (first) {\n        return first;\n      }\n    }\n    return null;\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n}\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n    this._onRestoreFocus = event => {\n      var _a;\n      const target = event.composedPath()[0];\n      if (target) {\n        const available = (_a = DeloserAPI.getDeloser(this._tabster, target)) === null || _a === void 0 ? void 0 : _a.findAvailable();\n        if (available) {\n          this._tabster.focusedElement.focus(available);\n        }\n        event.stopImmediatePropagation();\n      }\n    };\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n        this._restoreFocusTimer = undefined;\n      }\n      if (!e) {\n        this._scheduleRestoreFocus();\n        return;\n      }\n      const deloser = this._history.process(e);\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const doc = this._win().document;\n      doc.addEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.document.removeEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n    this._history.dispose();\n    delete this._curDeloser;\n  }\n  createDeloser(element, props) {\n    var _a;\n    if (true) ;\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n    if (dom.nodeContains(element, (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n    return deloser;\n  }\n  getActions(element) {\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n    return undefined;\n  }\n  pause() {\n    this._isPaused = true;\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n  }\n  resume(restore) {\n    this._isPaused = false;\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\n   * Activates and sets the current deloser\n   */\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\n   * Called when focus should no longer be in a deloser\n   */\n  _deactivate() {\n    var _a;\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n      if (!force && (this._isRestoringFocus || !this._inDeloser || lastFocused && !isDisplayNone(lastFocused))) {\n        return;\n      }\n      const curDeloser = this._curDeloser;\n      let isManual = false;\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n        if (curDeloser.strategy === DeloserStrategies.Manual) {\n          isManual = true;\n        } else {\n          const curDeloserElement = curDeloser.getElement();\n          const el = curDeloser.findAvailable();\n          if (el && (!(curDeloserElement === null || curDeloserElement === void 0 ? void 0 : curDeloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"deloser\",\n            owner: curDeloserElement,\n            next: el\n          }))) || this._tabster.focusedElement.focus(el))) {\n            return;\n          }\n        }\n      }\n      this._deactivate();\n      if (isManual) {\n        return;\n      }\n      this._isRestoringFocus = true;\n      // focusAvailable returns null when the default action is prevented by the application, false\n      // when nothing was focused and true when something was focused.\n      if ((await this._history.focusAvailable(null)) === false) {\n        await this._history.resetFocus(null);\n      }\n      this._isRestoringFocus = false;\n    };\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n  static getDeloser(tabster, element) {\n    var _a;\n    let root;\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n        const deloser = tabsterOnElement.deloser;\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n    const deloserAPI = tabster.deloser && tabster.deloser;\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n      const autoDeloserProps = deloserAPI._autoDeloser;\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n      return deloserAPI._autoDeloserInstance;\n    }\n    return undefined;\n  }\n  static getHistory(instance) {\n    return instance._history;\n  }\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n    callbacks.unshift(callback);\n  }\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n  setVal(val, detail) {\n    if (this._val === val) {\n      return;\n    }\n    this._val = val;\n    this._callCallbacks(val, detail);\n  }\n  getVal() {\n    return this._val;\n  }\n  trigger(val, detail) {\n    this._callCallbacks(val, detail);\n  }\n  _callCallbacks(val, detail) {\n    this._callbacks.forEach(callback => callback(val, detail));\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n  async focusAvailable() {\n    const data = {\n      ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n  async resetFocus() {\n    const data = {\n      ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n}\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n  unshift(deloser) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n    this._history.unshift(item);\n    this._history.splice(10, this._history.length - 10);\n  }\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = {\n      ...this._sentTo\n    };\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n    return this._promise;\n  }\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n    this._isDone = true;\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n  onResponse(data) {\n    const endData = data.endData;\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n}\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n}\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n}\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n    return true;\n  }\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n    return true;\n  }\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n    return true;\n  }\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (name && element) {\n      CrossOriginObservedElementState.trigger(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n    return true;\n  }\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n      return true;\n    });\n  }\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n    return true;\n  }\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n    return true;\n  }\n}\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static findElement(tabster, getOwner, data) {\n    let element;\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = dom.getElementById(getOwner().document, data.id);\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n    return element || null;\n  }\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false;\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n}\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n    return !!forwardRet;\n  }\n}\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse() {\n    return true;\n  }\n}\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const data = e.data;\n      let transactionId;\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n      let knownTarget = this._knownTargets[data.owner];\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n        const forwardResult = this.forwardTransaction(data);\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n    this._onPageHide = () => {\n      this._dead();\n    };\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (true) {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n      this._ping();\n    }\n    return this._onMessage;\n  }\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n    this.sendUp = sendUp || undefined;\n    const owner = this._owner();\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = (\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n    return this._onMessage;\n  }\n  async dispose() {\n    const owner = this._owner();\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n      t.transaction.end();\n    }\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n  forwardTransaction(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n    const Transaction = this._getTransactionClass(data.type);\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n  _getTransactionClass(type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n      default:\n        return null;\n    }\n  }\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n        return false;\n      })));\n    }\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n      this._ping();\n    }, _pingTimeout);\n  }\n}\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, {\n      ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n  static setVal(instance, val, detail) {\n    instance.setVal(val, detail);\n  }\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ?\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.observedElement.subscribe(this._onObserved);\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.outline.setup = this._outlineSetup;\n      }\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n    this._onFocus = element => {\n      const win = this._win();\n      const ownerUId = getWindowUId(win);\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, {\n          ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n    this._onObserved = (element, details) => {\n      var _a;\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n      return this._transactions.setup(sendUp);\n    }\n  }\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n  dispose() {\n    var _a;\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n    this._transactions.dispose();\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n}\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n    return uid;\n  }\n  return undefined;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n  dispose() {\n    /**/\n  }\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n    return false;\n  }\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n    if (isDisplayNone(el)) {\n      return false;\n    }\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n    return true;\n  }\n  isAccessible(el) {\n    var _a;\n    for (let e = el; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (this._isHidden(e)) {\n        return false;\n      }\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n  _isHidden(el) {\n    var _a;\n    const attrVal = el.getAttribute(\"aria-hidden\");\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  findFirst(options, out) {\n    return this.findElement({\n      ...options\n    }, out);\n  }\n  findLast(options, out) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    }, out);\n  }\n  findNext(options, out) {\n    return this.findElement({\n      ...options\n    }, out);\n  }\n  findPrev(options, out) {\n    return this.findElement({\n      ...options,\n      isBackward: true\n    }, out);\n  }\n  findDefault(options, out) {\n    return this.findElement({\n      ...options,\n      acceptCondition: el => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }, out) || null;\n  }\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n  findElement(options, out) {\n    const found = this._findElements(false, options, out);\n    return found ? found[0] : found;\n  }\n  _findElements(isFindAll, options, out) {\n    var _a, _b, _c;\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onElement\n    } = options;\n    if (!out) {\n      out = {};\n    }\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n    const hasCustomCondition = !!acceptCondition;\n    if (!container) {\n      return null;\n    }\n    if (!acceptCondition) {\n      acceptCondition = el => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      isFindAll,\n      acceptCondition,\n      hasCustomCondition,\n      includeProgrammaticallyFocusable,\n      ignoreAccessibility,\n      cachedGrouppers: {},\n      cachedRadioGroups: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n    if (!walker) {\n      return null;\n    }\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      var _a, _b;\n      const foundElement = (_a = acceptElementState.foundElement) !== null && _a !== void 0 ? _a : acceptElementState.foundBackward;\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n      if (isFindAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.foundBackward;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        if (foundElement && out) {\n          out.uncontrolled = (_b = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b === void 0 ? void 0 : _b.uncontrolled;\n        }\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n    if (!currentElement) {\n      out.outOfDOMOrder = true;\n    }\n    if (currentElement && dom.nodeContains(container, currentElement)) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild$2(container);\n      if (!lastChild) {\n        return null;\n      }\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        if (acceptElementState.skippedFocusable) {\n          out.outOfDOMOrder = true;\n        }\n        return elements;\n      }\n      walker.currentNode = lastChild;\n    }\n    do {\n      if (isBackward) {\n        walker.previousNode();\n      } else {\n        walker.nextNode();\n      }\n    } while (prepareForNextElement());\n    if (acceptElementState.skippedFocusable) {\n      out.outOfDOMOrder = true;\n    }\n    return elements.length ? elements : null;\n  }\n  _acceptElement(element, state) {\n    var _a, _b, _c;\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    const foundBackward = state.foundBackward;\n    if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {\n      state.found = true;\n      state.foundElement = foundBackward;\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    const container = state.container;\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (!dom.nodeContains(container, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (getDummyInputContainer(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (dom.nodeContains(state.rejectElementsFrom, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);\n    // Tabster is opt in, if it is not managed, don't try and get do anything special\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (shouldIgnoreFocus(element)) {\n      if (this.isFocusable(element, undefined, true, true)) {\n        state.skippedFocusable = true;\n      }\n      return NodeFilter.FILTER_SKIP;\n    }\n    // We assume iframes are focusable because native tab behaviour would tab inside.\n    // But we do it only during the standard search when there is no custom accept\n    // element condition.\n    if (!state.hasCustomCondition && (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\")) {\n      if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        state.found = true;\n        state.rejectElementsFrom = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      if (this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n      return NodeFilter.FILTER_REJECT;\n    }\n    let result;\n    let fromCtx = state.fromCtx;\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);\n    if (result !== undefined) {\n      state.skippedFocusable = true;\n    }\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n      if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n      if (groupperElement) {\n        if (groupperElement === container || !dom.nodeContains(container, groupperElement)) {\n          groupper = undefined;\n        } else if (!dom.nodeContains(groupperElement, element)) {\n          // _acceptElement() callback is called during the tree walking.\n          // Given the potentiality of virtual parents (driven by the custom getParent() function),\n          // we need to make sure that the groupper from the current element's context is not,\n          // portaling us out of the DOM order.\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      if (moverElement) {\n        if (!dom.nodeContains(container, moverElement)) {\n          mover = undefined;\n        } else if (!dom.nodeContains(moverElement, element)) {\n          // _acceptElement() callback is called during the tree walking.\n          // Given the potentiality of virtual parents (driven by the custom getParent() function),\n          // we need to make sure that the mover from the current element's context is not,\n          // portaling us out of the DOM order.\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n    }\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      if (!state.isFindAll && isRadio(element) && !element.checked) {\n        // We need to mimic the browser's behaviour to skip unchecked radio buttons.\n        const radioGroupName = element.name;\n        let radioGroup = state.cachedRadioGroups[radioGroupName];\n        if (!radioGroup) {\n          radioGroup = getRadioButtonGroup(element);\n          if (radioGroup) {\n            state.cachedRadioGroups[radioGroupName] = radioGroup;\n          }\n        }\n        if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {\n          // Currently found element is a radio button in a group that has another radio button checked.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n      if (state.isBackward) {\n        // When TreeWalker goes backwards, it visits the container first,\n        // then it goes inside. So, if the container is accepted, we remember it,\n        // but allowing the TreeWalker to check inside.\n        state.foundBackward = element;\n        result = NodeFilter.FILTER_SKIP;\n      } else {\n        state.found = true;\n        state.foundElement = element;\n      }\n    }\n    return result;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst Keys = {\n  Tab: \"Tab\",\n  Enter: \"Enter\",\n  Escape: \"Escape\",\n  PageUp: \"PageUp\",\n  PageDown: \"PageDown\",\n  End: \"End\",\n  Home: \"Home\",\n  ArrowLeft: \"ArrowLeft\",\n  ArrowUp: \"ArrowUp\",\n  ArrowRight: \"ArrowRight\",\n  ArrowDown: \"ArrowDown\"\n};\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getUncontrolledCompletelyContainer(tabster, element) {\n  var _a;\n  const getParent = tabster.getParent;\n  let el = element;\n  do {\n    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;\n    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {\n      return el;\n    }\n    el = getParent(el);\n  } while (el);\n  return undefined;\n}\nconst AsyncFocusIntentPriorityBySource = {\n  [AsyncFocusSources.Restorer]: 0,\n  [AsyncFocusSources.Deloser]: 1,\n  [AsyncFocusSources.EscapeGroupper]: 2\n};\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n    this._init = () => {\n      const win = this._win();\n      const doc = win.document;\n      // Add these event listeners as capture - we want Tabster to run before user event handlers\n      doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n      this.subscribe(this._onChanged);\n    };\n    this._onFocusIn = e => {\n      const target = e.composedPath()[0];\n      if (target) {\n        this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);\n      }\n    };\n    this._onFocusOut = e => {\n      var _a;\n      this._setFocusedElement(undefined, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._validateFocusedElement = element => {\n      // TODO: Make sure this is not needed anymore and write tests.\n    };\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Tab || event.ctrlKey) {\n        return;\n      }\n      const currentElement = this.getVal();\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n      if (!ctx || ctx.ignoreKeydown(event)) {\n        return;\n      }\n      const isBackward = event.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, undefined, isBackward, true);\n      const rootElement = ctx.root.getElement();\n      if (!rootElement) {\n        return;\n      }\n      const nextElement = next === null || next === void 0 ? void 0 : next.element;\n      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster, currentElement);\n      if (nextElement) {\n        const nextUncontrolled = next.uncontrolled;\n        if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {\n          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {\n            // Nothing to do, everything will be done by the browser or something\n            // that controls the uncontrolled area.\n            return;\n          }\n          // We are in uncontrolled area. We allow whatever controls it to move\n          // focus, but we add a phantom dummy to make sure the focus is moved\n          // to the correct place if the uncontrolled area allows default action.\n          // We only need that in the controlled mode, because in uncontrolled\n          // mode we have dummy inputs around everything that redirects focus.\n          DummyInputManager.addPhantomDummyWithTarget(tabster, currentElement, isBackward, nextElement);\n          return;\n        }\n        if (nextUncontrolled && tabster.focusable.isVisible(nextUncontrolled) || nextElement.tagName === \"IFRAME\" && tabster.focusable.isVisible(nextElement)) {\n          // For iframes and uncontrolled areas we always want to use default action to\n          // move focus into.\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            DummyInputManager.moveWithPhantomDummy(tabster, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);\n          }\n          return;\n        }\n        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(nextElement);\n          }\n        }\n      } else {\n        if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n          by: \"root\",\n          owner: rootElement,\n          next: null,\n          relatedEvent: event\n        }))) {\n          ctx.root.moveOutWithDefaultAction(isBackward, event);\n        }\n      }\n    };\n    this._onChanged = (element, detail) => {\n      var _a, _b;\n      if (element) {\n        element.dispatchEvent(new TabsterFocusInEvent(detail));\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n        if (last) {\n          const d = {\n            ...detail\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n          last.dispatchEvent(new TabsterFocusOutEvent(d));\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    super.dispose();\n    const win = this._win();\n    const doc = win.document;\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn, true);\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    const asyncFocus = this._asyncFocus;\n    if (asyncFocus) {\n      win.clearTimeout(asyncFocus.timeout);\n      delete this._asyncFocus;\n    }\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._nextVal;\n    }\n    wel = instance._lastVal;\n    el = wel && wel.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._lastVal;\n    }\n  }\n  getFocusedElement() {\n    return this.getVal();\n  }\n  getLastFocusedElement() {\n    var _a;\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n    return el;\n  }\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n    element.focus({\n      preventScroll\n    });\n    return true;\n  }\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n      return true;\n    }\n    return false;\n  }\n  getFirstOrLastTabbable(isFirst, props) {\n    var _a;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let toFocus;\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n      if (ctx) {\n        toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, undefined, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;\n      }\n    }\n    if (toFocus && !dom.nodeContains(container, toFocus)) {\n      toFocus = undefined;\n    }\n    return toFocus || undefined;\n  }\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n    return false;\n  }\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n    return true;\n  }\n  requestAsyncFocus(source, callback, delay) {\n    const win = this._tabster.getWindow();\n    const currentAsyncFocus = this._asyncFocus;\n    if (currentAsyncFocus) {\n      if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {\n        // Previously registered intent has higher priority.\n        return;\n      }\n      // New intent has higher priority.\n      win.clearTimeout(currentAsyncFocus.timeout);\n    }\n    this._asyncFocus = {\n      source,\n      callback,\n      timeout: win.setTimeout(() => {\n        this._asyncFocus = undefined;\n        callback();\n      }, delay)\n    };\n  }\n  cancelAsyncFocus(source) {\n    const asyncFocus = this._asyncFocus;\n    if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {\n      this._tabster.getWindow().clearTimeout(asyncFocus.timeout);\n      this._asyncFocus = undefined;\n    }\n  }\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n    if (this._tabster._noop) {\n      return;\n    }\n    const detail = {\n      relatedTarget\n    };\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n      detail.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n      if (modalizerId) {\n        detail.modalizerId = modalizerId;\n      }\n    }\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      detail\n    };\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    }\n    // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n    if (this._nextVal === nextVal) {\n      this.setVal(element, detail);\n    }\n    this._nextVal = undefined;\n  }\n  setVal(val, detail) {\n    super.setVal(val, detail);\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n    if (!actualContainer) {\n      return null;\n    }\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n    const callFindNext = what => {\n      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);\n      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {\n        const parentElement = what !== modalizer && dom.getParentElement(what.getElement());\n        if (parentElement) {\n          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {\n            referenceElement: parentElement\n          });\n          if (parentCtx) {\n            const currentScopeElement = what.getElement();\n            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;\n            if (newCurrent) {\n              next = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreAccessibility);\n              if (next) {\n                next.outOfDOMOrder = true;\n              }\n            }\n          }\n        }\n      }\n    };\n    if (groupper && mover) {\n      callFindNext(ctx.groupperBeforeMover ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      const findProps = {\n        container: actualContainer,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      const nextElement = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      next = {\n        element: nextElement,\n        outOfDOMOrder: findPropsOut.outOfDOMOrder,\n        uncontrolled: findPropsOut.uncontrolled\n      };\n    }\n    return next;\n  }\n}\nFocusedElementState.isTabbing = false;\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n      const container = element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, undefined, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n          if (next) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(next);\n          }\n        }\n      }\n    });\n  }\n}\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const element = this._element.get();\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n    if (element) {\n      if (true) {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n    delete this._first;\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const groupperElement = this.getElement();\n    if (!groupperElement) {\n      return null;\n    }\n    const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;\n    if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        outOfDOMOrder: true\n      };\n    }\n    const groupperFirstFocusable = this.getFirst(true);\n    if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        outOfDOMOrder: true\n      };\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      const findProps = {\n        container: groupperElement,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container: groupperElement,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n        outOfDOMOrder = true;\n      }\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n    if (true) {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n  isActive(noIfFirstIsFocused) {\n    var _a;\n    const element = this.getElement() || null;\n    let isParentActive = true;\n    for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n    return ret;\n  }\n  getFirst(orContainer) {\n    var _a;\n    const groupperElement = this.getElement();\n    let first;\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          useActiveModalizer: true\n        }) || undefined;\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n    return first;\n  }\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n  acceptElement(element, state) {\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = dom.getParentElement(this.getElement());\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n      return isActive;\n    };\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {\n            state.skippedFocusable = true;\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n        if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {\n          state.skippedFocusable = true;\n          return NodeFilter.FILTER_REJECT;\n        }\n        const cached = cachedGrouppers[this.id];\n        let first;\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n        if (first && state.acceptCondition(first)) {\n          state.rejectElementsFrom = groupperElement;\n          state.skippedFocusable = true;\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n}\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n    this._init = () => {\n      const win = this._win();\n      // Making sure groupper's onFocus is called before modalizer's onFocus.\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n      const doc = win.document;\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement) {\n        this._onFocus(activeElement);\n      }\n      doc.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    };\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element);\n      }\n    };\n    this._onMouseDown = e => {\n      let target = e.target;\n      while (target && !this._tabster.focusable.isFocusable(target)) {\n        target = this._tabster.getParent(target);\n      }\n      if (target) {\n        this._updateCurrent(target);\n      }\n    };\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Enter && event.key !== Keys.Escape) {\n        return;\n      }\n      // Give a chance to other listeners to handle the event.\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      const element = this._tabster.focusedElement.getFocusedElement();\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n    this._onMoveFocus = e => {\n      var _a;\n      const element = e.composedPath()[0];\n      const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;\n      if (element && action !== undefined && !e.defaultPrevented) {\n        if (action === GroupperMoveFocusActions.Enter) {\n          this._enterGroupper(element);\n        } else {\n          this._escapeGroupper(element);\n        }\n        e.stopImmediatePropagation();\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    const win = this._win();\n    this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n    this._current = {};\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n  createGroupper(element, props, sys) {\n    if (true) ;\n    const tabster = this._tabster;\n    const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n    const focusedElement = tabster.focusedElement.getFocusedElement();\n    // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n    if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer;\n        // Making sure the focused element hasn't changed.\n        if (focusedElement === tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement);\n        }\n      }, 0);\n    }\n    return newGroupper;\n  }\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n  _updateCurrent(element) {\n    var _a;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    const tabster = this._tabster;\n    const newIds = {};\n    for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {\n      const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (groupper) {\n        newIds[groupper.id] = true;\n        this._current[groupper.id] = groupper;\n        const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n        groupper.makeTabbable(isTabbable);\n      }\n    }\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n  _enterGroupper(element, relatedEvent) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n    if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n      const next = tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement: element,\n        useActiveModalizer: true\n      });\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (relatedEvent) {\n          // When the application hasn't prevented default,\n          // we consider the event completely handled, hence we\n          // prevent the initial event's default action and stop\n          // propagation.\n          relatedEvent.preventDefault();\n          relatedEvent.stopImmediatePropagation();\n        }\n        next.focus();\n        return next;\n      }\n    }\n    return null;\n  }\n  _escapeGroupper(element, relatedEvent, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n    if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {\n      let next;\n      if (element !== groupperElement || fromModalizer) {\n        next = groupper.getFirst(true);\n      } else {\n        const parentElement = dom.getParentElement(groupperElement);\n        const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n        groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n        next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n      }\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (groupper) {\n          groupper.makeTabbable(false);\n        }\n        // This part happens asynchronously inside setTimeout,\n        // so no need to prevent default or stop propagation.\n        next.focus();\n        return next;\n      }\n    }\n    return null;\n  }\n  moveFocus(element, action) {\n    return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);\n  }\n  handleKeyPress(element, event, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {\n      tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n      if (event.key === Keys.Enter) {\n        this._enterGroupper(element, event);\n      } else if (event.key === Keys.Escape) {\n        // We will handle Esc asynchronously, if something in the application will\n        // move focus during the keypress handling, we will not interfere.\n        const focusedElement = tabster.focusedElement.getFocusedElement();\n        tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {\n          if (focusedElement !== tabster.focusedElement.getFocusedElement() && (\n          // A part of Modalizer that has called this handler to escape the active groupper\n          // might have been removed from DOM, if the focus is on body, we still want to handle Esc.\n          fromModalizer && !focusedElement || !fromModalizer)) {\n            // Something else in the application has moved focus, we will not handle Esc.\n            return;\n          }\n          this._escapeGroupper(element, event, fromModalizer);\n        }, 0);\n      }\n    }\n  }\n}\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n    this._keyborg = (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.createKeyborg)(getWindow());\n    this._keyborg.subscribe(this._onChange);\n  }\n  dispose() {\n    super.dispose();\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n      (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.disposeKeyborg)(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n  isNavigatingWithKeyboard() {\n    var _a;\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b;\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n      if (container && input) {\n        const dummyContainer = getDummyInputContainer(input);\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n        if (ctx) {\n          toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n        }\n        if (toFocus) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n        }\n      }\n    });\n  }\n}\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n    if (true) {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.get()).indexOf(element);\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n      if (true) {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n      this._dispatchEvent(isActive);\n    }\n  }\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n    return this._wasFocused;\n  }\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n    this._props = {\n      ...props\n    };\n  }\n  dispose() {\n    var _a;\n    this.makeActive(false);\n    this._onDispose(this);\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n    this._activeElements = [];\n    this._remove();\n  }\n  isActive() {\n    return !!this._isActive;\n  }\n  contains(element) {\n    return dom.nodeContains(this.getElement(), element);\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    var _a, _b;\n    const modalizerElement = this.getElement();\n    if (!modalizerElement) {\n      return null;\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n    if (container) {\n      const findProps = {\n        container,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n        if (next === null) {\n          next = currentElement;\n        }\n        outOfDOMOrder = true;\n      } else {\n        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      }\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  _dispatchEvent(isActive, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.get()) : [element];\n      for (const el of elements) {\n        if (el) {\n          const eventDetail = {\n            id: this.userId,\n            element\n          };\n          const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);\n          el.dispatchEvent(event);\n          if (event.defaultPrevented) {\n            defaultPrevented = true;\n          }\n        }\n      }\n    }\n    return defaultPrevented;\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n}\nclass ModalizerAPI {\n  constructor(tabster,\n  // @deprecated use accessibleCheck.\n  alwaysAccessibleSelector, accessibleCheck) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n      if (part) {\n        delete part[id];\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n          const activationHistory = this._activationHistory;\n          const cleanActivationHistory = [];\n          let prevHistoryItem;\n          // The history order is from most recent to oldest.\n          for (let i = activationHistory.length; i--;) {\n            // Remove from activation history, making sure there are no duplicates\n            // for cases like [modal2, modal1, modal2, modal1]: just removing modal2\n            // will result in [modal1, modal1] and we want just [modal1]. Otherwise,\n            // there is a chance for this array to grow forever in a narrow case of\n            // a modalizer that stays in DOM forever and is being activated/deactivated\n            // switching between other modalizers that come and go.\n            const modalizerUserIdFromHistory = activationHistory[i];\n            if (modalizerUserIdFromHistory === userId) {\n              continue;\n            }\n            if (modalizerUserIdFromHistory !== prevHistoryItem) {\n              prevHistoryItem = modalizerUserIdFromHistory;\n              if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {\n                cleanActivationHistory.unshift(modalizerUserIdFromHistory);\n              }\n            }\n          }\n          this._activationHistory = cleanActivationHistory;\n          if (this.activeId === userId) {\n            const prevActiveId = cleanActivationHistory[0];\n            const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : undefined;\n            this.setActive(prevActive);\n          }\n        }\n      }\n    };\n    this._onKeyDown = event => {\n      var _a;\n      if (event.key !== Keys.Escape) {\n        return;\n      }\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n          if (activeId) {\n            const part = this._parts[activeId];\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param focusedElement - Element that is focused\n     * @param detail - Additional data about the focus event\n     */\n    this._onFocus = (focusedElement, detail) => {\n      var _a;\n      const tabster = this._tabster;\n      const ctx = focusedElement && RootAPI.getTabsterContext(tabster, focusedElement);\n      // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n      if (!ctx || !focusedElement) {\n        return;\n      }\n      const augmentedMap = this._augMap;\n      for (let e = focusedElement; e; e = dom.getParentElement(e)) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(tabster, e, _ariaHidden);\n        }\n      }\n      let modalizer = ctx.modalizer;\n      const tabsterOnFocusedElement = getTabsterOnElement(tabster, focusedElement);\n      const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;\n      if (modalizerOnFocusedElement) {\n        modalizerOnFocusedElement.focused();\n        if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {\n          const parentElement = tabster.getParent(focusedElement);\n          const parentModalizer = parentElement && ((_a = RootAPI.getTabsterContext(tabster, parentElement)) === null || _a === void 0 ? void 0 : _a.modalizer);\n          if (parentModalizer) {\n            modalizer = parentModalizer;\n          } else {\n            this.setActive(undefined);\n            return;\n          }\n        }\n      }\n      // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n      modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      }\n      // Developers calling `element.focus()` should change/deactivate active modalizer\n      if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this._accessibleCheck = accessibleCheck;\n    this._activationHistory = [];\n    this.activeElements = [];\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n    const win = this._win();\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    const win = this._win();\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    // Dispose all modalizers managed by the API\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n  createModalizer(element, props, sys) {\n    var _a;\n    if (true) ;\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n    part[id] = modalizer;\n    const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;\n    // Adding a modalizer which is already focused, activate it\n    if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n    return modalizer;\n  }\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n      this._hiddenUpdate();\n    }, 250);\n  }\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n    if (activeId === userId) {\n      return;\n    }\n    this.activeId = userId;\n    if (activeId) {\n      const part = this._parts[activeId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n    if (userId) {\n      const part = this._parts[userId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n    const activationHistory = this._activationHistory;\n    if (activationHistory[0] !== userId && (userId !== undefined || activationHistory.length > 0)) {\n      activationHistory.unshift(userId);\n    }\n  }\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n        if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n        if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n        tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (true) {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n    return false;\n  }\n  activate(modalizerElementOrContainer) {\n    var _a;\n    const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : undefined;\n    if (!modalizerElementOrContainer || modalizerToActivate) {\n      this.setActive(modalizerToActivate);\n      return true;\n    }\n    return false;\n  }\n  acceptElement(element, state) {\n    var _a;\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.get();\n        if (el && (dom.nodeContains(element, el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n    if (ret !== undefined) {\n      state.skippedFocusable = true;\n    }\n    return ret;\n  }\n  _hiddenUpdate() {\n    var _a;\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];\n    const activeModalizerElements = [];\n    for (const userId of Object.keys(parts)) {\n      const modalizerParts = parts[userId];\n      for (const id of Object.keys(modalizerParts)) {\n        const modalizer = modalizerParts[id];\n        const el = modalizer.getElement();\n        const props = modalizer.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n        if (el) {\n          if (userId === activeId) {\n            activeModalizerElements.push(el);\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n    const toggle = (element, hide) => {\n      var _a;\n      const tagName = element.tagName;\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n      let isAugmented = false;\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && !((_a = this._accessibleCheck) === null || _a === void 0 ? void 0 : _a.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n      if (isAugmented) {\n        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n    const walk = element => {\n      var _a;\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        let skip = false;\n        let containsModalizer = false;\n        let containedByModalizer = false;\n        if (allVisibleElements) {\n          const elParent = tabster.getParent(el);\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n            if (dom.nodeContains(el, c)) {\n              containsModalizer = true;\n              break;\n            } else if (dom.nodeContains(c, elParent)) {\n              // tabster.getParent() could be provided by the application to\n              // handle, for example, virtual parents. Making sure, we are\n              // not setting aria-hidden on elements which are virtually\n              // inside modalizer.\n              containedByModalizer = true;\n            }\n          }\n          if (containsModalizer || ((_a = el.__tabsterElementFlags) === null || _a === void 0 ? void 0 : _a.noDirectAriaHidden)) {\n            walk(el);\n          } else if (!skip && !containedByModalizer) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n    hiddenElements.forEach(e => toggle(e, true));\n    if (body) {\n      walk(body);\n    }\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.get()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\n   * Called when an element is focused outside of an active modalizer.\n   * Attempts to pull focus back into the active modalizer\n   * @param outsideElement - An element being focused outside of the modalizer\n   */\n  _restoreModalizerFocus(outsideElement) {\n    var _a;\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n    const focusedElement = this._tabster.focusedElement.getFocusedElement();\n    const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);\n    if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {\n      // If there is no currently focused element, or the currently focused element\n      // is in the active modalizer, we don't need to do anything.\n      return;\n    }\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n    if (container) {\n      let toFocus = tabster.focusable.findFirst({\n        container,\n        useActiveModalizer: true\n      });\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = tabster.focusable.findLast({\n            container,\n            useActiveModalizer: true\n          });\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n        tabster.focusedElement.focus(toFocus);\n        return;\n      }\n    }\n    // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n    outsideElement.blur();\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n      const container = this._element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, undefined, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n        if (memorized && this._tabster.focusable.isFocusable(memorized)) {\n          toFocus = memorized;\n        }\n        if (toFocus) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n    this._setHandlers(this._onFocusDummyInput);\n  }\n}\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n    super(tabster, element, props);\n    this._visible = {};\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n          const state = this.getState(el);\n          if (state) {\n            el.dispatchEvent(new MoverStateEvent(state));\n          }\n        }\n      }\n    };\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n      this._observeState();\n    }\n    this._onDispose = onDispose;\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n      delete this._intersectionObserver;\n    }\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n    if (this._unobserve) {\n      this._unobserve();\n      delete this._unobserve;\n    }\n    const win = this._win();\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n  }\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n        delete this._setCurrentTimer;\n        const changed = [];\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n              if (state) {\n                el.dispatchEvent(new MoverStateEvent(state));\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n  getCurrent() {\n    var _a;\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const container = this.getElement();\n    const currentIsDummy = container && getDummyInputContainer(currentElement) === container;\n    if (!container) {\n      return null;\n    }\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {\n      const findProps = {\n        currentElement,\n        referenceElement,\n        container,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = this._tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  acceptElement(element, state) {\n    var _a, _b;\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {\n      let found;\n      if (memorizeCurrent) {\n        const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          useActiveModalizer: true\n        });\n      }\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.rejectElementsFrom = moverElement;\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n    return undefined;\n  }\n  _observeState() {\n    const element = this.getElement();\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n    const win = this._win();\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = dom.createMutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n      requestUpdate();\n    });\n    const setElement = (element, remove) => {\n      var _a, _b;\n      const current = allElements.get(element);\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n        return NodeFilter.FILTER_SKIP;\n      });\n      if (walker) {\n        walker.currentNode = element;\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n    const removeWalk = element => {\n      const current = allElements.get(element);\n      if (current) {\n        setElement(element, true);\n      }\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        removeWalk(el);\n      }\n    };\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n    const getMoverGroupper = element => {\n      const ret = {};\n      for (let el = element; el; el = dom.getParentElement(el)) {\n        const toe = getTabsterOnElement(this._tabster, el);\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n      return ret;\n    };\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n  getState(element) {\n    const id = getElementUId(this._win, element);\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n    return undefined;\n  }\n}\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n      win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n    this._onFocus = element => {\n      var _a;\n      // When something in the app gets focused, we are making sure that\n      // the relevant context Mover is aware of it.\n      // Looking for the relevant context Mover from the currently\n      // focused element parent, not from the element itself, because the\n      // Mover element itself cannot be its own current (but might be\n      // current for its parent Mover).\n      let currentFocusableElement = element;\n      let deepestFocusableElement = element;\n      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n        // We go through all Movers up from the focused element and\n        // set their current element to the deepest focusable of that\n        // Mover.\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n        if (mover) {\n          mover.setCurrent(deepestFocusableElement);\n          currentFocusableElement = undefined;\n        }\n        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {\n          currentFocusableElement = deepestFocusableElement = el;\n        }\n      }\n    };\n    this._onKeyDown = async event => {\n      var _a;\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n        delete this._ignoredInputTimer;\n      }\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      const key = event.key;\n      let moverKey;\n      if (key === Keys.ArrowDown) {\n        moverKey = MoverKeys.ArrowDown;\n      } else if (key === Keys.ArrowRight) {\n        moverKey = MoverKeys.ArrowRight;\n      } else if (key === Keys.ArrowUp) {\n        moverKey = MoverKeys.ArrowUp;\n      } else if (key === Keys.ArrowLeft) {\n        moverKey = MoverKeys.ArrowLeft;\n      } else if (key === Keys.PageDown) {\n        moverKey = MoverKeys.PageDown;\n      } else if (key === Keys.PageUp) {\n        moverKey = MoverKeys.PageUp;\n      } else if (key === Keys.Home) {\n        moverKey = MoverKeys.Home;\n      } else if (key === Keys.End) {\n        moverKey = MoverKeys.End;\n      }\n      if (!moverKey) {\n        return;\n      }\n      const focused = this._tabster.focusedElement.getFocusedElement();\n      if (!focused || (await this._isIgnoredInput(focused, key))) {\n        return;\n      }\n      this._moveFocus(focused, moverKey, event);\n    };\n    this._onMoveFocus = e => {\n      var _a;\n      const element = e.composedPath()[0];\n      const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;\n      if (element && key !== undefined && !e.defaultPrevented) {\n        this._moveFocus(element, key);\n        e.stopImmediatePropagation();\n      }\n    };\n    this._onMemorizedElement = e => {\n      var _a;\n      const target = e.composedPath()[0];\n      let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;\n      if (target) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, target);\n        const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;\n        if (mover) {\n          if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {\n            memorizedElement = undefined;\n          }\n          mover.setCurrent(memorizedElement);\n          e.stopImmediatePropagation();\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    var _a;\n    const win = this._win();\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n    win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n        delete this._movers[moverId];\n      }\n    });\n  }\n  createMover(element, props, sys) {\n    if (true) ;\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n  moveFocus(fromElement, key) {\n    return this._moveFocus(fromElement, key);\n  }\n  _moveFocus(fromElement, key, relatedEvent) {\n    var _a, _b;\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, fromElement, {\n      checkRtl: true\n    });\n    if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {\n      return null;\n    }\n    const mover = ctx.mover;\n    const container = mover.getElement();\n    if (ctx.groupperBeforeMover) {\n      const groupper = ctx.groupper;\n      if (groupper && !groupper.isActive(true)) {\n        // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n        // the grouppers between the current element and the current mover.\n        for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) {\n          if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {\n            return null;\n          }\n        }\n      } else {\n        return null;\n      }\n    }\n    if (!container) {\n      return null;\n    }\n    const focusable = tabster.focusable;\n    const moverProps = mover.getProps();\n    const direction = moverProps.direction || MoverDirections.Both;\n    const isBoth = direction === MoverDirections.Both;\n    const isVertical = isBoth || direction === MoverDirections.Vertical;\n    const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n    const isGridLinear = direction === MoverDirections.GridLinear;\n    const isGrid = isGridLinear || direction === MoverDirections.Grid;\n    const isCyclic = moverProps.cyclic;\n    let next;\n    let scrollIntoViewArg;\n    let focusedElementRect;\n    let focusedElementX1 = 0;\n    let focusedElementX2 = 0;\n    if (isGrid) {\n      focusedElementRect = fromElement.getBoundingClientRect();\n      focusedElementX1 = Math.ceil(focusedElementRect.left);\n      focusedElementX2 = Math.floor(focusedElementRect.right);\n    }\n    if (ctx.rtl) {\n      if (key === MoverKeys.ArrowRight) {\n        key = MoverKeys.ArrowLeft;\n      } else if (key === MoverKeys.ArrowLeft) {\n        key = MoverKeys.ArrowRight;\n      }\n    }\n    if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {\n      next = focusable.findNext({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n      if (next && isGrid) {\n        const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n        if (!isGridLinear && focusedElementX2 > nextElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {\n      next = focusable.findPrev({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n      if (next && isGrid) {\n        const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n        if (!isGridLinear && nextElementX2 > focusedElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.Home) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            var _a;\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n            if (el !== fromElement && focusedElementX1 <= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.End) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            var _a;\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n            if (el !== fromElement && focusedElementX1 >= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.PageUp) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        isBackward: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n          return true;\n        }\n      });\n      // will be on the first column move forward and preserve previous column\n      if (isGrid && next) {\n        const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n            if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      }\n      scrollIntoViewArg = false;\n    } else if (key === MoverKeys.PageDown) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n          return true;\n        }\n      });\n      // will be on the last column move backwards and preserve previous column\n      if (isGrid && next) {\n        const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n            if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      }\n      scrollIntoViewArg = true;\n    } else if (isGrid) {\n      const isBackward = key === MoverKeys.ArrowUp;\n      const ax1 = focusedElementX1;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const ay1 = Math.ceil(focusedElementRect.top);\n      const ax2 = focusedElementX2;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const ay2 = Math.floor(focusedElementRect.bottom);\n      let targetElement;\n      let lastDistance;\n      let lastIntersection = 0;\n      focusable.findAll({\n        container,\n        currentElement: fromElement,\n        isBackward,\n        onElement: el => {\n          // Find element which has maximal intersection with the focused element horizontally,\n          // or the closest one.\n          const rect = el.getBoundingClientRect();\n          const bx1 = Math.ceil(rect.left);\n          const by1 = Math.ceil(rect.top);\n          const bx2 = Math.floor(rect.right);\n          const by2 = Math.floor(rect.bottom);\n          if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n            // Only consider elements which are below/above curretly focused.\n            return true;\n          }\n          const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n          const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n          if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n            // Element intersects with the focused element on X axis.\n            const intersection = xIntersectionWidth / minWidth;\n            if (intersection > lastIntersection) {\n              targetElement = el;\n              lastIntersection = intersection;\n            }\n          } else if (lastIntersection === 0) {\n            // If we didn't have intersection, try just the closest one.\n            const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n            if (lastDistance === undefined || distance < lastDistance) {\n              lastDistance = distance;\n              targetElement = el;\n            }\n          } else if (lastIntersection > 0) {\n            // Element doesn't intersect, but we had intersection already, stop search.\n            return false;\n          }\n          return true;\n        }\n      });\n      next = targetElement;\n    }\n    if (next && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({\n      by: \"mover\",\n      owner: container,\n      next,\n      relatedEvent\n    })))) {\n      if (scrollIntoViewArg !== undefined) {\n        scrollIntoView(this._win, next, scrollIntoViewArg);\n      }\n      if (relatedEvent) {\n        relatedEvent.preventDefault();\n        relatedEvent.stopImmediatePropagation();\n      }\n      (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(next);\n      return next;\n    }\n    return null;\n  }\n  async _isIgnoredInput(element, key) {\n    if (element.getAttribute(\"aria-expanded\") === \"true\" && element.hasAttribute(\"aria-activedescendant\")) {\n      // It is likely a combobox with expanded options and arrow keys are\n      // controlled by it.\n      return true;\n    }\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = dom.getSelection(element);\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n          const win = this._win();\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = dom.getSelection(element) || {};\n          // Get selection gives incorrect value if we call it syncronously onKeyDown.\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = dom.getSelection(element) || {};\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n            if (anchorNode && focusNode) {\n              if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n                    const nodeText = node.textContent;\n                    if (nodeText && !dom.getFirstChild(node)) {\n                      const len = nodeText.length;\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n                    let stop = false;\n                    for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n                    return stop;\n                  };\n                  addOffsets(element);\n                }\n              }\n            }\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n      if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {\n        return true;\n      }\n      if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n    const removedNodes = new Set();\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {\n          // removedNodes helps to make sure we are not recreating things\n          // for the removed elements.\n          // For some reason, if we do removeChild() and setAttribute() on the\n          // removed child in the same tick, both the child removal and the attribute\n          // change will be present in the mutation records. And the attribute change\n          // will follow the child removal.\n          // So, we remember the removed nodes and ignore attribute changes for them.\n          if (!removedNodes.has(target)) {\n            updateTabsterByAttribute(tabster, target);\n          }\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          const removedNode = removed[i];\n          removedNodes.add(removedNode);\n          updateTabsterElements(removedNode, true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n    removedNodes.clear();\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n  function processNode(element, removed) {\n    var _a;\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n    const uid = element.__tabsterElementUID;\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n    return NodeFilter.FILTER_SKIP;\n  }\n  const observer = dom.createMutationObserver(onMutation);\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TABSTER_ATTRIBUTE_NAME]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n          const settleTime = 300;\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n    this.onObservedElementUpdate = element => {\n      var _a;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n          info.prevNames = observedNames;\n        }\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          }\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          obn[uid] = info;\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n        delete this._observedById[uid];\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n    this._observedById = {};\n    this._observedByName = {};\n  }\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n    if (w) {\n      const win = this._win();\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n      delete this._waiting[key];\n    }\n  }\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns existing element by observed name\n   *\n   * @param observedName An observed name\n   * @param accessibility Optionally, return only if the element is accessible or focusable\n   * @returns HTMLElement | null\n   */\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n        if (el) {\n          if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n        return el;\n      }\n    }\n    return null;\n  }\n  /**\n   * Waits for the element to appear in the DOM and returns it.\n   *\n   * @param observedName An observed name\n   * @param timeout Wait no longer than this timeout\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n   * @returns Promise<HTMLElement | null>\n   */\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        },\n        status: ObservedElementRequestStatuses.Succeeded\n      };\n    }\n    let prefix;\n    if (accessibility === ObservedElementAccessibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccessibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n    if (w && w.request) {\n      return w.request;\n    }\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n        delete this._waiting[key];\n        if (w.request) {\n          w.request.status = ObservedElementRequestStatuses.TimedOut;\n        }\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    }).catch(() => {\n      // Ignore the error, it is expected to be rejected when the request is canceled.\n      return null;\n    });\n    const request = {\n      result: promise,\n      cancel: () => {\n        if (request.status === ObservedElementRequestStatuses.Waiting) {\n          // cancel() function is callable by user, someone might call it after request is finished,\n          // we are making sure that status of a finished request is not overriden.\n          request.status = ObservedElementRequestStatuses.Canceled;\n        }\n        this._rejectWaiting(key, true);\n      },\n      status: ObservedElementRequestStatuses.Waiting\n    };\n    w.request = request;\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n    return request;\n  }\n  requestFocus(observedName, timeout, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n    const request = this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    const ret = {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true, undefined, options.preventScroll) : false),\n      cancel: () => {\n        request.cancel();\n      },\n      status: request.status\n    };\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n      ret.status = request.status;\n    });\n    return ret;\n  }\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n    const win = this._win();\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n      delete this._waiting[key];\n      if (waiting.request) {\n        waiting.request.status = ObservedElementRequestStatuses.Succeeded;\n      }\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);\n      }\n    }\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n      resolveAccessible();\n    }\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n      resolveFocusable();\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n}\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const win = this._win();\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n      const target = e.target.body || e.target;\n      const outlineElements = this._getDOM(target);\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n      this._curPos = undefined;\n      this._setOutlinePosition();\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n  setup(props) {\n    _props = {\n      ..._props,\n      ...props\n    };\n    const win = this._win();\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._curPos = undefined;\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n        this._updateOutline();\n      }\n      return true;\n    }\n    return false;\n  }\n  _updateOutline() {\n    this._setOutlinePosition();\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    if (!this._outlinedElement) {\n      return;\n    }\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n      this._updateOutline();\n    }, 30);\n  }\n  _setVisibility(visible) {\n    this._isVisible = visible;\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n        this._curPos = undefined;\n      }\n    }\n  }\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n    const outlineElements = this._getDOM(this._outlinedElement);\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n    if (!outlineElements || !win) {\n      return;\n    }\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n      this._curOutlineElements = outlineElements;\n    }\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n    if (!scrollingElement) {\n      return;\n    }\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n      if (!win) {\n        return;\n      }\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements;\n      // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n      this._allOutlineElements.push(outlineElements);\n    }\n    return win.__tabsterOutline.elements;\n  }\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n    if (!outline) {\n      return;\n    }\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n    const outlineElements = outline && outline.elements;\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n      delete outline.elements;\n    }\n  }\n  static _isParentChild(parent, child) {\n    return child === parent ||\n    // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n}\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nclass UncontrolledAPI {\n  constructor(isUncontrolledCompletely) {\n    this._isUncontrolledCompletely = isUncontrolledCompletely;\n  }\n  isUncontrolledCompletely(element, completely) {\n    var _a;\n    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);\n    // If isUncontrolledCompletely callback is not defined or returns undefined, then the default\n    // behaviour is to return the uncontrolled.completely value from the element.\n    return isUncontrolledCompletely === undefined ? completely : isUncontrolledCompletely;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Restorer extends TabsterPart {\n  constructor(tabster, element, props) {\n    var _a;\n    super(tabster, element, props);\n    this._hasFocus = false;\n    this._onFocusOut = e => {\n      var _a;\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      if (element && e.relatedTarget === null) {\n        element.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n      if (element && !dom.nodeContains(element, e.relatedTarget)) {\n        this._hasFocus = false;\n      }\n    };\n    this._onFocusIn = () => {\n      this._hasFocus = true;\n    };\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusin\", this._onFocusIn);\n      // set hasFocus when the instance is created, in case focus has already moved within it\n      this._hasFocus = dom.nodeContains(element, element && dom.getActiveElement(element.ownerDocument));\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusin\", this._onFocusIn);\n      if (this._hasFocus) {\n        const doc = this._tabster.getWindow().document;\n        doc.body.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n    }\n  }\n}\nclass History {\n  constructor(getWindow) {\n    this._stack = [];\n    this._getWindow = getWindow;\n  }\n  /**\n   * Push a weak element to the top of the history stack.\n   * If the stack is full, the bottom weak element is removed.\n   * If the element is already at the top of the stack, it is not duplicated.\n   */\n  push(element) {\n    var _a;\n    // Don't duplicate the top of history\n    if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {\n      return;\n    }\n    if (this._stack.length > History.DEPTH) {\n      this._stack.shift();\n    }\n    this._stack.push(new WeakHTMLElement(this._getWindow, element));\n  }\n  /**\n   * Pop the first element from the history that satisfies the callback.\n   * The history is searched from the top to the bottom (from the most recent to the least recent).\n   *\n   * If a weak reference to the element is broken,\n   * or the element is no longer in the DOM,\n   * the element is removed from the top of the stack while popping.\n   *\n   * If no matching element is found, undefined is returned.\n   * If the stack is empty, undefined is returned.\n   */\n  pop(filter) {\n    if (filter === void 0) {\n      filter = () => true;\n    }\n    var _a;\n    const doc = this._getWindow().document;\n    for (let index = this._stack.length - 1; index >= 0; index--) {\n      const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();\n      if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {\n        return maybeElement;\n      }\n    }\n    return undefined;\n  }\n}\nHistory.DEPTH = 10;\nclass RestorerAPI {\n  constructor(tabster) {\n    this._onRestoreFocus = e => {\n      var _a, _b;\n      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n      // ShadowDOM will have shadowRoot as e.target.\n      const source = e.composedPath()[0];\n      if (source) {\n        // source id must be recovered before source is removed from DOM\n        // otherwise it'll be unreachable\n        // (as tabster on element will not be available through getTabsterOnElement)\n        const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;\n        this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);\n      }\n    };\n    this._onFocusIn = element => {\n      var _a;\n      if (!element) {\n        return;\n      }\n      const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {\n        return;\n      }\n      this._history.push(element);\n    };\n    this._restoreFocus = (source, sourceId) => {\n      var _a;\n      // don't restore focus if focus isn't lost to body\n      const doc = this._getWindow().document;\n      if (dom.getActiveElement(doc) !== doc.body) {\n        return;\n      }\n      if (\n      // clicking on any empty space focuses body - this is can be a false positive\n      !this._keyboardNavState.isNavigatingWithKeyboard() &&\n      // Source no longer exists on DOM - always restore focus\n      dom.nodeContains(doc.body, source)) {\n        return;\n      }\n      const getId = element => {\n        var _a, _b;\n        const restorerProps = (_b = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps();\n        // We return id or undefined if there is actual restorer on the element,\n        // and null otherwise. To filter out elements that had restorers in their lifetime\n        // but don't have them anymore.\n        return restorerProps ? restorerProps.id : null;\n      };\n      // sourceId is undefined or string, if there is no Restorer on the target, the element will\n      // be filtered out because getId() will return null.\n      (_a = this._history.pop(target => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n    this._history = new History(this._getWindow);\n    this._keyboardNavState = tabster.keyboardNavigation;\n    this._focusedElementState = tabster.focusedElement;\n    this._focusedElementState.subscribe(this._onFocusIn);\n  }\n  dispose() {\n    const win = this._getWindow();\n    this._focusedElementState.unsubscribe(this._onFocusIn);\n    this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n    win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n  }\n  createRestorer(element, props) {\n    const restorer = new Restorer(this._tabster, element, props);\n    // Focus might already be on a restorer target when it gets created so the focusin will not do anything\n    if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {\n      this._history.push(element);\n    }\n    return restorer;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getActiveElement(doc) {\n  var _a;\n  let activeElement = doc.activeElement;\n  while ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction nodeContains(node, otherNode) {\n  var _a, _b;\n  if (!node || !otherNode) {\n    return false;\n  }\n  let currentNode = otherNode;\n  while (currentNode) {\n    if (currentNode === node) {\n      return true;\n    }\n    if (typeof currentNode.assignedElements !== \"function\" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {\n      // Element is slotted\n      currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;\n    } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n      // Element is in shadow root\n      currentNode = currentNode.host;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return false;\n}\nfunction getParentNode(node) {\n  if (!node) {\n    return null;\n  }\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n    return node.host;\n  }\n  return node.parentNode;\n}\nfunction getParentElement(element) {\n  for (let parentNode = getParentNode(element); parentNode; parentNode = getParentNode(parentNode)) {\n    if (parentNode.nodeType === Node.ELEMENT_NODE) {\n      return parentNode;\n    }\n  }\n  return null;\n}\nfunction getFirstChild(node) {\n  if (!node) {\n    return null;\n  }\n  if (node.shadowRoot) {\n    const child = getFirstChild(node.shadowRoot);\n    if (child) {\n      return child;\n    }\n    // If the attached shadowRoot has no children, just try ordinary children,\n    // that might come after.\n  }\n  return node.firstChild;\n}\nfunction getLastChild$1(node) {\n  if (!node) {\n    return null;\n  }\n  if (!node.lastChild && node.shadowRoot) {\n    return getLastChild$1(node.shadowRoot);\n  }\n  return node.lastChild;\n}\nfunction getNextSibling(node) {\n  return (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\n}\nfunction getPreviousSibling(node) {\n  var _a;\n  if (!node) {\n    return null;\n  }\n  let sibling = node.previousSibling;\n  if (!sibling && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {\n    sibling = getLastChild$1(node.parentElement.shadowRoot);\n  }\n  return sibling;\n}\nfunction getFirstElementChild(element) {\n  let child = getFirstChild(element);\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getNextSibling(child);\n  }\n  return child;\n}\nfunction getLastElementChild(element) {\n  let child = getLastChild$1(element);\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getPreviousSibling(child);\n  }\n  return child;\n}\nfunction getNextElementSibling(element) {\n  let sibling = getNextSibling(element);\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getNextSibling(sibling);\n  }\n  return sibling;\n}\nfunction getPreviousElementSibling(element) {\n  let sibling = getPreviousSibling(element);\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getPreviousSibling(sibling);\n  }\n  return sibling;\n}\nfunction appendChild(parent, child) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.appendChild(child) : parent.appendChild(child);\n}\nfunction insertBefore(parent, child, referenceChild) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.insertBefore(child, referenceChild) : parent.insertBefore(child, referenceChild);\n}\nfunction getSelection(ref) {\n  var _a;\n  const win = (_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n  if (!win) {\n    return null;\n  }\n  for (let el = ref; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      const tmp = el;\n      // ShadowRoot.getSelection() exists only in Chrome.\n      if (tmp.getSelection) {\n        return tmp.getSelection() || null;\n      }\n      break;\n    }\n  }\n  return win.getSelection() || null;\n}\nfunction getElementsByName(referenceElement, name) {\n  for (let el = referenceElement; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      // Shadow root doesn't have getElementsByName()...\n      return el.querySelectorAll(`[name=${name}]`);\n    }\n  }\n  return referenceElement.ownerDocument.getElementsByName(name);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getLastChild(container) {\n  let lastChild = null;\n  for (let i = getLastElementChild(container); i; i = getLastElementChild(i)) {\n    lastChild = i;\n  }\n  return lastChild || undefined;\n}\nclass ShadowTreeWalker {\n  constructor(doc, root, whatToShow, filter) {\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n    this._acceptNode = node => {\n      var _a;\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const shadowRoot = node.shadowRoot;\n        if (shadowRoot) {\n          const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n            acceptNode: this._acceptNode\n          });\n          this._walkerStack.unshift(walker);\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          if (typeof this.filter === \"function\") {\n            return this.filter(node);\n          } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n            return this.filter.acceptNode(node);\n          } else if (this.filter === null) {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n    const shadowRoot = root.shadowRoot;\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      this._walkerStack.unshift(walker);\n    }\n  }\n  get currentNode() {\n    return this._currentNode;\n  }\n  set currentNode(node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\"Cannot set currentNode to a node that is not contained by the root node.\");\n    }\n    const walkers = [];\n    let curNode = node;\n    let currentWalkerCurrentNode = node;\n    this._currentNode = node;\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode;\n        const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n          acceptNode: this._acceptNode\n        });\n        walkers.push(walker);\n        walker.currentNode = currentWalkerCurrentNode;\n        this._currentSetFor.add(walker);\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n      acceptNode: this._acceptNode\n    });\n    walkers.push(walker);\n    walker.currentNode = currentWalkerCurrentNode;\n    this._currentSetFor.add(walker);\n    this._walkerStack = walkers;\n  }\n  firstChild() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  lastChild() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  nextNode() {\n    var _a;\n    const nextNode = this._walkerStack[0].nextNode();\n    if (nextNode) {\n      const shadowRoot = nextNode.shadowRoot;\n      if (shadowRoot) {\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(nextNode);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return nextNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        return this.nextNode();\n      }\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        return this.nextNode();\n      } else {\n        return null;\n      }\n    }\n  }\n  previousNode() {\n    var _a, _b;\n    const currentWalker = this._walkerStack[0];\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          return this.previousNode();\n        } else {\n          return null;\n        }\n      }\n      const lastChild = getLastChild(currentWalker.root);\n      if (lastChild) {\n        currentWalker.currentNode = lastChild;\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(lastChild);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(lastChild);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return lastChild;\n        }\n      }\n    }\n    const previousNode = currentWalker.previousNode();\n    if (previousNode) {\n      const shadowRoot = previousNode.shadowRoot;\n      if (shadowRoot) {\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(previousNode);\n        } else if ((_b = this.filter) === null || _b === void 0 ? void 0 : _b.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return previousNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        return this.previousNode();\n      }\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        return this.previousNode();\n      } else {\n        return null;\n      }\n    }\n  }\n  nextSibling() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  previousSibling() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  parentNode() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n}\nfunction createShadowTreeWalker(doc, root, whatToShow, filter) {\n  return new ShadowTreeWalker(doc, root, whatToShow, filter);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass ShadowMutationObserver {\n  static _overrideAttachShadow(win) {\n    const origAttachShadow = win.Element.prototype.attachShadow;\n    if (origAttachShadow.__origAttachShadow) {\n      return;\n    }\n    Element.prototype.attachShadow = function (options) {\n      const shadowRoot = origAttachShadow.call(this, options);\n      for (const shadowObserver of ShadowMutationObserver._shadowObservers) {\n        shadowObserver._addSubObserver(shadowRoot);\n      }\n      return shadowRoot;\n    };\n    Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;\n  }\n  constructor(callback) {\n    this._isObserving = false;\n    this._callbackWrapper = (mutations, observer) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          const removed = mutation.removedNodes;\n          const added = mutation.addedNodes;\n          for (let i = 0; i < removed.length; i++) {\n            this._walkShadows(removed[i], true);\n          }\n          for (let i = 0; i < added.length; i++) {\n            this._walkShadows(added[i]);\n          }\n        }\n      }\n      this._callback(mutations, observer);\n    };\n    this._callback = callback;\n    this._observer = new MutationObserver(this._callbackWrapper);\n    this._subObservers = new Map();\n  }\n  _addSubObserver(shadowRoot) {\n    if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {\n      return;\n    }\n    if (this._options.subtree && nodeContains(this._root, shadowRoot)) {\n      const subObserver = new MutationObserver(this._callbackWrapper);\n      this._subObservers.set(shadowRoot, subObserver);\n      if (this._isObserving) {\n        subObserver.observe(shadowRoot, this._options);\n      }\n      this._walkShadows(shadowRoot);\n    }\n  }\n  disconnect() {\n    this._isObserving = false;\n    delete this._options;\n    ShadowMutationObserver._shadowObservers.delete(this);\n    for (const subObserver of this._subObservers.values()) {\n      subObserver.disconnect();\n    }\n    this._subObservers.clear();\n    this._observer.disconnect();\n  }\n  observe(target, options) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n    const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;\n    if (!doc || !win) {\n      return;\n    }\n    ShadowMutationObserver._overrideAttachShadow(win);\n    ShadowMutationObserver._shadowObservers.add(this);\n    this._root = target;\n    this._options = options;\n    this._isObserving = true;\n    this._observer.observe(target, options);\n    this._walkShadows(target);\n  }\n  _walkShadows(target, remove) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n    if (!doc) {\n      return;\n    }\n    if (target === doc) {\n      target = doc.body;\n    } else {\n      const shadowRoot = target.shadowRoot;\n      if (shadowRoot) {\n        this._addSubObserver(shadowRoot);\n        return;\n      }\n    }\n    const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: node => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          if (remove) {\n            const subObserver = this._subObservers.get(node);\n            if (subObserver) {\n              subObserver.disconnect();\n              this._subObservers.delete(node);\n            }\n          } else {\n            const shadowRoot = node.shadowRoot;\n            if (shadowRoot) {\n              this._addSubObserver(shadowRoot);\n            }\n          }\n        }\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n  takeRecords() {\n    const records = this._observer.takeRecords();\n    for (const subObserver of this._subObservers.values()) {\n      records.push(...subObserver.takeRecords());\n    }\n    return records;\n  }\n}\nShadowMutationObserver._shadowObservers = /*#__PURE__*/new Set();\nfunction createShadowMutationObserver(callback) {\n  return new ShadowMutationObserver(callback);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction shadowQuerySelector(node, selector, all) {\n  // TODO: This is probably slow. Optimize to use each shadowRoot's querySelector/querySelectorAll\n  //       instead of walking the tree.\n  const elements = [];\n  walk(node, selector);\n  return elements;\n  function walk(from, selector) {\n    let el = null;\n    const walker = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: n => {\n        if (n.nodeType === Node.ELEMENT_NODE) {\n          if (n.matches(selector)) {\n            el = n;\n            elements.push(el);\n            return all ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n          }\n          const shadowRoot = n.shadowRoot;\n          if (shadowRoot) {\n            walk(shadowRoot, selector);\n            return !all && elements.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n          }\n        }\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n}\nfunction querySelectorAll(node, selector) {\n  return shadowQuerySelector(node, selector, true);\n}\nfunction querySelector(node, selector) {\n  return shadowQuerySelector(node, selector, false)[0] || null;\n}\nfunction getElementById(doc, id) {\n  return querySelector(doc, \"#\" + id);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// TODO: The functions below do not consider Shadow DOM slots yet. We will be adding\n// support for slots as the need arises.\n\nvar shadowDOMAPI = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    appendChild: appendChild,\n    createMutationObserver: createShadowMutationObserver,\n    createTreeWalker: createShadowTreeWalker,\n    getActiveElement: getActiveElement,\n    getElementById: getElementById,\n    getElementsByName: getElementsByName,\n    getFirstChild: getFirstChild,\n    getFirstElementChild: getFirstElementChild,\n    getLastChild: getLastChild$1,\n    getLastElementChild: getLastElementChild,\n    getNextElementSibling: getNextElementSibling,\n    getNextSibling: getNextSibling,\n    getParentElement: getParentElement,\n    getParentNode: getParentNode,\n    getPreviousElementSibling: getPreviousElementSibling,\n    getPreviousSibling: getPreviousSibling,\n    getSelection: getSelection,\n    insertBefore: insertBefore,\n    nodeContains: nodeContains,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n}\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore {\n  constructor(win, props) {\n    var _a, _b;\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"8.5.6\";\n    this._noop = false;\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n      return this._win;\n    };\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    if (props === null || props === void 0 ? void 0 : props.DOMAPI) {\n      setDOMAPI({\n        ...props.DOMAPI\n      });\n    }\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI(\n    // TODO: Remove checkUncontrolledTrappingFocus in the next major version.\n    (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus));\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow);\n    // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n  /**\n   * Merges external props with the current props. Not all\n   * props can/should be mergeable, so let's add more as we move on.\n   * @param props Tabster props\n   */\n  _mergeProps(props) {\n    var _a;\n    if (!props) {\n      return;\n    }\n    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;\n  }\n  createTabster(noRefCount, props) {\n    const wrapper = new Tabster(this);\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n    this._mergeProps(props);\n    return wrapper;\n  }\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n    this._dummyObserver.dispose();\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n    this._wrappers.clear();\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n    return entry;\n  }\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n    this._forgetMemorizedElements.push(this._win.document.body);\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n  queueInit(callback) {\n    var _a;\n    if (!this._win) {\n      return;\n    }\n    this._initQueue.push(callback);\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n    const queue = this._initQueue;\n    // Resetting the queue before calling the callbacks to avoid recursion.\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n}\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n  if (tabster) {\n    return tabster.createTabster(false, props);\n  }\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\nfunction getShadowDOMAPI() {\n  return shadowDOMAPI;\n}\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.groupper;\n}\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n  return tabsterCore.outline;\n}\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n  return tabsterCore.deloser;\n}\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n * @param accessibleCheck An optional callback that will be called when\n * active Modalizer wants to hide an element that doesn't belong to it from\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\n * but allows to address the elements programmatically rather than with a selector.\n * If the callback returns true, the element will not receive aria-hidden.\n */\nfunction getModalizer(tabster,\n// @deprecated use accessibleCheck.\nalwaysAccessibleSelector, accessibleCheck) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);\n  }\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction getRestorer(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.restorer) {\n    tabsterCore.restorer = new RestorerAPI(tabsterCore);\n  }\n  return tabsterCore.restorer;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n  if (core._noop !== noop) {\n    core._noop = noop;\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n        updateTabsterByAttribute(core, element);\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar EventsTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new GroupperMoveFocusEvent(...)). */\nfunction dispatchGroupperMoveFocusEvent(target, action) {\n  return target.dispatchEvent(new GroupperMoveFocusEvent({\n    action\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMoveFocusEvent(...)). */\nfunction dispatchMoverMoveFocusEvent(target, key) {\n  return target.dispatchEvent(new MoverMoveFocusEvent({\n    key\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMemorizedElementEvent(...)). */\nfunction dispatchMoverMemorizedElementEvent(target, memorizedElement) {\n  return target.dispatchEvent(new MoverMemorizedElementEvent({\n    memorizedElement\n  }));\n}\n\n\n//# sourceMappingURL=tabster.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGFic3Rlci9kaXN0L3RhYnN0ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3Rzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXNDO0FBQ2xELHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWSxTQUFTLElBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLFNBQVMsSUFBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVMsSUFBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVksU0FBUyxJQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWSxTQUFTLElBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsSUFBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLElBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsY0FBYyxnQkFBZ0IsZ0JBQWdCLDRCQUE0QixpQkFBaUIsYUFBYSxXQUFXO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFtRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsSUFBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsWUFBWSxJQUFzQztBQUNsRCx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBZTtBQUN4Qyx5QkFBeUIscURBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBZTtBQUMzQyw0QkFBNEIscURBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0IsSUFBc0M7QUFDdEQ7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEdBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBZTtBQUMxQywyQkFBMkIscURBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFlO0FBQzNDLDRCQUE0QixxREFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUtBQXFLLFdBQVc7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLElBQXNDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CO0FBQ2hGLFFBQVE7QUFDUiwrREFBK0Qsb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlEQUFpRDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RCx5Q0FBeUMsb0JBQW9CO0FBQzdELDJDQUEyQyxvQkFBb0I7QUFDL0QsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQixNQUFNLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDNUM7QUFDQTs7QUFFQSxHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFcStDO0FBQ3IrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy90YWJzdGVyL2Rpc3QvdGFic3Rlci5lc20uanM/ODNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBuYXRpdmVGb2N1cywgS0VZQk9SR19GT0NVU0lOLCBLRVlCT1JHX0ZPQ1VTT1VULCBjcmVhdGVLZXlib3JnLCBkaXNwb3NlS2V5Ym9yZyB9IGZyb20gJ2tleWJvcmcnO1xuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jb25zdCBUQUJTVEVSX0FUVFJJQlVURV9OQU1FID0gXCJkYXRhLXRhYnN0ZXJcIjtcbmNvbnN0IFRBQlNURVJfRFVNTVlfSU5QVVRfQVRUUklCVVRFX05BTUUgPSBcImRhdGEtdGFic3Rlci1kdW1teVwiO1xuY29uc3QgRk9DVVNBQkxFX1NFTEVDVE9SID0gLyojX19QVVJFX18qL1tcImFbaHJlZl1cIiwgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pXCIsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLCBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiLCBcIipbdGFiaW5kZXhdXCIsIFwiKltjb250ZW50ZWRpdGFibGVdXCIsIFwiZGV0YWlscyA+IHN1bW1hcnlcIiwgXCJhdWRpb1tjb250cm9sc11cIiwgXCJ2aWRlb1tjb250cm9sc11cIl0uam9pbihcIiwgXCIpO1xuY29uc3QgQXN5bmNGb2N1c1NvdXJjZXMgPSB7XG4gIEVzY2FwZUdyb3VwcGVyOiAxLFxuICBSZXN0b3JlcjogMixcbiAgRGVsb3NlcjogM1xufTtcbmNvbnN0IE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcyA9IHtcbiAgQW55OiAwLFxuICBBY2Nlc3NpYmxlOiAxLFxuICBGb2N1c2FibGU6IDJcbn07XG5jb25zdCBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMgPSB7XG4gIFdhaXRpbmc6IDAsXG4gIFN1Y2NlZWRlZDogMSxcbiAgQ2FuY2VsZWQ6IDIsXG4gIFRpbWVkT3V0OiAzXG59O1xuY29uc3QgUmVzdG9yZUZvY3VzT3JkZXJzID0ge1xuICBIaXN0b3J5OiAwLFxuICBEZWxvc2VyRGVmYXVsdDogMSxcbiAgUm9vdERlZmF1bHQ6IDIsXG4gIERlbG9zZXJGaXJzdDogMyxcbiAgUm9vdEZpcnN0OiA0XG59O1xuY29uc3QgRGVsb3NlclN0cmF0ZWdpZXMgPSB7XG4gIC8qKlxuICAgKiBJZiB0aGUgZm9jdXMgaXMgbG9zdCwgdGhlIGZvY3VzIHdpbGwgYmUgcmVzdG9yZWQgYXV0b21hdGljYWxseSB1c2luZyBhbGwgYXZhaWxhYmxlIGZvY3VzIGhpc3RvcnkuXG4gICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgc3RyYXRlZ3kuXG4gICAqL1xuICBBdXRvOiAwLFxuICAvKipcbiAgICogSWYgdGhlIGZvY3VzIGlzIGxvc3QgZnJvbSB0aGlzIERlbG9zZXIgaW5zdGFuY2UsIHRoZSBmb2N1cyB3aWxsIG5vdCBiZSByZXN0b3JlZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUaGUgYXBwbGljYXRpb24gbWlnaHQgbGlzdGVuIHRvIHRoZSBldmVudCBhbmQgcmVzdG9yZSB0aGUgZm9jdXMgbWFudWFsbHkuXG4gICAqIEJ1dCBpZiBpdCBpcyBsb3N0IGZyb20gYW5vdGhlciBEZWxvc2VyIGluc3RhbmNlLCB0aGUgaGlzdG9yeSBvZiB0aGlzIERlbG9zZXIgY291bGQgYmUgdXNlZCBmaW5kaW5nXG4gICAqIHRoZSBlbGVtZW50IHRvIGZvY3VzLlxuICAgKi9cbiAgTWFudWFsOiAxXG59O1xuY29uc3QgVmlzaWJpbGl0aWVzID0ge1xuICBJbnZpc2libGU6IDAsXG4gIFBhcnRpYWxseVZpc2libGU6IDEsXG4gIFZpc2libGU6IDJcbn07XG5jb25zdCBSZXN0b3JlclR5cGVzID0ge1xuICBTb3VyY2U6IDAsXG4gIFRhcmdldDogMVxufTtcbmNvbnN0IE1vdmVyRGlyZWN0aW9ucyA9IHtcbiAgQm90aDogMCxcbiAgLy8gRGVmYXVsdCwgYm90aCBsZWZ0L3VwIGtleXMgbW92ZSB0byB0aGUgcHJldmlvdXMsIHJpZ2h0L2Rvd24gbW92ZSB0byB0aGUgbmV4dC5cbiAgVmVydGljYWw6IDEsXG4gIC8vIE9ubHkgdXAvZG93biBhcnJvd3MgbW92ZSB0byB0aGUgbmV4dC9wcmV2aW91cy5cbiAgSG9yaXpvbnRhbDogMixcbiAgLy8gT25seSBsZWZ0L3JpZ2h0IGFycm93cyBtb3ZlIHRvIHRoZSBuZXh0L3ByZXZpb3VzLlxuICBHcmlkOiAzLFxuICAvLyBUd28tZGltZW50aW9uYWwgbW92ZW1lbnQgZGVwZW5kaW5nIG9uIHRoZSB2aXN1YWwgcGxhY2VtZW50LlxuICBHcmlkTGluZWFyOiA0IC8vIFR3by1kaW1lbnRpb25hbCBtb3ZlbWVudCBkZXBlbmRpbmcgb24gdGhlIHZpc3VhbCBwbGFjZW1lbnQuIEFsbG93cyBsaW5lYXIgbW92ZW1lbnQuXG59O1xuY29uc3QgTW92ZXJLZXlzID0ge1xuICBBcnJvd1VwOiAxLFxuICBBcnJvd0Rvd246IDIsXG4gIEFycm93TGVmdDogMyxcbiAgQXJyb3dSaWdodDogNCxcbiAgUGFnZVVwOiA1LFxuICBQYWdlRG93bjogNixcbiAgSG9tZTogNyxcbiAgRW5kOiA4XG59O1xuY29uc3QgR3JvdXBwZXJUYWJiYWJpbGl0aWVzID0ge1xuICBVbmxpbWl0ZWQ6IDAsXG4gIExpbWl0ZWQ6IDEsXG4gIC8vIFRoZSB0YWJiYWJpbGl0eSBpcyBsaW1pdGVkIHRvIHRoZSBjb250YWluZXIgYW5kIGV4cGxpY2l0IEVudGVyIGlzIG5lZWRlZCB0byBnbyBpbnNpZGUuXG4gIExpbWl0ZWRUcmFwRm9jdXM6IDIgLy8gVGhlIGZvY3VzIGlzIGxpbWl0ZWQgYXMgYWJvdmUsIHBsdXMgdHJhcHBlZCB3aGVuIGluc2lkZS5cbn07XG5jb25zdCBHcm91cHBlck1vdmVGb2N1c0FjdGlvbnMgPSB7XG4gIEVudGVyOiAxLFxuICBFc2NhcGU6IDJcbn07XG5jb25zdCBTeXNEdW1teUlucHV0c1Bvc2l0aW9ucyA9IHtcbiAgQXV0bzogMCxcbiAgLy8gVGFic3RlciB3aWxsIHBsYWNlIGR1bW15IGlucHV0cyBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lciB0YWcgbmFtZSBhbmQgb24gdGhlIGRlZmF1bHQgYmVoYXZpb3VyLlxuICBJbnNpZGU6IDEsXG4gIC8vIFRhYnN0ZXIgd2lsbCBhbHdheXMgcGxhY2UgZHVtbXkgaW5wdXRzIGluc2lkZSB0aGUgY29udGFpbmVyLlxuICBPdXRzaWRlOiAyIC8vIFRhYnN0ZXIgd2lsbCBhbHdheXMgcGxhY2UgZHVtbXkgaW5wdXRzIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5lci5cbn07XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgZWxlbWVudCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB0YWJzdGVyLnN0b3JhZ2VFbnRyeShlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhYnN0ZXI7XG59XG5mdW5jdGlvbiB1cGRhdGVUYWJzdGVyQnlBdHRyaWJ1dGUodGFic3RlciwgZWxlbWVudCwgZGlzcG9zZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBuZXdBdHRyVmFsdWUgPSBkaXNwb3NlIHx8IHRhYnN0ZXIuX25vb3AgPyB1bmRlZmluZWQgOiBlbGVtZW50LmdldEF0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKTtcbiAgbGV0IGVudHJ5ID0gdGFic3Rlci5zdG9yYWdlRW50cnkoZWxlbWVudCk7XG4gIGxldCBuZXdBdHRyO1xuICBpZiAobmV3QXR0clZhbHVlKSB7XG4gICAgaWYgKG5ld0F0dHJWYWx1ZSAhPT0gKChfYSA9IGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5hdHRyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RyaW5nKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBKU09OLnBhcnNlKG5ld0F0dHJWYWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGlzIG5vdCBhIEpTT04gb2JqZWN0LCBnb3QgJyR7bmV3QXR0clZhbHVlfScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3QXR0ciA9IHtcbiAgICAgICAgICBzdHJpbmc6IG5ld0F0dHJWYWx1ZSxcbiAgICAgICAgICBvYmplY3Q6IG5ld1ZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEtdGFic3RlciBhdHRyaWJ1dGUgZXJyb3I6ICR7ZX1gLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbnRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWVudHJ5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBlbnRyeSA9IHRhYnN0ZXIuc3RvcmFnZUVudHJ5KGVsZW1lbnQsIHRydWUpO1xuICB9XG4gIGlmICghZW50cnkudGFic3Rlcikge1xuICAgIGVudHJ5LnRhYnN0ZXIgPSB7fTtcbiAgfVxuICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZW50cnkudGFic3RlciB8fCB7fTtcbiAgY29uc3Qgb2xkVGFic3RlclByb3BzID0gKChfYiA9IGVudHJ5LmF0dHIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vYmplY3QpIHx8IHt9O1xuICBjb25zdCBuZXdUYWJzdGVyUHJvcHMgPSAobmV3QXR0ciA9PT0gbnVsbCB8fCBuZXdBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdBdHRyLm9iamVjdCkgfHwge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9sZFRhYnN0ZXJQcm9wcykpIHtcbiAgICBpZiAoIW5ld1RhYnN0ZXJQcm9wc1trZXldKSB7XG4gICAgICBpZiAoa2V5ID09PSBcInJvb3RcIikge1xuICAgICAgICBjb25zdCByb290ID0gdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIHRhYnN0ZXIucm9vdC5vblJvb3Qocm9vdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJkZWxvc2VyXCI6XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIGNhc2UgXCJncm91cHBlclwiOlxuICAgICAgICBjYXNlIFwibW9kYWxpemVyXCI6XG4gICAgICAgIGNhc2UgXCJyZXN0b3JlclwiOlxuICAgICAgICBjYXNlIFwibW92ZXJcIjpcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICBwYXJ0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0YWJzdGVyT25FbGVtZW50W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JzZXJ2ZWRcIjpcbiAgICAgICAgICBkZWxldGUgdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICAgIGlmICh0YWJzdGVyLm9ic2VydmVkRWxlbWVudCkge1xuICAgICAgICAgICAgdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQub25PYnNlcnZlZEVsZW1lbnRVcGRhdGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJvdXRsaW5lXCI6XG4gICAgICAgIGNhc2UgXCJ1bmNvbnRyb2xsZWRcIjpcbiAgICAgICAgY2FzZSBcInN5c1wiOlxuICAgICAgICAgIGRlbGV0ZSB0YWJzdGVyT25FbGVtZW50W2tleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld1RhYnN0ZXJQcm9wcykpIHtcbiAgICBjb25zdCBzeXMgPSBuZXdUYWJzdGVyUHJvcHMuc3lzO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwiZGVsb3NlclwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5kZWxvc2VyKSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5kZWxvc2VyLnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5kZWxvc2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFic3Rlci5kZWxvc2VyKSB7XG4gICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50LmRlbG9zZXIgPSB0YWJzdGVyLmRlbG9zZXIuY3JlYXRlRGVsb3NlcihlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMuZGVsb3Nlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRlbG9zZXIgQVBJIHVzZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLCBwbGVhc2UgY2FsbCBgZ2V0RGVsb3NlcigpYFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5yb290KSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5yb290LnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5yb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50LnJvb3QgPSB0YWJzdGVyLnJvb3QuY3JlYXRlUm9vdChlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMucm9vdCwgc3lzKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJzdGVyLnJvb3Qub25Sb290KHRhYnN0ZXJPbkVsZW1lbnQucm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1vZGFsaXplclwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5tb2RhbGl6ZXIpIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm1vZGFsaXplci5zZXRQcm9wcyhuZXdUYWJzdGVyUHJvcHMubW9kYWxpemVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFic3Rlci5tb2RhbGl6ZXIpIHtcbiAgICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQubW9kYWxpemVyID0gdGFic3Rlci5tb2RhbGl6ZXIuY3JlYXRlTW9kYWxpemVyKGVsZW1lbnQsIG5ld1RhYnN0ZXJQcm9wcy5tb2RhbGl6ZXIsIHN5cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZGFsaXplciBBUEkgdXNlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIHBsZWFzZSBjYWxsIGBnZXRNb2RhbGl6ZXIoKWBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlc3RvcmVyXCI6XG4gICAgICAgIGlmICh0YWJzdGVyT25FbGVtZW50LnJlc3RvcmVyKSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5yZXN0b3Jlci5zZXRQcm9wcyhuZXdUYWJzdGVyUHJvcHMucmVzdG9yZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YWJzdGVyLnJlc3RvcmVyKSB7XG4gICAgICAgICAgICBpZiAobmV3VGFic3RlclByb3BzLnJlc3RvcmVyKSB7XG4gICAgICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQucmVzdG9yZXIgPSB0YWJzdGVyLnJlc3RvcmVyLmNyZWF0ZVJlc3RvcmVyKGVsZW1lbnQsIG5ld1RhYnN0ZXJQcm9wcy5yZXN0b3Jlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJlc3RvcmVyIEFQSSB1c2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgcGxlYXNlIGNhbGwgYGdldFJlc3RvcmVyKClgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgdGFic3Rlck9uRWxlbWVudC5mb2N1c2FibGUgPSBuZXdUYWJzdGVyUHJvcHMuZm9jdXNhYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJncm91cHBlclwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5ncm91cHBlcikge1xuICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQuZ3JvdXBwZXIuc2V0UHJvcHMobmV3VGFic3RlclByb3BzLmdyb3VwcGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFic3Rlci5ncm91cHBlcikge1xuICAgICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5ncm91cHBlciA9IHRhYnN0ZXIuZ3JvdXBwZXIuY3JlYXRlR3JvdXBwZXIoZWxlbWVudCwgbmV3VGFic3RlclByb3BzLmdyb3VwcGVyLCBzeXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJHcm91cHBlciBBUEkgdXNlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIHBsZWFzZSBjYWxsIGBnZXRHcm91cHBlcigpYFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW92ZXJcIjpcbiAgICAgICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQubW92ZXIpIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm1vdmVyLnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5tb3Zlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRhYnN0ZXIubW92ZXIpIHtcbiAgICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQubW92ZXIgPSB0YWJzdGVyLm1vdmVyLmNyZWF0ZU1vdmVyKGVsZW1lbnQsIG5ld1RhYnN0ZXJQcm9wcy5tb3Zlciwgc3lzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW92ZXIgQVBJIHVzZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLCBwbGVhc2UgY2FsbCBgZ2V0TW92ZXIoKWBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9ic2VydmVkXCI6XG4gICAgICAgIGlmICh0YWJzdGVyLm9ic2VydmVkRWxlbWVudCkge1xuICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQub2JzZXJ2ZWQgPSBuZXdUYWJzdGVyUHJvcHMub2JzZXJ2ZWQ7XG4gICAgICAgICAgdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQub25PYnNlcnZlZEVsZW1lbnRVcGRhdGUoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiT2JzZXJ2ZWRFbGVtZW50IEFQSSB1c2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgcGxlYXNlIGNhbGwgYGdldE9ic2VydmVkRWxlbWVudCgpYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1bmNvbnRyb2xsZWRcIjpcbiAgICAgICAgdGFic3Rlck9uRWxlbWVudC51bmNvbnRyb2xsZWQgPSBuZXdUYWJzdGVyUHJvcHMudW5jb250cm9sbGVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvdXRsaW5lXCI6XG4gICAgICAgIGlmICh0YWJzdGVyLm91dGxpbmUpIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm91dGxpbmUgPSBuZXdUYWJzdGVyUHJvcHMub3V0bGluZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJPdXRsaW5lIEFQSSB1c2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgcGxlYXNlIGNhbGwgYGdldE91dGxpbmUoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3lzXCI6XG4gICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQuc3lzID0gbmV3VGFic3RlclByb3BzLnN5cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmtub3duIGtleSAnJHtrZXl9JyBpbiBkYXRhLXRhYnN0ZXIgYXR0cmlidXRlIHZhbHVlLmApO1xuICAgIH1cbiAgfVxuICBpZiAobmV3QXR0cikge1xuICAgIGVudHJ5LmF0dHIgPSBuZXdBdHRyO1xuICB9IGVsc2Uge1xuICAgIGlmIChPYmplY3Qua2V5cyh0YWJzdGVyT25FbGVtZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBlbnRyeS50YWJzdGVyO1xuICAgICAgZGVsZXRlIGVudHJ5LmF0dHI7XG4gICAgfVxuICAgIHRhYnN0ZXIuc3RvcmFnZUVudHJ5KGVsZW1lbnQsIGZhbHNlKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2ZW50cyBzZW50IGJ5IFRhYnN0ZXIuXG4gKi9cbmNvbnN0IFRhYnN0ZXJGb2N1c0luRXZlbnROYW1lID0gXCJ0YWJzdGVyOmZvY3VzaW5cIjtcbmNvbnN0IFRhYnN0ZXJGb2N1c091dEV2ZW50TmFtZSA9IFwidGFic3Rlcjpmb2N1c291dFwiO1xuLy8gRXZlbnQgaXMgZGlzcGF0Y2hlZCB3aGVuIFRhYnN0ZXIgd2FudHMgdG8gbW92ZSBmb2N1cyBhcyB0aGUgcmVzdWx0IG9mXG4vLyBoYW5kbGluZyBrZXlib2FyZCBldmVudC4gVGhpcyBhbGxvd3MgdG8gcHJldmVudERlZmF1bHQoKSBpZiB5b3Ugd2FudCB0byBoYXZlXG4vLyBzb21lIGN1c3RvbSBsb2dpYy5cbmNvbnN0IFRhYnN0ZXJNb3ZlRm9jdXNFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW92ZWZvY3VzXCI7XG4vKipcbiAqIEV2ZW50cyBzZW50IGJ5IERlbG9zZXIuXG4gKi9cbmNvbnN0IERlbG9zZXJGb2N1c0xvc3RFdmVudE5hbWUgPSBcInRhYnN0ZXI6ZGVsb3Nlcjpmb2N1cy1sb3N0XCI7XG4vKipcbiAqIEV2ZW50cyB0byBiZSBzZW50IHRvIERlbG9zZXIgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5jb25zdCBEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOmRlbG9zZXI6cmVzdG9yZS1mb2N1c1wiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBNb2RhbGl6ZXIuXG4gKi9cbmNvbnN0IE1vZGFsaXplckFjdGl2ZUV2ZW50TmFtZSA9IFwidGFic3Rlcjptb2RhbGl6ZXI6YWN0aXZlXCI7XG5jb25zdCBNb2RhbGl6ZXJJbmFjdGl2ZUV2ZW50TmFtZSA9IFwidGFic3Rlcjptb2RhbGl6ZXI6aW5hY3RpdmVcIjtcbmNvbnN0IE1vZGFsaXplckZvY3VzSW5FdmVudE5hbWUgPSBcInRhYnN0ZXI6bW9kYWxpemVyOmZvY3VzaW5cIjtcbmNvbnN0IE1vZGFsaXplckZvY3VzT3V0RXZlbnROYW1lID0gXCJ0YWJzdGVyOm1vZGFsaXplcjpmb2N1c291dFwiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBNb3Zlci5cbiAqL1xuY29uc3QgTW92ZXJTdGF0ZUV2ZW50TmFtZSA9IFwidGFic3Rlcjptb3ZlcjpzdGF0ZVwiO1xuLyoqXG4gKiBFdmVudHMgdG8gYmUgc2VudCB0byBNb3ZlciBieSB0aGUgYXBwbGljYXRpb24uXG4gKi9cbi8vIEV2ZW50IHRoYXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIHByb2dyYW1tYXRpY2FsbHkgbW92ZVxuLy8gZm9jdXMgaW5zaWRlIE1vdmVyLlxuY29uc3QgTW92ZXJNb3ZlRm9jdXNFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW92ZXI6bW92ZWZvY3VzXCI7XG4vLyBFdmVudCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiB0byBmb3JnZXQgb3IgbW9kaWZ5XG4vLyBtZW1vcml6ZWQgZWxlbWVudCBpbiBNb3ZlciB3aXRoIG1lbW9yaXplQ3VycmVudCBwcm9wZXJ0eS5cbmNvbnN0IE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50TmFtZSA9IFwidGFic3Rlcjptb3ZlcjptZW1vcml6ZWQtZWxlbWVudFwiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBHcm91cHBlci5cbiAqL1xuLyoqXG4gKiBFdmVudHMgdG8gYmUgc2VudCB0byBHcm91cHBlciBieSB0aGUgYXBwbGljYXRpb24uXG4gKi9cbi8vIEV2ZW50IHRoYXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIHByb2dyYW1tYXRpY2FsbHkgZW50ZXJcbi8vIG9yIGVzY2FwZSBHcm91cHBlci5cbmNvbnN0IEdyb3VwcGVyTW92ZUZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOmdyb3VwcGVyOm1vdmVmb2N1c1wiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBSZXN0b3Jlci5cbiAqL1xuY29uc3QgUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUgPSBcInRhYnN0ZXI6cmVzdG9yZXI6cmVzdG9yZS1mb2N1c1wiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBSb290LlxuICovXG5jb25zdCBSb290Rm9jdXNFdmVudE5hbWUgPSBcInRhYnN0ZXI6cm9vdDpmb2N1c1wiO1xuY29uc3QgUm9vdEJsdXJFdmVudE5hbWUgPSBcInRhYnN0ZXI6cm9vdDpibHVyXCI7XG4vLyBOb2RlLmpzIGVudmlyb25tZW50cyBkbyBub3QgaGF2ZSBDdXN0b21FdmVudCBhbmQgaXQgaXMgbmVlZGVkIGZvciB0aGUgZXZlbnRzIHRvIGJlXG4vLyBldmFsdWF0ZWQuIEl0IGRvZXNuJ3QgbWF0dGVyIGlmIGl0IHdvcmtzIG9yIG5vdCBpbiBOb2RlLmpzIGVudmlyb25tZW50LlxuLy8gU28sIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBpdCBkb2Vzbid0IHRocm93IHVuZGVmaW5lZCByZWZlcmVuY2UuXG5jb25zdCBDdXN0b21FdmVudF8gPSB0eXBlb2YgQ3VzdG9tRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgPyBDdXN0b21FdmVudCA6IGZ1bmN0aW9uICgpIHtcbiAgLyogbm8tb3AgKi9cbn07XG5jbGFzcyBUYWJzdGVyQ3VzdG9tRXZlbnQgZXh0ZW5kcyBDdXN0b21FdmVudF8ge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBkZXRhaWwpIHtcbiAgICBzdXBlcih0eXBlLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgZGV0YWlsXG4gICAgfSk7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlsO1xuICB9XG59XG5jbGFzcyBUYWJzdGVyRm9jdXNJbkV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoVGFic3RlckZvY3VzSW5FdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIFRhYnN0ZXJGb2N1c091dEV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoVGFic3RlckZvY3VzT3V0RXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkZXRhaWwpIHtcbiAgICBzdXBlcihUYWJzdGVyTW92ZUZvY3VzRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBNb3ZlclN0YXRlRXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkZXRhaWwpIHtcbiAgICBzdXBlcihNb3ZlclN0YXRlRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBNb3Zlck1vdmVGb2N1c0V2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoTW92ZXJNb3ZlRm9jdXNFdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBHcm91cHBlck1vdmVGb2N1c0V2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIE1vZGFsaXplckFjdGl2ZUV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoTW9kYWxpemVyQWN0aXZlRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBNb2RhbGl6ZXJJbmFjdGl2ZUV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoTW9kYWxpemVySW5hY3RpdmVFdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIERlbG9zZXJGb2N1c0xvc3RFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKERlbG9zZXJGb2N1c0xvc3RFdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIERlbG9zZXJSZXN0b3JlRm9jdXNFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKERlbG9zZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUpO1xuICB9XG59XG5jbGFzcyBSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUpO1xuICB9XG59XG5jbGFzcyBSb290Rm9jdXNFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKFJvb3RGb2N1c0V2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgUm9vdEJsdXJFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKFJvb3RCbHVyRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IF9jcmVhdGVNdXRhdGlvbk9ic2VydmVyID0gY2FsbGJhY2sgPT4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuY29uc3QgX2NyZWF0ZVRyZWVXYWxrZXIgPSAoZG9jLCByb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpID0+IGRvYy5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcik7XG5jb25zdCBfZ2V0UGFyZW50Tm9kZSA9IG5vZGUgPT4gbm9kZSA/IG5vZGUucGFyZW50Tm9kZSA6IG51bGw7XG5jb25zdCBfZ2V0UGFyZW50RWxlbWVudCA9IGVsZW1lbnQgPT4gZWxlbWVudCA/IGVsZW1lbnQucGFyZW50RWxlbWVudCA6IG51bGw7XG5jb25zdCBfbm9kZUNvbnRhaW5zID0gKHBhcmVudCwgY2hpbGQpID0+ICEhKGNoaWxkICYmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY29udGFpbnMoY2hpbGQpKSk7XG5jb25zdCBfZ2V0QWN0aXZlRWxlbWVudCA9IGRvYyA9PiBkb2MuYWN0aXZlRWxlbWVudDtcbmNvbnN0IF9xdWVyeVNlbGVjdG9yID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuY29uc3QgX3F1ZXJ5U2VsZWN0b3JBbGwgPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIDApO1xuY29uc3QgX2dldEVsZW1lbnRCeUlkID0gKGRvYywgaWQpID0+IGRvYy5nZXRFbGVtZW50QnlJZChpZCk7XG5jb25zdCBfZ2V0Rmlyc3RDaGlsZCA9IG5vZGUgPT4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5maXJzdENoaWxkKSB8fCBudWxsO1xuY29uc3QgX2dldExhc3RDaGlsZCA9IG5vZGUgPT4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5sYXN0Q2hpbGQpIHx8IG51bGw7XG5jb25zdCBfZ2V0TmV4dFNpYmxpbmcgPSBub2RlID0+IChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubmV4dFNpYmxpbmcpIHx8IG51bGw7XG5jb25zdCBfZ2V0UHJldmlvdXNTaWJsaW5nID0gbm9kZSA9PiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnByZXZpb3VzU2libGluZykgfHwgbnVsbDtcbmNvbnN0IF9nZXRGaXJzdEVsZW1lbnRDaGlsZCA9IGVsZW1lbnQgPT4gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgfHwgbnVsbDtcbmNvbnN0IF9nZXRMYXN0RWxlbWVudENoaWxkID0gZWxlbWVudCA9PiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHx8IG51bGw7XG5jb25zdCBfZ2V0TmV4dEVsZW1lbnRTaWJsaW5nID0gZWxlbWVudCA9PiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykgfHwgbnVsbDtcbmNvbnN0IF9nZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nID0gZWxlbWVudCA9PiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IG51bGw7XG5jb25zdCBfYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbmNvbnN0IF9pbnNlcnRCZWZvcmUgPSAocGFyZW50LCBjaGlsZCwgcmVmZXJlbmNlQ2hpbGQpID0+IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZmVyZW5jZUNoaWxkKTtcbmNvbnN0IF9nZXRTZWxlY3Rpb24gPSByZWYgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gcmVmLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZWxlY3Rpb24oKSkgfHwgbnVsbDtcbn07XG5jb25zdCBfZ2V0RWxlbWVudHNCeU5hbWUgPSAocmVmZXJlbmNlRWxlbWVudCwgbmFtZSkgPT4gcmVmZXJlbmNlRWxlbWVudC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpO1xuY29uc3QgZG9tID0ge1xuICBjcmVhdGVNdXRhdGlvbk9ic2VydmVyOiBfY3JlYXRlTXV0YXRpb25PYnNlcnZlcixcbiAgY3JlYXRlVHJlZVdhbGtlcjogX2NyZWF0ZVRyZWVXYWxrZXIsXG4gIGdldFBhcmVudE5vZGU6IF9nZXRQYXJlbnROb2RlLFxuICBnZXRQYXJlbnRFbGVtZW50OiBfZ2V0UGFyZW50RWxlbWVudCxcbiAgbm9kZUNvbnRhaW5zOiBfbm9kZUNvbnRhaW5zLFxuICBnZXRBY3RpdmVFbGVtZW50OiBfZ2V0QWN0aXZlRWxlbWVudCxcbiAgcXVlcnlTZWxlY3RvcjogX3F1ZXJ5U2VsZWN0b3IsXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IF9xdWVyeVNlbGVjdG9yQWxsLFxuICBnZXRFbGVtZW50QnlJZDogX2dldEVsZW1lbnRCeUlkLFxuICBnZXRGaXJzdENoaWxkOiBfZ2V0Rmlyc3RDaGlsZCxcbiAgZ2V0TGFzdENoaWxkOiBfZ2V0TGFzdENoaWxkLFxuICBnZXROZXh0U2libGluZzogX2dldE5leHRTaWJsaW5nLFxuICBnZXRQcmV2aW91c1NpYmxpbmc6IF9nZXRQcmV2aW91c1NpYmxpbmcsXG4gIGdldEZpcnN0RWxlbWVudENoaWxkOiBfZ2V0Rmlyc3RFbGVtZW50Q2hpbGQsXG4gIGdldExhc3RFbGVtZW50Q2hpbGQ6IF9nZXRMYXN0RWxlbWVudENoaWxkLFxuICBnZXROZXh0RWxlbWVudFNpYmxpbmc6IF9nZXROZXh0RWxlbWVudFNpYmxpbmcsXG4gIGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmc6IF9nZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nLFxuICBhcHBlbmRDaGlsZDogX2FwcGVuZENoaWxkLFxuICBpbnNlcnRCZWZvcmU6IF9pbnNlcnRCZWZvcmUsXG4gIGdldFNlbGVjdGlvbjogX2dldFNlbGVjdGlvbixcbiAgZ2V0RWxlbWVudHNCeU5hbWU6IF9nZXRFbGVtZW50c0J5TmFtZVxufTtcbmZ1bmN0aW9uIHNldERPTUFQSShkb21hcGkpIHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZG9tYXBpKSkge1xuICAgIGRvbVtrZXldID0gZG9tYXBpW2tleV07XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xubGV0IF9pc0Jyb2tlbklFMTE7XG5jb25zdCBfRE9NUmVjdCA9IHR5cGVvZiBET01SZWN0ICE9PSBcInVuZGVmaW5lZFwiID8gRE9NUmVjdCA6IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMubGVmdCA9IHggfHwgMDtcbiAgICB0aGlzLnRvcCA9IHkgfHwgMDtcbiAgICB0aGlzLnJpZ2h0ID0gKHggfHwgMCkgKyAod2lkdGggfHwgMCk7XG4gICAgdGhpcy5ib3R0b20gPSAoeSB8fCAwKSArIChoZWlnaHQgfHwgMCk7XG4gIH1cbn07XG5sZXQgX3VpZENvdW50ZXIgPSAwO1xudHJ5IHtcbiAgLy8gSUUxMSBvbmx5IGFjY2VwdHMgYGZpbHRlcmAgYXJndW1lbnQgYXMgYSBmdW5jdGlvbiAobm90IG9iamVjdCB3aXRoIHRoZSBgYWNjZXB0Tm9kZWBcbiAgLy8gcHJvcGVydHkgYXMgdGhlIGRvY3MgZGVmaW5lKS4gQWxzbyBgZW50aXR5UmVmZXJlbmNlRXhwYW5zaW9uYCBhcmd1bWVudCBpcyBub3RcbiAgLy8gb3B0aW9uYWwuIEFuZCBpdCB0aHJvd3MgZXhjZXB0aW9uIHdoZW4gdGhlIGFib3ZlIGFyZ3VtZW50cyBhcmVuJ3QgdGhlcmUuXG4gIGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgX2lzQnJva2VuSUUxMSA9IGZhbHNlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG59IGNhdGNoIChlKSB7XG4gIF9pc0Jyb2tlbklFMTEgPSB0cnVlO1xufVxuY29uc3QgX3VwZGF0ZUR1bW15SW5wdXRzVGltZW91dCA9IDEwMDtcbmZ1bmN0aW9uIGdldEluc3RhbmNlQ29udGV4dChnZXRXaW5kb3cpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KCk7XG4gIGxldCBjdHggPSB3aW4uX190YWJzdGVySW5zdGFuY2VDb250ZXh0O1xuICBpZiAoIWN0eCkge1xuICAgIGN0eCA9IHtcbiAgICAgIGVsZW1lbnRCeVVJZDoge30sXG4gICAgICBiYXNpY3M6IHtcbiAgICAgICAgUHJvbWlzZTogd2luLlByb21pc2UgfHwgdW5kZWZpbmVkLFxuICAgICAgICBXZWFrUmVmOiB3aW4uV2Vha1JlZiB8fCB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBjb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZToge30sXG4gICAgICBsYXN0Q29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVJZDogMCxcbiAgICAgIGZha2VXZWFrUmVmczogW10sXG4gICAgICBmYWtlV2Vha1JlZnNTdGFydGVkOiBmYWxzZVxuICAgIH07XG4gICAgd2luLl9fdGFic3Rlckluc3RhbmNlQ29udGV4dCA9IGN0eDtcbiAgfVxuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gZGlzcG9zZUluc3RhbmNlQ29udGV4dCh3aW4pIHtcbiAgY29uc3QgY3R4ID0gd2luLl9fdGFic3Rlckluc3RhbmNlQ29udGV4dDtcbiAgaWYgKGN0eCkge1xuICAgIGN0eC5lbGVtZW50QnlVSWQgPSB7fTtcbiAgICBkZWxldGUgY3R4LldlYWtSZWY7XG4gICAgY3R4LmNvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlID0ge307XG4gICAgaWYgKGN0eC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KGN0eC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVRpbWVyKTtcbiAgICB9XG4gICAgaWYgKGN0eC5mYWtlV2Vha1JlZnNUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dChjdHguZmFrZVdlYWtSZWZzVGltZXIpO1xuICAgIH1cbiAgICBjdHguZmFrZVdlYWtSZWZzID0gW107XG4gICAgZGVsZXRlIHdpbi5fX3RhYnN0ZXJJbnN0YW5jZUNvbnRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVdlYWtNYXAod2luKSB7XG4gIGNvbnN0IGN0eCA9IHdpbi5fX3RhYnN0ZXJJbnN0YW5jZUNvbnRleHQ7XG4gIHJldHVybiBuZXcgKChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguYmFzaWNzLldlYWtNYXApIHx8IFdlYWtNYXApKCk7XG59XG5mdW5jdGlvbiBoYXNTdWJGb2N1c2FibGUoZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoRk9DVVNBQkxFX1NFTEVDVE9SKTtcbn1cbmNsYXNzIEZha2VXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIGRlcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gIH1cbiAgc3RhdGljIGNsZWFudXAoZndyLCBmb3JjZVJlbW92ZSkge1xuICAgIGlmICghZndyLl90YXJnZXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZm9yY2VSZW1vdmUgfHwgIWRvY3VtZW50Q29udGFpbnMoZndyLl90YXJnZXQub3duZXJEb2N1bWVudCwgZndyLl90YXJnZXQpKSB7XG4gICAgICBkZWxldGUgZndyLl90YXJnZXQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBXZWFrSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihnZXRXaW5kb3csIGVsZW1lbnQsIGRhdGEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gICAgbGV0IHJlZjtcbiAgICBpZiAoY29udGV4dC5XZWFrUmVmKSB7XG4gICAgICByZWYgPSBuZXcgY29udGV4dC5XZWFrUmVmKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSBuZXcgRmFrZVdlYWtSZWYoZWxlbWVudCk7XG4gICAgICBjb250ZXh0LmZha2VXZWFrUmVmcy5wdXNoKHJlZik7XG4gICAgfVxuICAgIHRoaXMuX3JlZiA9IHJlZjtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgcmVmID0gdGhpcy5fcmVmO1xuICAgIGxldCBlbGVtZW50O1xuICAgIGlmIChyZWYpIHtcbiAgICAgIGVsZW1lbnQgPSByZWYuZGVyZWYoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRmFrZVdlYWtSZWZzKGdldFdpbmRvdywgZm9yY2VSZW1vdmUpIHtcbiAgY29uc3QgY29udGV4dCA9IGdldEluc3RhbmNlQ29udGV4dChnZXRXaW5kb3cpO1xuICBjb250ZXh0LmZha2VXZWFrUmVmcyA9IGNvbnRleHQuZmFrZVdlYWtSZWZzLmZpbHRlcihlID0+ICFGYWtlV2Vha1JlZi5jbGVhbnVwKGUsIGZvcmNlUmVtb3ZlKSk7XG59XG5mdW5jdGlvbiBzdGFydEZha2VXZWFrUmVmc0NsZWFudXAoZ2V0V2luZG93KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgaWYgKCFjb250ZXh0LmZha2VXZWFrUmVmc1N0YXJ0ZWQpIHtcbiAgICBjb250ZXh0LmZha2VXZWFrUmVmc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIGNvbnRleHQuV2Vha1JlZiA9IGdldFdlYWtSZWYoY29udGV4dCk7XG4gIH1cbiAgaWYgKCFjb250ZXh0LmZha2VXZWFrUmVmc1RpbWVyKSB7XG4gICAgY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lciA9IGdldFdpbmRvdygpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFudXBGYWtlV2Vha1JlZnMoZ2V0V2luZG93KTtcbiAgICAgIHN0YXJ0RmFrZVdlYWtSZWZzQ2xlYW51cChnZXRXaW5kb3cpO1xuICAgIH0sIDIgKiA2MCAqIDEwMDApOyAvLyAyIG1pbnV0ZXMuXG4gIH1cbn1cbmZ1bmN0aW9uIHN0b3BGYWtlV2Vha1JlZnNDbGVhbnVwQW5kQ2xlYXJTdG9yYWdlKGdldFdpbmRvdykge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gIGNvbnRleHQuZmFrZVdlYWtSZWZzU3RhcnRlZCA9IGZhbHNlO1xuICBpZiAoY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lcikge1xuICAgIGdldFdpbmRvdygpLmNsZWFyVGltZW91dChjb250ZXh0LmZha2VXZWFrUmVmc1RpbWVyKTtcbiAgICBjb250ZXh0LmZha2VXZWFrUmVmc1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnRleHQuZmFrZVdlYWtSZWZzID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKGRvYywgcm9vdCwgYWNjZXB0Tm9kZSkge1xuICAvLyBJRTExIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gdGhlIFRyZWVXYWxrZXIgcm9vdCBpcyBub3QgYW4gRWxlbWVudC5cbiAgaWYgKHJvb3Qubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBUeXBlU2NyaXB0IGlzbid0IGF3YXJlIG9mIElFMTEgYmVoYXZpbmcgYmFkbHkuXG4gIGNvbnN0IGZpbHRlciA9IF9pc0Jyb2tlbklFMTEgPyBhY2NlcHROb2RlIDoge1xuICAgIGFjY2VwdE5vZGVcbiAgfTtcbiAgcmV0dXJuIGRvbS5jcmVhdGVUcmVlV2Fsa2VyKGRvYywgcm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIGZpbHRlcixcbiAgLy8gQHRzLWlnbm9yZTogV2Ugc3RpbGwgZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJyZWFrIElFMTEsIHNvLCBlbnRpdHlSZWZlcmVuY2VFeHBhbnNpb24gYXJndW1lbnQgaXMgbm90IG9wdGlvbmFsLlxuICBmYWxzZSAvKiBMYXN0IGFyZ3VtZW50IGlzIG5vdCBvcHRpb25hbCBmb3IgSUUxMSEgKi8pO1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KGdldFdpbmRvdywgZWxlbWVudCkge1xuICBsZXQgY2FjaGVJZCA9IGVsZW1lbnQuX190YWJzdGVyQ2FjaGVJZDtcbiAgY29uc3QgY29udGV4dCA9IGdldEluc3RhbmNlQ29udGV4dChnZXRXaW5kb3cpO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZUlkID8gY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVtjYWNoZUlkXSA6IHVuZGVmaW5lZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQucmVjdDtcbiAgfVxuICBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgX0RPTVJlY3QoKTtcbiAgfVxuICAvLyBBIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IGNvbnRhaW5zIHRoZSB3aG9sZSBwYWdlIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gIC8vIHNjcm9sbGJhci4gU28sIHdlIGltcHJvdmlzZSBhIGxpdHRsZSBhbmQgbGltaXRpbmcgdGhlIGZpbmFsIHJlc3VsdC4uLlxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCB0b3AgPSAwO1xuICBsZXQgcmlnaHQgPSBzY3JvbGxpbmdFbGVtZW50LmNsaWVudFdpZHRoO1xuICBsZXQgYm90dG9tID0gc2Nyb2xsaW5nRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIGlmIChlbGVtZW50ICE9PSBzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgciA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHIubGVmdCk7XG4gICAgdG9wID0gTWF0aC5tYXgodG9wLCByLnRvcCk7XG4gICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgci5yaWdodCk7XG4gICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCByLmJvdHRvbSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IG5ldyBfRE9NUmVjdChsZWZ0IDwgcmlnaHQgPyBsZWZ0IDogLTEsIHRvcCA8IGJvdHRvbSA/IHRvcCA6IC0xLCBsZWZ0IDwgcmlnaHQgPyByaWdodCAtIGxlZnQgOiAwLCB0b3AgPCBib3R0b20gPyBib3R0b20gLSB0b3AgOiAwKTtcbiAgaWYgKCFjYWNoZUlkKSB7XG4gICAgY2FjaGVJZCA9IFwici1cIiArICsrY29udGV4dC5sYXN0Q29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVJZDtcbiAgICBlbGVtZW50Ll9fdGFic3RlckNhY2hlSWQgPSBjYWNoZUlkO1xuICB9XG4gIGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVbY2FjaGVJZF0gPSB7XG4gICAgcmVjdCxcbiAgICBlbGVtZW50XG4gIH07XG4gIGlmICghY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVRpbWVyKSB7XG4gICAgY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgZm9yIChjb25zdCBjSWQgb2YgT2JqZWN0LmtleXMoY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZSkpIHtcbiAgICAgICAgZGVsZXRlIGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVbY0lkXS5lbGVtZW50Ll9fdGFic3RlckNhY2hlSWQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlID0ge307XG4gICAgfSwgNTApO1xuICB9XG4gIHJldHVybiByZWN0O1xufVxuZnVuY3Rpb24gaXNFbGVtZW50VmVydGljYWxseVZpc2libGVJbkNvbnRhaW5lcihnZXRXaW5kb3csIGVsZW1lbnQsIHRvbGVyYW5jZSkge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb250YWluZXJSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KGdldFdpbmRvdywgY29udGFpbmVyKTtcbiAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBpbnRlcnNlY3Rpb25Ub2xlcmFuY2UgPSBlbGVtZW50UmVjdC5oZWlnaHQgKiAoMSAtIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHRvcEludGVyc2VjdGlvbiA9IE1hdGgubWF4KDAsIGNvbnRhaW5lclJlY3QudG9wIC0gZWxlbWVudFJlY3QudG9wKTtcbiAgY29uc3QgYm90dG9tSW50ZXJzZWN0aW9uID0gTWF0aC5tYXgoMCwgZWxlbWVudFJlY3QuYm90dG9tIC0gY29udGFpbmVyUmVjdC5ib3R0b20pO1xuICBjb25zdCB0b3RhbEludGVyc2VjdGlvbiA9IHRvcEludGVyc2VjdGlvbiArIGJvdHRvbUludGVyc2VjdGlvbjtcbiAgcmV0dXJuIHRvdGFsSW50ZXJzZWN0aW9uID09PSAwIHx8IHRvdGFsSW50ZXJzZWN0aW9uIDw9IGludGVyc2VjdGlvblRvbGVyYW5jZTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGdldFdpbmRvdywgZWxlbWVudCwgYWxpZ25Ub1RvcCkge1xuICAvLyBCdWlsdC1pbiBET00ncyBzY3JvbGxJbnRvVmlldygpIGlzIGNvb2wsIGJ1dCB3aGVuIHdlIGhhdmUgbmVzdGVkIGNvbnRhaW5lcnMsXG4gIC8vIGl0IHNjcm9sbHMgYWxsIG9mIHRoZW0sIG5vdCBqdXN0IHRoZSBkZWVwZXN0IG9uZS4gU28sIHRyeWluZyB0byB3b3JrIGl0IGFyb3VuZC5cbiAgY29uc3QgY29udGFpbmVyID0gZ2V0U2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50KTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBnZXRCb3VuZGluZ1JlY3QoZ2V0V2luZG93LCBjb250YWluZXIpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYWxpZ25Ub1RvcCkge1xuICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBlbGVtZW50UmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBlbGVtZW50UmVjdC5ib3R0b20gLSBjb250YWluZXJSZWN0LmJvdHRvbTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNjcm9sbGFibGVDb250YWluZXIoZWxlbWVudCkge1xuICBjb25zdCBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGlmIChkb2MpIHtcbiAgICBmb3IgKGxldCBlbCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpOyBlbDsgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbCkpIHtcbiAgICAgIGlmIChlbC5zY3JvbGxXaWR0aCA+IGVsLmNsaWVudFdpZHRoIHx8IGVsLnNjcm9sbEhlaWdodCA+IGVsLmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZUZvY3VzSWdub3JlZChlbGVtZW50KSB7XG4gIGVsZW1lbnQuX19zaG91bGRJZ25vcmVGb2N1cyA9IHRydWU7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVGb2N1cyhlbGVtZW50KSB7XG4gIHJldHVybiAhIWVsZW1lbnQuX19zaG91bGRJZ25vcmVGb2N1cztcbn1cbmZ1bmN0aW9uIGdldFVJZCh3bmQpIHtcbiAgY29uc3Qgcm5kID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICBpZiAod25kLmNyeXB0byAmJiB3bmQuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHduZC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJuZCk7XG4gIH0gZWxzZSBpZiAod25kLm1zQ3J5cHRvICYmIHduZC5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB3bmQubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJuZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBybmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJuZFtpXSA9IDB4ZmZmZmZmZmYgKiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzcm5kID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm5kLmxlbmd0aDsgaSsrKSB7XG4gICAgc3JuZC5wdXNoKHJuZFtpXS50b1N0cmluZygzNikpO1xuICB9XG4gIHNybmQucHVzaChcInxcIik7XG4gIHNybmQucHVzaCgoKytfdWlkQ291bnRlcikudG9TdHJpbmcoMzYpKTtcbiAgc3JuZC5wdXNoKFwifFwiKTtcbiAgc3JuZC5wdXNoKERhdGUubm93KCkudG9TdHJpbmcoMzYpKTtcbiAgcmV0dXJuIHNybmQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRVSWQoZ2V0V2luZG93LCBlbGVtZW50KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgbGV0IHVpZCA9IGVsZW1lbnQuX190YWJzdGVyRWxlbWVudFVJRDtcbiAgaWYgKCF1aWQpIHtcbiAgICB1aWQgPSBlbGVtZW50Ll9fdGFic3RlckVsZW1lbnRVSUQgPSBnZXRVSWQoZ2V0V2luZG93KCkpO1xuICB9XG4gIGlmICghY29udGV4dC5lbGVtZW50QnlVSWRbdWlkXSAmJiBkb2N1bWVudENvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudCwgZWxlbWVudCkpIHtcbiAgICBjb250ZXh0LmVsZW1lbnRCeVVJZFt1aWRdID0gbmV3IFdlYWtIVE1MRWxlbWVudChnZXRXaW5kb3csIGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiB1aWQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dVSWQod2luKSB7XG4gIGxldCB1aWQgPSB3aW4uX190YWJzdGVyQ3Jvc3NPcmlnaW5XaW5kb3dVSUQ7XG4gIGlmICghdWlkKSB7XG4gICAgdWlkID0gd2luLl9fdGFic3RlckNyb3NzT3JpZ2luV2luZG93VUlEID0gZ2V0VUlkKHdpbik7XG4gIH1cbiAgcmV0dXJuIHVpZDtcbn1cbmZ1bmN0aW9uIGNsZWFyRWxlbWVudENhY2hlKGdldFdpbmRvdywgcGFyZW50KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29udGV4dC5lbGVtZW50QnlVSWQpKSB7XG4gICAgY29uc3Qgd2VsID0gY29udGV4dC5lbGVtZW50QnlVSWRba2V5XTtcbiAgICBjb25zdCBlbCA9IHdlbCAmJiB3ZWwuZ2V0KCk7XG4gICAgaWYgKGVsICYmIHBhcmVudCkge1xuICAgICAgaWYgKCFkb20ubm9kZUNvbnRhaW5zKHBhcmVudCwgZWwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgY29udGV4dC5lbGVtZW50QnlVSWRba2V5XTtcbiAgfVxufVxuLy8gSUUxMSBkb2Vzbid0IGhhdmUgZG9jdW1lbnQuY29udGFpbnMoKS4uLlxuZnVuY3Rpb24gZG9jdW1lbnRDb250YWlucyhkb2MsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGRvbS5ub2RlQ29udGFpbnMoZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHksIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoZXMgfHwgZWxlbWVudC5tYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgcmV0dXJuIG1hdGNoZXMgJiYgbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGdldFByb21pc2UoZ2V0V2luZG93KSB7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgaWYgKGNvbnRleHQuYmFzaWNzLlByb21pc2UpIHtcbiAgICByZXR1cm4gY29udGV4dC5iYXNpY3MuUHJvbWlzZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQcm9taXNlIGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gZ2V0V2Vha1JlZihjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0LmJhc2ljcy5XZWFrUmVmO1xufVxubGV0IF9sYXN0VGFic3RlclBhcnRJZCA9IDA7XG5jbGFzcyBUYWJzdGVyUGFydCB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKSB7XG4gICAgY29uc3QgZ2V0V2luZG93ID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fZWxlbWVudCA9IG5ldyBXZWFrSFRNTEVsZW1lbnQoZ2V0V2luZG93LCBlbGVtZW50KTtcbiAgICB0aGlzLl9wcm9wcyA9IHtcbiAgICAgIC4uLnByb3BzXG4gICAgfTtcbiAgICB0aGlzLmlkID0gXCJpXCIgKyArK19sYXN0VGFic3RlclBhcnRJZDtcbiAgfVxuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldCgpO1xuICB9XG4gIGdldFByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgfVxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuX3Byb3BzID0ge1xuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIER1bW15IEhUTUwgZWxlbWVudHMgdGhhdCBhcmUgdXNlZCBhcyBmb2N1cyBzZW50aW5lbHMgZm9yIHRoZSBET00gZW5jbG9zZWQgd2l0aGluIHRoZW1cbiAqL1xuY2xhc3MgRHVtbXlJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGdldFdpbmRvdywgaXNPdXRzaWRlLCBwcm9wcywgZWxlbWVudCwgZml4ZWRUYXJnZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5fZm9jdXNJbiA9IGUgPT4ge1xuICAgICAgaWYgKHRoaXMuX2ZpeGVkVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2ZpeGVkVGFyZ2V0LmdldCgpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgbmF0aXZlRm9jdXModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICBpZiAodGhpcy5vbkZvY3VzSW4gJiYgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdGhpcy5vbkZvY3VzSW4odGhpcywgdGhpcy5faXNCYWNrd2FyZCh0cnVlLCBpbnB1dCwgcmVsYXRlZFRhcmdldCksIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZm9jdXNPdXQgPSBlID0+IHtcbiAgICAgIGlmICh0aGlzLl9maXhlZFRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVzZURlZmF1bHRBY3Rpb24gPSBmYWxzZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgIGlmICh0aGlzLm9uRm9jdXNPdXQgJiYgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdGhpcy5vbkZvY3VzT3V0KHRoaXMsIHRoaXMuX2lzQmFja3dhcmQoZmFsc2UsIGlucHV0LCByZWxhdGVkVGFyZ2V0KSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coKTtcbiAgICBjb25zdCBpbnB1dCA9IHdpbi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICBpbnB1dC50YWJJbmRleCA9IDA7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm5vbmVcIik7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFRBQlNURVJfRFVNTVlfSU5QVVRfQVRUUklCVVRFX05BTUUsIFwiXCIpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBjb25zdCBzdHlsZSA9IGlucHV0LnN0eWxlO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcbiAgICBzdHlsZS5vcGFjaXR5ID0gXCIwLjAwMVwiO1xuICAgIHN0eWxlLnpJbmRleCA9IFwiLTFcIjtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShcImNvbnRlbnQtdmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICBtYWtlRm9jdXNJZ25vcmVkKGlucHV0KTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5pc0ZpcnN0ID0gcHJvcHMuaXNGaXJzdDtcbiAgICB0aGlzLmlzT3V0c2lkZSA9IGlzT3V0c2lkZTtcbiAgICB0aGlzLl9pc1BoYW50b20gPSAoX2EgPSBwcm9wcy5pc1BoYW50b20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIHRoaXMuX2ZpeGVkVGFyZ2V0ID0gZml4ZWRUYXJnZXQ7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy5fZm9jdXNJbik7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX2ZvY3VzT3V0KTtcbiAgICBpbnB1dC5fX3RhYnN0ZXJEdW1teUNvbnRhaW5lciA9IGVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuX2lzUGhhbnRvbSkge1xuICAgICAgdGhpcy5fZGlzcG9zZVRpbWVyID0gd2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fZGlzcG9zZVRpbWVyO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5fY2xlYXJEaXNwb3NlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VUaW1lcikge1xuICAgICAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5fZGlzcG9zZVRpbWVyKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZGlzcG9zZVRpbWVyO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jbGVhckRpc3Bvc2VUaW1lb3V0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX2NsZWFyRGlzcG9zZVRpbWVvdXQpIHtcbiAgICAgIHRoaXMuX2NsZWFyRGlzcG9zZVRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX2ZpeGVkVGFyZ2V0O1xuICAgIGRlbGV0ZSB0aGlzLm9uRm9jdXNJbjtcbiAgICBkZWxldGUgdGhpcy5vbkZvY3VzT3V0O1xuICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX2ZvY3VzSW4pO1xuICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLl9mb2N1c091dCk7XG4gICAgZGVsZXRlIGlucHV0Ll9fdGFic3RlckR1bW15Q29udGFpbmVyO1xuICAgIChfYSA9IGRvbS5nZXRQYXJlbnROb2RlKGlucHV0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGlucHV0KTtcbiAgfVxuICBzZXRUb3BMZWZ0KHRvcCwgbGVmdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzdHlsZSA9IChfYSA9IHRoaXMuaW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHlsZTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG4gICAgICBzdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG4gICAgfVxuICB9XG4gIF9pc0JhY2t3YXJkKGlzSW4sIGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGlzSW4gJiYgIXByZXZpb3VzID8gIXRoaXMuaXNGaXJzdCA6ICEhKHByZXZpb3VzICYmIGN1cnJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocHJldmlvdXMpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpO1xuICB9XG59XG5jb25zdCBEdW1teUlucHV0TWFuYWdlclByaW9yaXRpZXMgPSB7XG4gIFJvb3Q6IDEsXG4gIE1vZGFsaXplcjogMixcbiAgTW92ZXI6IDMsXG4gIEdyb3VwcGVyOiA0XG59O1xuY2xhc3MgRHVtbXlJbnB1dE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBwcmlvcml0eSwgc3lzLCBvdXRzaWRlQnlEZWZhdWx0LCBjYWxsRm9yRGVmYXVsdEFjdGlvbikge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IER1bW15SW5wdXRNYW5hZ2VyQ29yZSh0YWJzdGVyLCBlbGVtZW50LCB0aGlzLCBwcmlvcml0eSwgc3lzLCBvdXRzaWRlQnlEZWZhdWx0LCBjYWxsRm9yRGVmYXVsdEFjdGlvbik7XG4gIH1cbiAgX3NldEhhbmRsZXJzKG9uRm9jdXNJbiwgb25Gb2N1c091dCkge1xuICAgIHRoaXMuX29uRm9jdXNJbiA9IG9uRm9jdXNJbjtcbiAgICB0aGlzLl9vbkZvY3VzT3V0ID0gb25Gb2N1c091dDtcbiAgfVxuICBtb3ZlT3V0KGJhY2t3YXJkcykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9pbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVPdXQoYmFja3dhcmRzKTtcbiAgfVxuICBtb3ZlT3V0V2l0aERlZmF1bHRBY3Rpb24oYmFja3dhcmRzLCByZWxhdGVkRXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5faW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlT3V0V2l0aERlZmF1bHRBY3Rpb24oYmFja3dhcmRzLCByZWxhdGVkRXZlbnQpO1xuICB9XG4gIGdldEhhbmRsZXIoaXNJbikge1xuICAgIHJldHVybiBpc0luID8gdGhpcy5fb25Gb2N1c0luIDogdGhpcy5fb25Gb2N1c091dDtcbiAgfVxuICBzZXRUYWJiYWJsZSh0YWJiYWJsZSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9pbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFRhYmJhYmxlKHRoaXMsIHRhYmJhYmxlKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UuZGlzcG9zZSh0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pbnN0YW5jZTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX29uRm9jdXNJbjtcbiAgICBkZWxldGUgdGhpcy5fb25Gb2N1c091dDtcbiAgfVxuICBzdGF0aWMgbW92ZVdpdGhQaGFudG9tRHVtbXkodGFic3RlciwgZWxlbWVudCxcbiAgLy8gVGhlIHRhcmdldCBlbGVtZW50IHRvIG1vdmUgdG8gb3Igb3V0IG9mLlxuICBtb3ZlT3V0T2ZFbGVtZW50LFxuICAvLyBXaGV0aGVyIHRvIG1vdmUgb3V0IG9mIHRoZSBlbGVtZW50IG9yIGludG8gaXQuXG4gIGlzQmFja3dhcmQsXG4gIC8vIEFyZSB3ZSB0YWJiaW5nIG9mIHNoaWZ0LXRhYmJpbmc/XG4gIHJlbGF0ZWRFdmVudCAvLyBUaGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG1vdmUuXG4gICkge1xuICAgIC8vIFBoYW50b20gZHVtbXkgaXMgYSBoYWNrIHRvIHVzZSBicm93c2VyJ3MgZGVmYXVsdCBhY3Rpb24gdG8gbW92ZVxuICAgIC8vIGZvY3VzIGZyb20gYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgYXBwbGljYXRpb24gdG8gdGhlIG5leHQvcHJldmlvdXNcbiAgICAvLyBlbGVtZW50LiBEZWZhdWx0IGFjdGlvbiBpcyBuZWVkZWQgYmVjYXVzZSBuZXh0IGZvY3VzYWJsZSBlbGVtZW50XG4gICAgLy8gaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgdG8gZm9jdXMgZGlyZWN0bHkgKGZvciBleGFtcGxlLCBuZXh0IGZvY3VzYWJsZVxuICAgIC8vIGlzIGluc2lkZSBpc29sYXRlZCBpZnJhbWUpIG9yIGZvciB1bmNvbnRyb2xsZWQgYXJlYXMgd2Ugd2FudCB0byBtYWtlXG4gICAgLy8gc3VyZSB0aGF0IHNvbWV0aGluZyB0aGF0IGNvbnRyb2xzIGl0IHRha2VzIGNhcmUgb2YgdGhlIGZvY3VzaW5nLlxuICAgIC8vIEl0IHdvcmtzIGluIGEgd2F5IHRoYXQgZHVyaW5nIHRoZSBUYWIga2V5IGhhbmRsaW5nLCB3ZSBjcmVhdGUgYSBkdW1teVxuICAgIC8vIGlucHV0IGVsZW1lbnQsIHBsYWNlIGl0IHRvIHRoZSBzcGVjaWZpYyBwbGFjZSBpbiB0aGUgRE9NIGFuZCBmb2N1cyBpdCxcbiAgICAvLyB0aGVuIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgVGFiIHByZXNzIHdpbGwgbW92ZSBmb2N1cyBmcm9tIG91ciBkdW1teVxuICAgIC8vIGlucHV0LiBBbmQgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSByaWdodCBhZnRlciB0aGF0LlxuICAgIGNvbnN0IGR1bW15ID0gbmV3IER1bW15SW5wdXQodGFic3Rlci5nZXRXaW5kb3csIHRydWUsIHtcbiAgICAgIGlzUGhhbnRvbTogdHJ1ZSxcbiAgICAgIGlzRmlyc3Q6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbnB1dCA9IGR1bW15LmlucHV0O1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgbGV0IHBhcmVudDtcbiAgICAgIGxldCBpbnNlcnRCZWZvcmU7XG4gICAgICAvLyBMZXQncyBzYXkgd2UgaGF2ZSBhIGZvbGxvd2luZyBET00gc3RydWN0dXJlOlxuICAgICAgLy8gPGRpdj5cbiAgICAgIC8vICAgPGJ1dHRvbj5CdXR0b24xPC9idXR0b24+XG4gICAgICAvLyAgIDxkaXYgaWQ9XCJ1bmNvbnRyb2xsZWRcIiBkYXRhLXRhYnN0ZXI9e3VuY29udHJvbGxlZDoge319PlxuICAgICAgLy8gICAgIDxidXR0b24+QnV0dG9uMjwvYnV0dG9uPlxuICAgICAgLy8gICAgIDxidXR0b24+QnV0dG9uMzwvYnV0dG9uPlxuICAgICAgLy8gICA8L2Rpdj5cbiAgICAgIC8vICAgPGJ1dHRvbj5CdXR0b240PC9idXR0b24+XG4gICAgICAvLyA8L2Rpdj5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBwYXNzIHRoZSBcInVuY29udHJvbGxlZFwiIGRpdiBhcyB0aGUgZWxlbWVudCB0byBtb3ZlIHRvIG9yIG91dCBvZi5cbiAgICAgIC8vXG4gICAgICAvLyBXaGVuIHdlIHBhc3MgbW92ZU91dE9mRWxlbWVudD10cnVlIGFuZCBpc0JhY2t3YXJkPWZhbHNlLFxuICAgICAgLy8gdGhlIHBoYW50b20gZHVtbXkgaW5wdXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgQnV0dG9uNC5cbiAgICAgIC8vXG4gICAgICAvLyBXaGVuIHdlIHBhc3MgbW92ZU91dE9mRWxlbWVudD10cnVlIGFuZCBpc0JhY2t3YXJkPXRydWUsIHRoZXJlIGFyZVxuICAgICAgLy8gdHdvIGNhc2VzLiBJZiB0aGUgdW5jb250cm9sbGVkIGVsZW1lbnQgaXMgZm9jdXNhYmxlIChoYXMgdGFiaW5kZXg9MCksXG4gICAgICAvLyB0aGUgcGhhbnRvbSBkdW1teSBpbnB1dCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIEJ1dHRvbjEuIElmIHRoZVxuICAgICAgLy8gdW5jb250cm9sbGVkIGVsZW1lbnQgaXMgbm90IGZvY3VzYWJsZSwgdGhlIHBoYW50b20gZHVtbXkgaW5wdXQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgYmVmb3JlIEJ1dHRvbjIuXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB3ZSBwYXNzIG1vdmVPdXRPZkVsZW1lbnQ9ZmFsc2UgYW5kIGlzQmFja3dhcmQ9ZmFsc2UsIHRoZVxuICAgICAgLy8gcGhhbnRvbSBkdW1teSBpbnB1dCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIEJ1dHRvbjEuXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB3ZSBwYXNzIG1vdmVPdXRPZkVsZW1lbnQ9ZmFsc2UgYW5kIGlzQmFja3dhcmQ9dHJ1ZSwgdGhlIHBoYW50b21cbiAgICAgIC8vIGR1bW15IGlucHV0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIEJ1dHRvbjQuXG4gICAgICAvL1xuICAgICAgLy8gQW5kIHdlIGhhdmUgYSBjb3JuZXIgY2FzZSBmb3IgPGJvZHk+IGFuZCB3ZSBtYWtlIHN1cmUgdGhhdCB0aGUgaW5zZXJ0ZWRcbiAgICAgIC8vIGR1bW15IGlzIGluc2VydGVkIHByb3Blcmx5IHdoZW4gdGhlcmUgYXJlIGV4aXN0aW5nIHBlcm1hbmVudCBkdW1taWVzLlxuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IGluc2VydCBlbGVtZW50cyBvdXRzaWRlIG9mIEJPRFkuXG4gICAgICAgIHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGluc2VydEJlZm9yZSA9IG1vdmVPdXRPZkVsZW1lbnQgJiYgaXNCYWNrd2FyZCB8fCAhbW92ZU91dE9mRWxlbWVudCAmJiAhaXNCYWNrd2FyZCA/IGRvbS5nZXRGaXJzdEVsZW1lbnRDaGlsZChlbGVtZW50KSA6IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobW92ZU91dE9mRWxlbWVudCAmJiAoIWlzQmFja3dhcmQgfHwgaXNCYWNrd2FyZCAmJiAhdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCwgZmFsc2UsIHRydWUsIHRydWUpKSkge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlID0gaXNCYWNrd2FyZCA/IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIGluc2VydEJlZm9yZSA9IG1vdmVPdXRPZkVsZW1lbnQgJiYgaXNCYWNrd2FyZCB8fCAhbW92ZU91dE9mRWxlbWVudCAmJiAhaXNCYWNrd2FyZCA/IGVsZW1lbnQgOiBkb20uZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3RlbnRpYWxEdW1teTtcbiAgICAgICAgbGV0IGR1bW15Rm9yO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHNhZmV0eSBwaWxsb3cgZm9yIHRoZSBjYXNlcyB3aGVuIHNvbWVvbmUsIGNvbWJpbmVzXG4gICAgICAgICAgLy8gZ3JvdXBwZXIgd2l0aCB1bmNvbnRyb2xsZWQgb24gdGhlIHNhbWUgbm9kZS4gV2hpY2ggaXMgdGVjaG5pY2FsbHlcbiAgICAgICAgICAvLyBub3QgY29ycmVjdCwgYnV0IG1vdmluZyBpbnRvIHRoZSBjb250YWluZXIgZWxlbWVudCB2aWEgaXRzIGR1bW15XG4gICAgICAgICAgLy8gaW5wdXQgd291bGQgcHJvZHVjZSBhIGNvcnJlY3QgYmVoYXZpb3VyIGluIHVuY29udHJvbGxlZCBtb2RlLlxuICAgICAgICAgIHBvdGVudGlhbER1bW15ID0gbW92ZU91dE9mRWxlbWVudCAmJiBpc0JhY2t3YXJkIHx8ICFtb3ZlT3V0T2ZFbGVtZW50ICYmICFpc0JhY2t3YXJkID8gZG9tLmdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoaW5zZXJ0QmVmb3JlKSA6IGluc2VydEJlZm9yZTtcbiAgICAgICAgICBkdW1teUZvciA9IGdldER1bW15SW5wdXRDb250YWluZXIocG90ZW50aWFsRHVtbXkpO1xuICAgICAgICAgIGlmIChkdW1teUZvciA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlID0gbW92ZU91dE9mRWxlbWVudCAmJiBpc0JhY2t3YXJkIHx8ICFtb3ZlT3V0T2ZFbGVtZW50ICYmICFpc0JhY2t3YXJkID8gcG90ZW50aWFsRHVtbXkgOiBkb20uZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKHBvdGVudGlhbER1bW15KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVtbXlGb3IgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZHVtbXlGb3IpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICBieTogXCJyb290XCIsXG4gICAgICAgIG93bmVyOiBwYXJlbnQsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHJlbGF0ZWRFdmVudFxuICAgICAgfSkpKSB7XG4gICAgICAgIGRvbS5pbnNlcnRCZWZvcmUocGFyZW50LCBpbnB1dCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgbmF0aXZlRm9jdXMoaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgYWRkUGhhbnRvbUR1bW15V2l0aFRhcmdldCh0YWJzdGVyLCBzb3VyY2VFbGVtZW50LCBpc0JhY2t3YXJkLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgY29uc3QgZHVtbXkgPSBuZXcgRHVtbXlJbnB1dCh0YWJzdGVyLmdldFdpbmRvdywgdHJ1ZSwge1xuICAgICAgaXNQaGFudG9tOiB0cnVlLFxuICAgICAgaXNGaXJzdDogdHJ1ZVxuICAgIH0sIHVuZGVmaW5lZCwgbmV3IFdlYWtIVE1MRWxlbWVudCh0YWJzdGVyLmdldFdpbmRvdywgdGFyZ2V0RWxlbWVudCkpO1xuICAgIGNvbnN0IGlucHV0ID0gZHVtbXkuaW5wdXQ7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBsZXQgZHVtbXlQYXJlbnQ7XG4gICAgICBsZXQgaW5zZXJ0QmVmb3JlO1xuICAgICAgaWYgKGhhc1N1YkZvY3VzYWJsZShzb3VyY2VFbGVtZW50KSAmJiAhaXNCYWNrd2FyZCkge1xuICAgICAgICBkdW1teVBhcmVudCA9IHNvdXJjZUVsZW1lbnQ7XG4gICAgICAgIGluc2VydEJlZm9yZSA9IGRvbS5nZXRGaXJzdEVsZW1lbnRDaGlsZChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR1bW15UGFyZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc291cmNlRWxlbWVudCk7XG4gICAgICAgIGluc2VydEJlZm9yZSA9IGlzQmFja3dhcmQgPyBzb3VyY2VFbGVtZW50IDogZG9tLmdldE5leHRFbGVtZW50U2libGluZyhzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChkdW1teVBhcmVudCkge1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKGR1bW15UGFyZW50LCBpbnB1dCwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKGR1bW15LCB3cmFwcGVycykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHdoYXQgPSB7XG4gICAgMTogXCJSb290XCIsXG4gICAgMjogXCJNb2RhbGl6ZXJcIixcbiAgICAzOiBcIk1vdmVyXCIsXG4gICAgNDogXCJHcm91cHBlclwiXG4gIH07XG4gIChfYSA9IGR1bW15LmlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKFRBQlNURVJfRFVNTVlfSU5QVVRfQVRUUklCVVRFX05BTUUsIFtgaXNGaXJzdD0ke2R1bW15LmlzRmlyc3R9YCwgYGlzT3V0c2lkZT0ke2R1bW15LmlzT3V0c2lkZX1gLCAuLi53cmFwcGVycy5tYXAodyA9PiBgKCR7d2hhdFt3LnByaW9yaXR5XX0sIHRhYmJhYmxlPSR7dy50YWJiYWJsZX0pYCldLmpvaW4oXCIsIFwiKSk7XG59XG5jbGFzcyBEdW1teUlucHV0T2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3Rvcih3aW4pIHtcbiAgICB0aGlzLl91cGRhdGVRdWV1ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9sYXN0VXBkYXRlUXVldWVUaW1lID0gMDtcbiAgICB0aGlzLl9jaGFuZ2VkUGFyZW50cyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fZHVtbXlFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2R1bW15Q2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9kb21DaGFuZ2VkID0gcGFyZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VkUGFyZW50cy5oYXMocGFyZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkUGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVEdW1teUlucHV0c1RpbWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZUR1bW15SW5wdXRzVGltZXIgPSAoX2EgPSB0aGlzLl93aW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fdXBkYXRlRHVtbXlJbnB1dHNUaW1lcjtcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpcy5fZHVtbXlFbGVtZW50cykge1xuICAgICAgICAgIGNvbnN0IGR1bW15RWxlbWVudCA9IHJlZi5nZXQoKTtcbiAgICAgICAgICBpZiAoZHVtbXlFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2R1bW15Q2FsbGJhY2tzLmdldChkdW1teUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGR1bW15UGFyZW50ID0gZG9tLmdldFBhcmVudE5vZGUoZHVtbXlFbGVtZW50KTtcbiAgICAgICAgICAgICAgaWYgKCFkdW1teVBhcmVudCB8fCB0aGlzLl9jaGFuZ2VkUGFyZW50cy5oYXMoZHVtbXlQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VkUGFyZW50cyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICB9LCBfdXBkYXRlRHVtbXlJbnB1dHNUaW1lb3V0KTtcbiAgICB9O1xuICAgIHRoaXMuX3dpbiA9IHdpbjtcbiAgfVxuICBhZGQoZHVtbXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9kdW1teUNhbGxiYWNrcy5oYXMoZHVtbXkpICYmIHRoaXMuX3dpbikge1xuICAgICAgdGhpcy5fZHVtbXlFbGVtZW50cy5wdXNoKG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fd2luLCBkdW1teSkpO1xuICAgICAgdGhpcy5fZHVtbXlDYWxsYmFja3Muc2V0KGR1bW15LCBjYWxsYmFjayk7XG4gICAgICB0aGlzLmRvbUNoYW5nZWQgPSB0aGlzLl9kb21DaGFuZ2VkO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZHVtbXkpIHtcbiAgICB0aGlzLl9kdW1teUVsZW1lbnRzID0gdGhpcy5fZHVtbXlFbGVtZW50cy5maWx0ZXIocmVmID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuZ2V0KCk7XG4gICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50ICE9PSBkdW1teTtcbiAgICB9KTtcbiAgICB0aGlzLl9kdW1teUNhbGxiYWNrcy5kZWxldGUoZHVtbXkpO1xuICAgIGlmICh0aGlzLl9kdW1teUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuZG9tQ2hhbmdlZDtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgd2luID0gKF9hID0gdGhpcy5fd2luKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fdXBkYXRlVGltZXIpIHtcbiAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5jbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlVGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZVRpbWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdXBkYXRlRHVtbXlJbnB1dHNUaW1lcikge1xuICAgICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVEdW1teUlucHV0c1RpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVEdW1teUlucHV0c1RpbWVyO1xuICAgIH1cbiAgICB0aGlzLl9jaGFuZ2VkUGFyZW50cyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fZHVtbXlDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX2R1bW15RWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl91cGRhdGVRdWV1ZS5jbGVhcigpO1xuICAgIGRlbGV0ZSB0aGlzLmRvbUNoYW5nZWQ7XG4gICAgZGVsZXRlIHRoaXMuX3dpbjtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbnMoY29tcHV0ZSkge1xuICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICAvLyBBcyB0aGlzIGlzIGEgcHVibGljIG1ldGhvZCwgd2UgbWFrZSBzdXJlIHRoYXQgaXQgaGFzIG5vIGVmZmVjdCB3aGVuXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgZGlzcG9zZSgpLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVRdWV1ZS5hZGQoY29tcHV0ZSk7XG4gICAgdGhpcy5fbGFzdFVwZGF0ZVF1ZXVlVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fc2NoZWR1bGVkVXBkYXRlUG9zaXRpb25zKCk7XG4gIH1cbiAgX3NjaGVkdWxlZFVwZGF0ZVBvc2l0aW9ucygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gKF9hID0gdGhpcy5fd2luKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICAgIC8vIHVwZGF0ZVBvc2l0aW9ucygpIG1pZ2h0IGJlIGNhbGxlZCBxdWl0ZSBhIGxvdCBkdXJpbmcgdGhlIHNjcm9sbGluZy5cbiAgICAgIC8vIFNvLCBpbnN0ZWFkIG9mIGNsZWFyaW5nIHRoZSB0aW1lb3V0IGFuZCBzY2hlZHVsaW5nIGEgbmV3IG9uZSwgd2VcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlUG9zaXRpb25zKCkgY2FsbFxuICAgICAgLy8gYW5kIG9ubHkgc2NoZWR1bGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgIC8vIEF0IG1heGltdW0sIHdlIHdpbGwgdXBkYXRlIGR1bW15IGlucHV0cyBwb3NpdGlvbnNcbiAgICAgIC8vIF91cGRhdGVEdW1teUlucHV0c1RpbWVvdXQgKiAyIGFmdGVyIHRoZSBsYXN0IHVwZGF0ZVBvc2l0aW9ucygpIGNhbGwuXG4gICAgICBpZiAodGhpcy5fbGFzdFVwZGF0ZVF1ZXVlVGltZSArIF91cGRhdGVEdW1teUlucHV0c1RpbWVvdXQgPD0gRGF0ZS5ub3coKSkge1xuICAgICAgICAvLyBBIGNhY2hlIGZvciBjdXJyZW50IGJ1bGsgb2YgdXBkYXRlcyB0byByZWR1Y2UgZ2V0Q29tcHV0ZWRTdHlsZSgpIGNhbGxzLlxuICAgICAgICBjb25zdCBzY3JvbGxUb3BMZWZ0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHNldFRvcExlZnRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjb21wdXRlIG9mIHRoaXMuX3VwZGF0ZVF1ZXVlKSB7XG4gICAgICAgICAgc2V0VG9wTGVmdENhbGxiYWNrcy5wdXNoKGNvbXB1dGUoc2Nyb2xsVG9wTGVmdENhY2hlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlUXVldWUuY2xlYXIoKTtcbiAgICAgICAgLy8gV2UncmUgc3BsaXR0aW5nIHRoZSBjb21wdXRhdGlvbiBvZiBvZmZzZXRzIGFuZCBzZXR0aW5nIHRoZW0gdG8gYXZvaWQgZXh0cmFcbiAgICAgICAgLy8gcmVmbG93cy5cbiAgICAgICAgZm9yIChjb25zdCBzZXRUb3BMZWZ0IG9mIHNldFRvcExlZnRDYWxsYmFja3MpIHtcbiAgICAgICAgICBzZXRUb3BMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXRseSBjbGVhciB0byBub3QgaG9sZCByZWZlcmVuY2VzIHRpbGwgdGhlIG5leHQgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICBzY3JvbGxUb3BMZWZ0Q2FjaGUuY2xlYXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZFVwZGF0ZVBvc2l0aW9ucygpO1xuICAgICAgfVxuICAgIH0sIF91cGRhdGVEdW1teUlucHV0c1RpbWVvdXQpO1xuICB9XG59XG4vKipcbiAqIFBhcmVudCBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgYmVoYXZpb3VyIG9mIGR1bW15IGlucHV0cyAoZm9jdXMgc2VudGluZWxzKVxuICovXG5jbGFzcyBEdW1teUlucHV0TWFuYWdlckNvcmUge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBtYW5hZ2VyLCBwcmlvcml0eSwgc3lzLCBvdXRzaWRlQnlEZWZhdWx0LCBjYWxsRm9yRGVmYXVsdEFjdGlvbikge1xuICAgIHRoaXMuX3dyYXBwZXJzID0gW107XG4gICAgdGhpcy5faXNPdXRzaWRlID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNmb3JtRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fb25Gb2N1c0luID0gKGR1bW15SW5wdXQsIGlzQmFja3dhcmQsIHJlbGF0ZWRUYXJnZXQpID0+IHtcbiAgICAgIHRoaXMuX29uRm9jdXModHJ1ZSwgZHVtbXlJbnB1dCwgaXNCYWNrd2FyZCwgcmVsYXRlZFRhcmdldCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzT3V0ID0gKGR1bW15SW5wdXQsIGlzQmFja3dhcmQsIHJlbGF0ZWRUYXJnZXQpID0+IHtcbiAgICAgIHRoaXMuX29uRm9jdXMoZmFsc2UsIGR1bW15SW5wdXQsIGlzQmFja3dhcmQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlT3V0ID0gYmFja3dhcmRzID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmlyc3REdW1teTtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9sYXN0RHVtbXk7XG4gICAgICBpZiAoZmlyc3QgJiYgbGFzdCkge1xuICAgICAgICAvLyBGb3IgdGhlIHNha2Ugb2YgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCB0aGUgZHVtbXkgaW5wdXRcbiAgICAgICAgLy8gcG9zaXRpb24gaW4gdGhlIERPTSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5IGZyb20gdGhlIERPTSBjaGFuZ2UuXG4gICAgICAgIC8vIENhbGxpbmcgX2Vuc3VyZVBvc2l0aW9uKCkgdG8gbWFrZSBzdXJlIHRoZSBwb3NpdGlvbiBpcyBjb3JyZWN0LlxuICAgICAgICB0aGlzLl9lbnN1cmVQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gZmlyc3QuaW5wdXQ7XG4gICAgICAgIGNvbnN0IGxhc3RJbnB1dCA9IGxhc3QuaW5wdXQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICAgIGlmIChmaXJzdElucHV0ICYmIGxhc3RJbnB1dCAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgbGV0IHRvRm9jdXM7XG4gICAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgZmlyc3RJbnB1dC50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICB0b0ZvY3VzID0gZmlyc3RJbnB1dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdElucHV0LnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIHRvRm9jdXMgPSBsYXN0SW5wdXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0ZvY3VzKSB7XG4gICAgICAgICAgICBuYXRpdmVGb2N1cyh0b0ZvY3VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRvIG1vdmUgZm9jdXMgb3V0IG9mIHRoZSBnaXZlbiBlbGVtZW50IGJ5IGZvY3VzaW5nXG4gICAgICogb25lIG9mIHRoZSBkdW1teSBpbnB1dHMgYW5kIHNldHRpbmcgdGhlIGB1c2VEZWZhdWx0QWN0aW9uYCBmbGFnXG4gICAgICogQHBhcmFtIGJhY2t3YXJkcyBmb2N1cyBtb3ZpbmcgdG8gYW4gZWxlbWVudCBiZWhpbmQgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLm1vdmVPdXRXaXRoRGVmYXVsdEFjdGlvbiA9IChiYWNrd2FyZHMsIHJlbGF0ZWRFdmVudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9maXJzdER1bW15O1xuICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX2xhc3REdW1teTtcbiAgICAgIGlmIChmaXJzdCAmJiBsYXN0KSB7XG4gICAgICAgIC8vIEZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIHRoZSBkdW1teSBpbnB1dFxuICAgICAgICAvLyBwb3NpdGlvbiBpbiB0aGUgRE9NIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgRE9NIGNoYW5nZS5cbiAgICAgICAgLy8gQ2FsbGluZyBfZW5zdXJlUG9zaXRpb24oKSB0byBtYWtlIHN1cmUgdGhlIHBvc2l0aW9uIGlzIGNvcnJlY3QuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBmaXJzdC5pbnB1dDtcbiAgICAgICAgY29uc3QgbGFzdElucHV0ID0gbGFzdC5pbnB1dDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChfYSA9IHRoaXMuX2VsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICAgICAgaWYgKGZpcnN0SW5wdXQgJiYgbGFzdElucHV0ICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICBsZXQgdG9Gb2N1cztcbiAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0LmlzT3V0c2lkZSAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbGVtZW50LCB0cnVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgICAgICB0b0ZvY3VzID0gZWxlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpcnN0LnVzZURlZmF1bHRBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBmaXJzdElucHV0LnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgdG9Gb2N1cyA9IGZpcnN0SW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QudXNlRGVmYXVsdEFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBsYXN0SW5wdXQudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgdG9Gb2N1cyA9IGxhc3RJbnB1dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvRm9jdXMgJiYgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICAgICAgYnk6IFwicm9vdFwiLFxuICAgICAgICAgICAgb3duZXI6IGVsZW1lbnQsXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50XG4gICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICBuYXRpdmVGb2N1cyh0b0ZvY3VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2V0VGFiYmFibGUgPSAobWFuYWdlciwgdGFiYmFibGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBmb3IgKGNvbnN0IHcgb2YgdGhpcy5fd3JhcHBlcnMpIHtcbiAgICAgICAgaWYgKHcubWFuYWdlciA9PT0gbWFuYWdlcikge1xuICAgICAgICAgIHcudGFiYmFibGUgPSB0YWJiYWJsZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMuX2dldEN1cnJlbnQoKTtcbiAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gd3JhcHBlci50YWJiYWJsZSA/IDAgOiAtMTtcbiAgICAgICAgbGV0IGlucHV0ID0gKF9hID0gdGhpcy5fZmlyc3REdW1teSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlucHV0O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICBpbnB1dC50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gKF9iID0gdGhpcy5fbGFzdER1bW15KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5wdXQ7XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIGlucHV0LnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICB0aGlzLl9maXJzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2ZpcnN0RHVtbXksIHRoaXMuX3dyYXBwZXJzKTtcbiAgICAgICAgdGhpcy5fbGFzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2xhc3REdW1teSwgdGhpcy5fd3JhcHBlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBkdW1teSBpbnB1dHMgYXMgdGhlIGZpcnN0IGFuZCBsYXN0IGNoaWxkIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICogQ2FsbGVkIGVhY2ggdGltZSB0aGUgY2hpbGRyZW4gdW5kZXIgdGhlIGVsZW1lbnQgaXMgbXV0YXRlZFxuICAgICAqL1xuICAgIHRoaXMuX2FkZER1bW15SW5wdXRzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2FkZFRpbWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZFRpbWVyID0gdGhpcy5fZ2V0V2luZG93KCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hZGRUaW1lcjtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9maXJzdER1bW15LCB0aGlzLl93cmFwcGVycyk7XG4gICAgICAgICAgdGhpcy5fbGFzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2xhc3REdW1teSwgdGhpcy5fd3JhcHBlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFRyYW5zZm9ybU9mZnNldHMoKTtcbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgdGhpcy5fYWRkVHJhbnNmb3JtT2Zmc2V0cyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuX2R1bW15T2JzZXJ2ZXIudXBkYXRlUG9zaXRpb25zKHRoaXMuX2NvbXB1dGVUcmFuc2Zvcm1PZmZzZXRzKTtcbiAgICB9O1xuICAgIHRoaXMuX2NvbXB1dGVUcmFuc2Zvcm1PZmZzZXRzID0gc2Nyb2xsVG9wTGVmdENhY2hlID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBmcm9tID0gKChfYSA9IHRoaXMuX2ZpcnN0RHVtbXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnB1dCkgfHwgKChfYiA9IHRoaXMuX2xhc3REdW1teSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0KTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybUVsZW1lbnRzID0gdGhpcy5fdHJhbnNmb3JtRWxlbWVudHM7XG4gICAgICBjb25zdCBuZXdUcmFuc2Zvcm1FbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgIGxldCBzY3JvbGxUb3AgPSAwO1xuICAgICAgbGV0IHNjcm9sbExlZnQgPSAwO1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgICBmb3IgKGxldCBlbGVtZW50ID0gZnJvbTsgZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTsgZWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGxldCBzY3JvbGxUb3BMZWZ0ID0gc2Nyb2xsVG9wTGVmdENhY2hlLmdldChlbGVtZW50KTtcbiAgICAgICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSgpIGFuZCBlbGVtZW50LnNjcm9sbExlZnQvVG9wKCkgY2F1c2Ugc3R5bGUgcmVjYWxjdWxhdGlvbixcbiAgICAgICAgLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBhY3Jvc3MgYWxsIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGJ1bGsuXG4gICAgICAgIGlmIChzY3JvbGxUb3BMZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS50cmFuc2Zvcm07XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBzY3JvbGxUb3BMZWZ0ID0ge1xuICAgICAgICAgICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbFRvcExlZnRDYWNoZS5zZXQoZWxlbWVudCwgc2Nyb2xsVG9wTGVmdCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsVG9wTGVmdCkge1xuICAgICAgICAgIG5ld1RyYW5zZm9ybUVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybUVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuX2FkZFRyYW5zZm9ybU9mZnNldHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxUb3AgKz0gc2Nyb2xsVG9wTGVmdC5zY3JvbGxUb3A7XG4gICAgICAgICAgc2Nyb2xsTGVmdCArPSBzY3JvbGxUb3BMZWZ0LnNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgdHJhbnNmb3JtRWxlbWVudHMpIHtcbiAgICAgICAgaWYgKCFuZXdUcmFuc2Zvcm1FbGVtZW50cy5oYXMoZWwpKSB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9hZGRUcmFuc2Zvcm1PZmZzZXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fdHJhbnNmb3JtRWxlbWVudHMgPSBuZXdUcmFuc2Zvcm1FbGVtZW50cztcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHRoaXMuX2ZpcnN0RHVtbXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRUb3BMZWZ0KHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCk7XG4gICAgICAgIChfYiA9IHRoaXMuX2xhc3REdW1teSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFRvcExlZnQoc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBlbCA9IGVsZW1lbnQuZ2V0KCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudFwiKTtcbiAgICB9XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fZ2V0V2luZG93ID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGhpcy5fY2FsbEZvckRlZmF1bHRBY3Rpb24gPSBjYWxsRm9yRGVmYXVsdEFjdGlvbjtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGVsLl9fdGFic3RlckR1bW15O1xuICAgIChpbnN0YW5jZSB8fCB0aGlzKS5fd3JhcHBlcnMucHVzaCh7XG4gICAgICBtYW5hZ2VyLFxuICAgICAgcHJpb3JpdHksXG4gICAgICB0YWJiYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0RHVtbXkgJiYgc2V0RHVtbXlJbnB1dERlYnVnVmFsdWUodGhpcy5fZmlyc3REdW1teSwgaW5zdGFuY2UuX3dyYXBwZXJzKTtcbiAgICAgICAgdGhpcy5fbGFzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2xhc3REdW1teSwgaW5zdGFuY2UuX3dyYXBwZXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgZWwuX190YWJzdGVyRHVtbXkgPSB0aGlzO1xuICAgIC8vIFNvbWUgZWxlbWVudHMgYWxsb3cgb25seSBzcGVjaWZpYyB0eXBlcyBvZiBkaXJlY3QgZGVzY2VuZGFudHMgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBwdXQgb3VyIGR1bW15IGlucHV0cyBpbnNpZGUgb3Igb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBhY2NvcmRpbmdseS5cbiAgICBjb25zdCBmb3JjZWREdW1teVBvc2l0aW9uID0gc3lzID09PSBudWxsIHx8IHN5cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3lzLmR1bW15SW5wdXRzUG9zaXRpb247XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XG4gICAgdGhpcy5faXNPdXRzaWRlID0gIWZvcmNlZER1bW15UG9zaXRpb24gPyAob3V0c2lkZUJ5RGVmYXVsdCB8fCB0YWdOYW1lID09PSBcIlVMXCIgfHwgdGFnTmFtZSA9PT0gXCJPTFwiIHx8IHRhZ05hbWUgPT09IFwiVEFCTEVcIikgJiYgISh0YWdOYW1lID09PSBcIkxJXCIgfHwgdGFnTmFtZSA9PT0gXCJURFwiIHx8IHRhZ05hbWUgPT09IFwiVEhcIikgOiBmb3JjZWREdW1teVBvc2l0aW9uID09PSBTeXNEdW1teUlucHV0c1Bvc2l0aW9ucy5PdXRzaWRlO1xuICAgIHRoaXMuX2ZpcnN0RHVtbXkgPSBuZXcgRHVtbXlJbnB1dCh0aGlzLl9nZXRXaW5kb3csIHRoaXMuX2lzT3V0c2lkZSwge1xuICAgICAgaXNGaXJzdDogdHJ1ZVxuICAgIH0sIGVsZW1lbnQpO1xuICAgIHRoaXMuX2xhc3REdW1teSA9IG5ldyBEdW1teUlucHV0KHRoaXMuX2dldFdpbmRvdywgdGhpcy5faXNPdXRzaWRlLCB7XG4gICAgICBpc0ZpcnN0OiBmYWxzZVxuICAgIH0sIGVsZW1lbnQpO1xuICAgIC8vIFdlIHdpbGwgYmUgY2hlY2tpbmcgZHVtbXkgaW5wdXQgcGFyZW50cyB0byBzZWUgaWYgdGhlaXIgY2hpbGQgbGlzdCBoYXZlIGNoYW5nZWQuXG4gICAgLy8gU28sIGl0IGlzIGVub3VnaCB0byBoYXZlIGp1c3Qgb25lIG9mIHRoZSBpbnB1dHMgb2JzZXJ2ZWQsIGJlY2F1c2VcbiAgICAvLyBib3RoIGR1bW15IGlucHV0cyBhbHdheXMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQuXG4gICAgY29uc3QgZHVtbXlFbGVtZW50ID0gdGhpcy5fZmlyc3REdW1teS5pbnB1dDtcbiAgICBkdW1teUVsZW1lbnQgJiYgdGFic3Rlci5fZHVtbXlPYnNlcnZlci5hZGQoZHVtbXlFbGVtZW50LCB0aGlzLl9hZGREdW1teUlucHV0cyk7XG4gICAgdGhpcy5fZmlyc3REdW1teS5vbkZvY3VzSW4gPSB0aGlzLl9vbkZvY3VzSW47XG4gICAgdGhpcy5fZmlyc3REdW1teS5vbkZvY3VzT3V0ID0gdGhpcy5fb25Gb2N1c091dDtcbiAgICB0aGlzLl9sYXN0RHVtbXkub25Gb2N1c0luID0gdGhpcy5fb25Gb2N1c0luO1xuICAgIHRoaXMuX2xhc3REdW1teS5vbkZvY3VzT3V0ID0gdGhpcy5fb25Gb2N1c091dDtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9hZGREdW1teUlucHV0cygpO1xuICB9XG4gIGRpc3Bvc2UobWFuYWdlciwgZm9yY2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qgd3JhcHBlcnMgPSB0aGlzLl93cmFwcGVycyA9IHRoaXMuX3dyYXBwZXJzLmZpbHRlcih3ID0+IHcubWFuYWdlciAhPT0gbWFuYWdlciAmJiAhZm9yY2UpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhpcy5fZmlyc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9maXJzdER1bW15LCB3cmFwcGVycyk7XG4gICAgICB0aGlzLl9sYXN0RHVtbXkgJiYgc2V0RHVtbXlJbnB1dERlYnVnVmFsdWUodGhpcy5fbGFzdER1bW15LCB3cmFwcGVycyk7XG4gICAgfVxuICAgIGlmICh3cmFwcGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSAoKF9hID0gdGhpcy5fZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpKS5fX3RhYnN0ZXJEdW1teTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5fdHJhbnNmb3JtRWxlbWVudHMpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9hZGRUcmFuc2Zvcm1PZmZzZXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyYW5zZm9ybUVsZW1lbnRzLmNsZWFyKCk7XG4gICAgICBjb25zdCB3aW4gPSB0aGlzLl9nZXRXaW5kb3coKTtcbiAgICAgIGlmICh0aGlzLl9hZGRUaW1lcikge1xuICAgICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX2FkZFRpbWVyKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FkZFRpbWVyO1xuICAgICAgfVxuICAgICAgY29uc3QgZHVtbXlFbGVtZW50ID0gKF9iID0gdGhpcy5fZmlyc3REdW1teSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0O1xuICAgICAgZHVtbXlFbGVtZW50ICYmIHRoaXMuX3RhYnN0ZXIuX2R1bW15T2JzZXJ2ZXIucmVtb3ZlKGR1bW15RWxlbWVudCk7XG4gICAgICAoX2MgPSB0aGlzLl9maXJzdER1bW15KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzcG9zZSgpO1xuICAgICAgKF9kID0gdGhpcy5fbGFzdER1bW15KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICBfb25Gb2N1cyhpc0luLCBkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLl9nZXRDdXJyZW50KCk7XG4gICAgaWYgKHdyYXBwZXIgJiYgKCFkdW1teUlucHV0LnVzZURlZmF1bHRBY3Rpb24gfHwgdGhpcy5fY2FsbEZvckRlZmF1bHRBY3Rpb24pKSB7XG4gICAgICAoX2EgPSB3cmFwcGVyLm1hbmFnZXIuZ2V0SGFuZGxlcihpc0luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGR1bW15SW5wdXQsIGlzQmFja3dhcmQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgfVxuICBfZ2V0Q3VycmVudCgpIHtcbiAgICB0aGlzLl93cmFwcGVycy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS50YWJiYWJsZSAhPT0gYi50YWJiYWJsZSkge1xuICAgICAgICByZXR1cm4gYS50YWJiYWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlcnNbMF07XG4gIH1cbiAgX2Vuc3VyZVBvc2l0aW9uKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgY29uc3QgZmlyc3REdW1teUlucHV0ID0gKF9iID0gdGhpcy5fZmlyc3REdW1teSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0O1xuICAgIGNvbnN0IGxhc3REdW1teUlucHV0ID0gKF9jID0gdGhpcy5fbGFzdER1bW15KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5wdXQ7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFmaXJzdER1bW15SW5wdXQgfHwgIWxhc3REdW1teUlucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc091dHNpZGUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRQYXJlbnQgPSBkb20uZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICAgIGlmIChlbGVtZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZG9tLmdldE5leHRTaWJsaW5nKGVsZW1lbnQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmcgIT09IGxhc3REdW1teUlucHV0KSB7XG4gICAgICAgICAgZG9tLmluc2VydEJlZm9yZShlbGVtZW50UGFyZW50LCBsYXN0RHVtbXlJbnB1dCwgbmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbGVtZW50KSAhPT0gZmlyc3REdW1teUlucHV0KSB7XG4gICAgICAgICAgZG9tLmluc2VydEJlZm9yZShlbGVtZW50UGFyZW50LCBmaXJzdER1bW15SW5wdXQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb20uZ2V0TGFzdEVsZW1lbnRDaGlsZChlbGVtZW50KSAhPT0gbGFzdER1bW15SW5wdXQpIHtcbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKGVsZW1lbnQsIGxhc3REdW1teUlucHV0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0RWxlbWVudENoaWxkID0gZG9tLmdldEZpcnN0RWxlbWVudENoaWxkKGVsZW1lbnQpO1xuICAgICAgaWYgKGZpcnN0RWxlbWVudENoaWxkICYmIGZpcnN0RWxlbWVudENoaWxkICE9PSBmaXJzdER1bW15SW5wdXQgJiYgZmlyc3RFbGVtZW50Q2hpbGQucGFyZW50Tm9kZSkge1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKGZpcnN0RWxlbWVudENoaWxkLnBhcmVudE5vZGUsIGZpcnN0RHVtbXlJbnB1dCwgZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGFzdENoaWxkJDIoY29udGFpbmVyKSB7XG4gIGxldCBsYXN0Q2hpbGQgPSBudWxsO1xuICBmb3IgKGxldCBpID0gZG9tLmdldExhc3RFbGVtZW50Q2hpbGQoY29udGFpbmVyKTsgaTsgaSA9IGRvbS5nZXRMYXN0RWxlbWVudENoaWxkKGkpKSB7XG4gICAgbGFzdENoaWxkID0gaTtcbiAgfVxuICByZXR1cm4gbGFzdENoaWxkIHx8IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEFkamFjZW50RWxlbWVudChmcm9tLCBwcmV2KSB7XG4gIGxldCBjdXIgPSBmcm9tO1xuICBsZXQgYWRqYWNlbnQgPSBudWxsO1xuICB3aGlsZSAoY3VyICYmICFhZGphY2VudCkge1xuICAgIGFkamFjZW50ID0gcHJldiA/IGRvbS5nZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nKGN1cikgOiBkb20uZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGN1cik7XG4gICAgY3VyID0gZG9tLmdldFBhcmVudEVsZW1lbnQoY3VyKTtcbiAgfVxuICByZXR1cm4gYWRqYWNlbnQgfHwgdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYXVnbWVudEF0dHJpYnV0ZSh0YWJzdGVyLCBlbGVtZW50LCBuYW1lLCB2YWx1ZSAvLyBSZXN0b3JlIG9yaWdpbmFsIHZhbHVlIHdoZW4gdW5kZWZpbmVkLlxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gIGNvbnN0IGVudHJ5ID0gdGFic3Rlci5zdG9yYWdlRW50cnkoZWxlbWVudCwgdHJ1ZSk7XG4gIGxldCByZXQgPSBmYWxzZTtcbiAgaWYgKCFlbnRyeS5hdWcpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZW50cnkuYXVnID0ge307XG4gIH1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobmFtZSBpbiBlbnRyeS5hdWcpIHtcbiAgICAgIGNvbnN0IG9yaWdWYWwgPSBlbnRyeS5hdWdbbmFtZV07XG4gICAgICBkZWxldGUgZW50cnkuYXVnW25hbWVdO1xuICAgICAgaWYgKG9yaWdWYWwgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCBvcmlnVmFsKTtcbiAgICAgIH1cbiAgICAgIHJldCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBvcmlnVmFsdWU7XG4gICAgaWYgKCEobmFtZSBpbiBlbnRyeS5hdWcpKSB7XG4gICAgICBvcmlnVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgaWYgKG9yaWdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9yaWdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGVudHJ5LmF1Z1tuYW1lXSA9IG9yaWdWYWx1ZTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKGVudHJ5LmF1ZykubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIGVudHJ5LmF1ZztcbiAgICB0YWJzdGVyLnN0b3JhZ2VFbnRyeShlbGVtZW50LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGlzRGlzcGxheU5vbmUoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBlbGVtZW50RG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSAoX2EgPSBlbGVtZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBvZmZzZXRQYXJlbnQgaXMgbnVsbCBmb3IgZWxlbWVudHMgd2l0aCBkaXNwbGF5Om5vbmUsIGRpc3BsYXk6Zml4ZWQgYW5kIGZvciA8Ym9keT4uXG4gIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbCAmJiBlbGVtZW50RG9jdW1lbnQuYm9keSAhPT0gZWxlbWVudCAmJiAoY29tcHV0ZWRTdHlsZSA9PT0gbnVsbCB8fCBjb21wdXRlZFN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uKSAhPT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gRm9yIG91ciBwdXJwb3NlcyBvZiBsb29raW5nIGZvciBmb2N1c2FibGUgZWxlbWVudHMsIHZpc2liaWxpdHk6aGlkZGVuIGhhcyB0aGUgc2FtZVxuICAvLyBlZmZlY3QgYXMgZGlzcGxheTpub25lLlxuICBpZiAoKGNvbXB1dGVkU3R5bGUgPT09IG51bGwgfHwgY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcHV0ZWRTdHlsZS52aXNpYmlsaXR5KSA9PT0gXCJoaWRkZW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGlmIGFuIGVsZW1lbnQgaGFzIGRpc3BsYXk6IGZpeGVkLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIGFsc28gaGlkZGVuIHdpdGggQ1NTLFxuICAvLyBvciB3aXRoaW4gYSBwYXJlbnQgaGlkZGVuIHdpdGggQ1NTXG4gIGlmICgoY29tcHV0ZWRTdHlsZSA9PT0gbnVsbCB8fCBjb21wdXRlZFN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uKSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgaWYgKGNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKChfYiA9IGVsZW1lbnQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9mZnNldFBhcmVudCkgPT09IG51bGwgJiYgZWxlbWVudERvY3VtZW50LmJvZHkgIT09IGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmFkaW8oZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgISFlbGVtZW50Lm5hbWUgJiYgZWxlbWVudC50eXBlID09PSBcInJhZGlvXCI7XG59XG5mdW5jdGlvbiBnZXRSYWRpb0J1dHRvbkdyb3VwKGVsZW1lbnQpIHtcbiAgaWYgKCFpc1JhZGlvKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gIGxldCByYWRpb0J1dHRvbnMgPSBBcnJheS5mcm9tKGRvbS5nZXRFbGVtZW50c0J5TmFtZShlbGVtZW50LCBuYW1lKSk7XG4gIGxldCBjaGVja2VkO1xuICByYWRpb0J1dHRvbnMgPSByYWRpb0J1dHRvbnMuZmlsdGVyKGVsID0+IHtcbiAgICBpZiAoaXNSYWRpbyhlbCkpIHtcbiAgICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICAgIGNoZWNrZWQgPSBlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgYnV0dG9uczogbmV3IFNldChyYWRpb0J1dHRvbnMpLFxuICAgIGNoZWNrZWRcbiAgfTtcbn1cbi8qKlxuICogSWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIFRhYnN0ZXIgZHVtbXkgaW5wdXQsIHJldHVybnMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoaXMgZHVtbXkgaW5wdXQgYmVsb25ncyB0by5cbiAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gY2hlY2sgZm9yIGJlaW5nIGR1bW15IGlucHV0LlxuICogQHJldHVybnMgRHVtbXkgaW5wdXQgY29udGFpbmVyIGVsZW1lbnQgKGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBhIGR1bW15IGlucHV0KSBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXREdW1teUlucHV0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5fX3RhYnN0ZXJEdW1teUNvbnRhaW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpKSB8fCBudWxsO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRUYWJzdGVyQXR0cmlidXRlKHByb3BzLCBwbGFpbikge1xuICBjb25zdCBhdHRyID0gSlNPTi5zdHJpbmdpZnkocHJvcHMpO1xuICBpZiAocGxhaW4gPT09IHRydWUpIHtcbiAgICByZXR1cm4gYXR0cjtcbiAgfVxuICByZXR1cm4ge1xuICAgIFtUQUJTVEVSX0FUVFJJQlVURV9OQU1FXTogYXR0clxuICB9O1xufVxuLyoqXG4gKiBVcGRhdGVzIFRhYnN0ZXIgcHJvcHMgb2JqZWN0IHdpdGggbmV3IHByb3BzLlxuICogQHBhcmFtIGVsZW1lbnQgYW4gZWxlbWVudCB0byBzZXQgZGF0YS10YWJzdGVyIGF0dHJpYnV0ZSBvbi5cbiAqIEBwYXJhbSBwcm9wcyBjdXJyZW50IFRhYnN0ZXIgcHJvcHMgdG8gdXBkYXRlLlxuICogQHBhcmFtIG5ld1Byb3BzIG5ldyBUYWJzdGVyIHByb3BzIHRvIGFkZC5cbiAqICBXaGVuIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIG5ld1Byb3BzIGlzIHVuZGVmaW5lZCwgdGhlIHByb3BlcnR5XG4gKiAgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VUYWJzdGVyUHJvcHMocHJvcHMsIG5ld1Byb3BzKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld1Byb3BzKSkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3UHJvcHNba2V5XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICBwcm9wc1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBTZXRzIG9yIHVwZGF0ZXMgVGFic3RlciBhdHRyaWJ1dGUgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCBhbiBlbGVtZW50IHRvIHNldCBkYXRhLXRhYnN0ZXIgYXR0cmlidXRlIG9uLlxuICogQHBhcmFtIG5ld1Byb3BzIG5ldyBUYWJzdGVyIHByb3BzIHRvIHNldC5cbiAqIEBwYXJhbSB1cGRhdGUgaWYgdHJ1ZSwgbmV3UHJvcHMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZXhpc3RpbmcgcHJvcHMuXG4gKiAgV2hlbiB0cnVlIGFuZCB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBuZXdQcm9wcyBpcyB1bmRlZmluZWQsIHRoZSBwcm9wZXJ0eVxuICogIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldFRhYnN0ZXJBdHRyaWJ1dGUoZWxlbWVudCwgbmV3UHJvcHMsIHVwZGF0ZSkge1xuICBsZXQgcHJvcHM7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBjb25zdCBhdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoVEFCU1RFUl9BVFRSSUJVVEVfTkFNRSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3BzID0gSlNPTi5wYXJzZShhdHRyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgZGF0YS10YWJzdGVyIGF0dHJpYnV0ZSBlcnJvcjogJHtlfWAsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIG1lcmdlVGFic3RlclByb3BzKHByb3BzLCBuZXdQcm9wcyk7XG4gIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFRBQlNURVJfQVRUUklCVVRFX05BTUUsIGdldFRhYnN0ZXJBdHRyaWJ1dGUocHJvcHMsIHRydWUpKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfc2V0SW5mb3JtYXRpdmVTdHlsZSQzKHdlYWtFbGVtZW50LCByZW1vdmUsIGlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB3ZWFrRWxlbWVudC5nZXQoKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS10YWJzdGVyLXJvb3RcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS10YWJzdGVyLXJvb3RcIiwgaWQgKyBcIixcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBSb290RHVtbXlNYW5hZ2VyIGV4dGVuZHMgRHVtbXlJbnB1dE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBzZXRGb2N1c2VkLCBzeXMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCBlbGVtZW50LCBEdW1teUlucHV0TWFuYWdlclByaW9yaXRpZXMuUm9vdCwgc3lzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHRoaXMuX29uRHVtbXlJbnB1dEZvY3VzID0gZHVtbXlJbnB1dCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZHVtbXlJbnB1dC51c2VEZWZhdWx0QWN0aW9uKSB7XG4gICAgICAgIC8vIFdoZW4gd2UndmUgcmVhY2hlZCB0aGUgbGFzdCBmb2N1c2FibGUgZWxlbWVudCwgd2Ugd2FudCB0byBsZXQgdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gdG8gbW92ZSB0aGUgZm9jdXMgb3V0c2lkZSBvZiB0aGUgcGFnZS4gSW4gb3JkZXIgdG8gZG8gdGhhdCB3ZSdyZSBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGNhbGxpbmcgZm9jdXMoKSBvZiB0aGUgZHVtbXkgaW5wdXQgZnJvbSB0aGUgVGFiIGtleSBoYW5kbGVyIGFuZCBhbGxvd2luZ1xuICAgICAgICAvLyB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gbW92ZSB0aGUgZm9jdXMgb3V0LlxuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSBhIGR1bW15IGlucHV0IGdldHMgZm9jdXNlZCBpcyBkdXJpbmcgdGhlIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAgICAgIHRoaXMuX3RhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLnNldE5hdmlnYXRpbmdXaXRoS2V5Ym9hcmQodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3NldEZvY3VzZWQodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rmlyc3RPckxhc3RUYWJiYWJsZShkdW1teUlucHV0LmlzRmlyc3QsIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogZWxlbWVudCxcbiAgICAgICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodG9Gb2N1cykge1xuICAgICAgICAgICAgbmF0aXZlRm9jdXModG9Gb2N1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYSA9IGR1bW15SW5wdXQuaW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ibHVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9zZXRIYW5kbGVycyh0aGlzLl9vbkR1bW15SW5wdXRGb2N1cyk7XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fc2V0Rm9jdXNlZCA9IHNldEZvY3VzZWQ7XG4gIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBUYWJzdGVyUGFydCB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGVsZW1lbnQsIG9uRGlzcG9zZSwgcHJvcHMsIHN5cykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zZXRGb2N1c2VkID0gaGFzRm9jdXNlZCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5fc2V0Rm9jdXNlZFRpbWVyKSB7XG4gICAgICAgIHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93KCkuY2xlYXJUaW1lb3V0KHRoaXMuX3NldEZvY3VzZWRUaW1lcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zZXRGb2N1c2VkVGltZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNGb2N1c2VkID09PSBoYXNGb2N1c2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGhhc0ZvY3VzZWQpIHtcbiAgICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgIChfYSA9IHRoaXMuX2R1bW15TWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFRhYmJhYmxlKGZhbHNlKTtcbiAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFJvb3RGb2N1c0V2ZW50KHtcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZFRpbWVyID0gdGhpcy5fdGFic3Rlci5nZXRXaW5kb3coKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZXRGb2N1c2VkVGltZXI7XG4gICAgICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX2R1bW15TWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFRhYmJhYmxlKHRydWUpO1xuICAgICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBSb290Qmx1ckV2ZW50KHtcbiAgICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzSW4gPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBnZXRQYXJlbnQgPSB0aGlzLl90YWJzdGVyLmdldFBhcmVudDtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIGxldCBjdXJFbGVtZW50ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjdXJFbGVtZW50ID09PSByb290RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3NldEZvY3VzZWQodHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN1ckVsZW1lbnQgPSBjdXJFbGVtZW50ICYmIGdldFBhcmVudChjdXJFbGVtZW50KTtcbiAgICAgIH0gd2hpbGUgKGN1ckVsZW1lbnQpO1xuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c091dCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5fb25EaXNwb3NlID0gb25EaXNwb3NlO1xuICAgIGNvbnN0IHdpbiA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMudWlkID0gZ2V0RWxlbWVudFVJZCh3aW4sIGVsZW1lbnQpO1xuICAgIHRoaXMuX3N5cyA9IHN5cztcbiAgICBpZiAodGFic3Rlci5jb250cm9sVGFiIHx8IHRhYnN0ZXIucm9vdER1bW15SW5wdXRzKSB7XG4gICAgICB0aGlzLmFkZER1bW15SW5wdXRzKCk7XG4gICAgfVxuICAgIGNvbnN0IHcgPSB3aW4oKTtcbiAgICBjb25zdCBkb2MgPSB3LmRvY3VtZW50O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKEtFWUJPUkdfRk9DVVNJTiwgdGhpcy5fb25Gb2N1c0luKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTT1VULCB0aGlzLl9vbkZvY3VzT3V0KTtcbiAgICB0aGlzLl9hZGQoKTtcbiAgfVxuICBhZGREdW1teUlucHV0cygpIHtcbiAgICBpZiAoIXRoaXMuX2R1bW15TWFuYWdlcikge1xuICAgICAgdGhpcy5fZHVtbXlNYW5hZ2VyID0gbmV3IFJvb3REdW1teU1hbmFnZXIodGhpcy5fdGFic3RlciwgdGhpcy5fZWxlbWVudCwgdGhpcy5fc2V0Rm9jdXNlZCwgdGhpcy5fc3lzKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5fb25EaXNwb3NlKHRoaXMpO1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93KCk7XG4gICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKEtFWUJPUkdfRk9DVVNJTiwgdGhpcy5fb25Gb2N1c0luKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTT1VULCB0aGlzLl9vbkZvY3VzT3V0KTtcbiAgICBpZiAodGhpcy5fc2V0Rm9jdXNlZFRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3NldEZvY3VzZWRUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5fc2V0Rm9jdXNlZFRpbWVyO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLl9kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcmVtb3ZlKCk7XG4gIH1cbiAgbW92ZU91dFdpdGhEZWZhdWx0QWN0aW9uKGlzQmFja3dhcmQsIHJlbGF0ZWRFdmVudCkge1xuICAgIGNvbnN0IGR1bW15TWFuYWdlciA9IHRoaXMuX2R1bW15TWFuYWdlcjtcbiAgICBpZiAoZHVtbXlNYW5hZ2VyKSB7XG4gICAgICBkdW1teU1hbmFnZXIubW92ZU91dFdpdGhEZWZhdWx0QWN0aW9uKGlzQmFja3dhcmQsIHJlbGF0ZWRFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgUm9vdER1bW15TWFuYWdlci5tb3ZlV2l0aFBoYW50b21EdW1teSh0aGlzLl90YWJzdGVyLCBlbCwgdHJ1ZSwgaXNCYWNrd2FyZCwgcmVsYXRlZEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2FkZCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDModGhpcy5fZWxlbWVudCwgZmFsc2UsIHRoaXMudWlkKTtcbiAgICB9XG4gIH1cbiAgX3JlbW92ZSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDModGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBSb290QVBJIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgYXV0b1Jvb3QpIHtcbiAgICB0aGlzLl9hdXRvUm9vdFdhaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yb290cyA9IHt9O1xuICAgIHRoaXMuX2ZvcmNlRHVtbXkgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RCeUlkID0ge307XG4gICAgdGhpcy5fYXV0b1Jvb3RDcmVhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl93aW4oKS5kb2N1bWVudDtcbiAgICAgIGNvbnN0IGJvZHkgPSBkb2MuYm9keTtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHRoaXMuX2F1dG9Sb290VW53YWl0KGRvYyk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5fYXV0b1Jvb3Q7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIHNldFRhYnN0ZXJBdHRyaWJ1dGUoYm9keSwge1xuICAgICAgICAgICAgcm9vdDogcHJvcHNcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICB1cGRhdGVUYWJzdGVyQnlBdHRyaWJ1dGUodGhpcy5fdGFic3RlciwgYm9keSk7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgYm9keSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb290O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9hdXRvUm9vdFdhaXRpbmcpIHtcbiAgICAgICAgdGhpcy5fYXV0b1Jvb3RXYWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2F1dG9Sb290Q3JlYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLl9vblJvb3REaXNwb3NlID0gcm9vdCA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fcm9vdHNbcm9vdC5pZF07XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLl9hdXRvUm9vdCA9IGF1dG9Sb290O1xuICAgIHRhYnN0ZXIucXVldWVJbml0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9hdXRvUm9vdCkge1xuICAgICAgICB0aGlzLl9hdXRvUm9vdENyZWF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9hdXRvUm9vdFVud2FpdChkb2MpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5fYXV0b1Jvb3RDcmVhdGUpO1xuICAgIHRoaXMuX2F1dG9Sb290V2FpdGluZyA9IGZhbHNlO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgdGhpcy5fYXV0b1Jvb3RVbndhaXQod2luLmRvY3VtZW50KTtcbiAgICBkZWxldGUgdGhpcy5fYXV0b1Jvb3Q7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcm9vdHMpLmZvckVhY2gocm9vdElkID0+IHtcbiAgICAgIGlmICh0aGlzLl9yb290c1tyb290SWRdKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RzW3Jvb3RJZF0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcm9vdHNbcm9vdElkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJvb3RCeUlkID0ge307XG4gIH1cbiAgY3JlYXRlUm9vdChlbGVtZW50LCBwcm9wcywgc3lzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSA7XG4gICAgY29uc3QgbmV3Um9vdCA9IG5ldyBSb290KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQsIHRoaXMuX29uUm9vdERpc3Bvc2UsIHByb3BzLCBzeXMpO1xuICAgIHRoaXMuX3Jvb3RzW25ld1Jvb3QuaWRdID0gbmV3Um9vdDtcbiAgICBpZiAodGhpcy5fZm9yY2VEdW1teSkge1xuICAgICAgbmV3Um9vdC5hZGREdW1teUlucHV0cygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um9vdDtcbiAgfVxuICBhZGREdW1teUlucHV0cygpIHtcbiAgICB0aGlzLl9mb3JjZUR1bW15ID0gdHJ1ZTtcbiAgICBjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMocm9vdHMpKSB7XG4gICAgICByb290c1tpZF0uYWRkRHVtbXlJbnB1dHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldFJvb3RCeVVJZChnZXRXaW5kb3csIGlkKSB7XG4gICAgY29uc3QgdGFic3RlciA9IGdldFdpbmRvdygpLl9fdGFic3Rlckluc3RhbmNlO1xuICAgIHJldHVybiB0YWJzdGVyICYmIHRhYnN0ZXIucm9vdC5yb290QnlJZFtpZF07XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRhYnN0ZXIgY29udGV4dCBmb3IgYW4gZWxlbWVudCB3YWxraW5nIHVwIGl0cyBhbmNlc3RvcnNcbiAgICpcbiAgICogQHBhcmFtIHRhYnN0ZXIgVGFic3RlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGUgdGFic3RlciBjb250ZXh0IHNob3VsZCByZXByZXNlbnRcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgZWxlbWVudCBpcyBub3QgYSBjaGlsZCBvZiBhIHRhYnN0ZXIgcm9vdCwgb3RoZXJ3aXNlIGFsbCBhcHBsaWNhYmxlIHRhYnN0ZXIgYmVoYXZpb3VycyBhbmQgY29uZmlndXJhdGlvbnNcbiAgICovXG4gIHN0YXRpYyBnZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKCFlbGVtZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNoZWNrUnRsLFxuICAgICAgcmVmZXJlbmNlRWxlbWVudFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGdldFBhcmVudCA9IHRhYnN0ZXIuZ2V0UGFyZW50O1xuICAgIC8vIE5vcm1hbGx5LCB0aGUgaW5pdGlhbGl6YXRpb24gc3RhcnRzIG9uIHRoZSBuZXh0IHRpY2sgYWZ0ZXIgdGhlIHRhYnN0ZXJcbiAgICAvLyBpbnN0YW5jZSBjcmVhdGlvbi4gSG93ZXZlciwgaWYgdGhlIGFwcGxpY2F0aW9uIHN0YXJ0cyB1c2luZyBpdCBiZWZvcmVcbiAgICAvLyB0aGUgbmV4dCB0aWNrLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgaW5pdGlhbGl6YXRpb24gaXMgZG9uZS5cbiAgICB0YWJzdGVyLmRyYWluSW5pdFF1ZXVlKCk7XG4gICAgbGV0IHJvb3Q7XG4gICAgbGV0IG1vZGFsaXplcjtcbiAgICBsZXQgZ3JvdXBwZXI7XG4gICAgbGV0IG1vdmVyO1xuICAgIGxldCBleGNsdWRlZEZyb21Nb3ZlciA9IGZhbHNlO1xuICAgIGxldCBncm91cHBlckJlZm9yZU1vdmVyO1xuICAgIGxldCBtb2RhbGl6ZXJJbkdyb3VwcGVyO1xuICAgIGxldCBkaXJSaWdodFRvTGVmdDtcbiAgICBsZXQgdW5jb250cm9sbGVkO1xuICAgIGxldCBjdXJFbGVtZW50ID0gcmVmZXJlbmNlRWxlbWVudCB8fCBlbGVtZW50O1xuICAgIGNvbnN0IGlnbm9yZUtleWRvd24gPSB7fTtcbiAgICB3aGlsZSAoY3VyRWxlbWVudCAmJiAoIXJvb3QgfHwgY2hlY2tSdGwpKSB7XG4gICAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBjdXJFbGVtZW50KTtcbiAgICAgIGlmIChjaGVja1J0bCAmJiBkaXJSaWdodFRvTGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGN1ckVsZW1lbnQuZGlyO1xuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgZGlyUmlnaHRUb0xlZnQgPSBkaXIudG9Mb3dlckNhc2UoKSA9PT0gXCJydGxcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0YWJzdGVyT25FbGVtZW50KSB7XG4gICAgICAgIGN1ckVsZW1lbnQgPSBnZXRQYXJlbnQoY3VyRWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFnTmFtZSA9IGN1ckVsZW1lbnQudGFnTmFtZTtcbiAgICAgIGlmICgodGFic3Rlck9uRWxlbWVudC51bmNvbnRyb2xsZWQgfHwgdGFnTmFtZSA9PT0gXCJJRlJBTUVcIiB8fCB0YWdOYW1lID09PSBcIldFQlZJRVdcIikgJiYgdGFic3Rlci5mb2N1c2FibGUuaXNWaXNpYmxlKGN1ckVsZW1lbnQpKSB7XG4gICAgICAgIHVuY29udHJvbGxlZCA9IGN1ckVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIW1vdmVyICYmICgoX2EgPSB0YWJzdGVyT25FbGVtZW50LmZvY3VzYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4Y2x1ZGVGcm9tTW92ZXIpICYmICFncm91cHBlcikge1xuICAgICAgICBleGNsdWRlZEZyb21Nb3ZlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJNb2RhbGl6ZXIgPSB0YWJzdGVyT25FbGVtZW50Lm1vZGFsaXplcjtcbiAgICAgIGNvbnN0IGN1ckdyb3VwcGVyID0gdGFic3Rlck9uRWxlbWVudC5ncm91cHBlcjtcbiAgICAgIGNvbnN0IGN1ck1vdmVyID0gdGFic3Rlck9uRWxlbWVudC5tb3ZlcjtcbiAgICAgIGlmICghbW9kYWxpemVyICYmIGN1ck1vZGFsaXplcikge1xuICAgICAgICBtb2RhbGl6ZXIgPSBjdXJNb2RhbGl6ZXI7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwcGVyICYmIGN1ckdyb3VwcGVyICYmICghbW9kYWxpemVyIHx8IGN1ck1vZGFsaXplcikpIHtcbiAgICAgICAgaWYgKG1vZGFsaXplcikge1xuICAgICAgICAgIC8vIE1vZGFsaXplciBkb21pbmF0ZXMgdGhlIGdyb3VwcGVyIHdoZW4gdGhleSBhcmUgb24gdGhlIHNhbWUgbm9kZSBhbmQgdGhlIGdyb3VwcGVyIGlzIGFjdGl2ZS5cbiAgICAgICAgICBpZiAoIWN1ckdyb3VwcGVyLmlzQWN0aXZlKCkgJiYgY3VyR3JvdXBwZXIuZ2V0UHJvcHMoKS50YWJiYWJpbGl0eSAmJiBtb2RhbGl6ZXIudXNlcklkICE9PSAoKF9iID0gdGFic3Rlci5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3RpdmVJZCkpIHtcbiAgICAgICAgICAgIG1vZGFsaXplciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGdyb3VwcGVyID0gY3VyR3JvdXBwZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGFsaXplckluR3JvdXBwZXIgPSBjdXJHcm91cHBlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cHBlciA9IGN1ckdyb3VwcGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1vdmVyICYmIGN1ck1vdmVyICYmICghbW9kYWxpemVyIHx8IGN1ck1vZGFsaXplcikgJiYgKCFjdXJHcm91cHBlciB8fCBjdXJFbGVtZW50ICE9PSBlbGVtZW50KSAmJiBjdXJFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQpIC8vIE1vdmVyIG1ha2VzIHNlbnNlIG9ubHkgZm9yIHJlYWxseSBpbnNpZGUgZWxlbWVudHMsIG5vdCBmb3IgdmlydXRhbCBvdXQgb2YgdGhlIERPTSBvcmRlciBjaGlsZHJlbi5cbiAgICAgICkge1xuICAgICAgICBtb3ZlciA9IGN1ck1vdmVyO1xuICAgICAgICBncm91cHBlckJlZm9yZU1vdmVyID0gISFncm91cHBlciAmJiBncm91cHBlciAhPT0gY3VyR3JvdXBwZXI7XG4gICAgICB9XG4gICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5yb290KSB7XG4gICAgICAgIHJvb3QgPSB0YWJzdGVyT25FbGVtZW50LnJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAoKF9jID0gdGFic3Rlck9uRWxlbWVudC5mb2N1c2FibGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pZ25vcmVLZXlkb3duKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaWdub3JlS2V5ZG93biwgdGFic3Rlck9uRWxlbWVudC5mb2N1c2FibGUuaWdub3JlS2V5ZG93bik7XG4gICAgICB9XG4gICAgICBjdXJFbGVtZW50ID0gZ2V0UGFyZW50KGN1ckVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBObyByb290IGVsZW1lbnQgY291bGQgYmUgZm91bmQsIHRyeSB0byBnZXQgYW4gYXV0byByb290XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBjb25zdCByb290QVBJID0gdGFic3Rlci5yb290O1xuICAgICAgY29uc3QgYXV0b1Jvb3QgPSByb290QVBJLl9hdXRvUm9vdDtcbiAgICAgIGlmIChhdXRvUm9vdCkge1xuICAgICAgICBpZiAoKF9kID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYm9keSkge1xuICAgICAgICAgIHJvb3QgPSByb290QVBJLl9hdXRvUm9vdENyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncm91cHBlciAmJiAhbW92ZXIpIHtcbiAgICAgIGdyb3VwcGVyQmVmb3JlTW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIXJvb3QpIHtcbiAgICAgIGlmIChtb2RhbGl6ZXIgfHwgZ3JvdXBwZXIgfHwgbW92ZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRhYnN0ZXIgUm9vdCBpcyByZXF1aXJlZCBmb3IgTW92ZXIsIEdyb3VwcGVyIGFuZCBNb2RhbGl6ZXIgdG8gd29yay5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZElnbm9yZUtleWRvd24gPSBldmVudCA9PiAhIWlnbm9yZUtleWRvd25bZXZlbnQua2V5XTtcbiAgICByZXR1cm4gcm9vdCA/IHtcbiAgICAgIHJvb3QsXG4gICAgICBtb2RhbGl6ZXIsXG4gICAgICBncm91cHBlcixcbiAgICAgIG1vdmVyLFxuICAgICAgZ3JvdXBwZXJCZWZvcmVNb3ZlcixcbiAgICAgIG1vZGFsaXplckluR3JvdXBwZXIsXG4gICAgICBydGw6IGNoZWNrUnRsID8gISFkaXJSaWdodFRvTGVmdCA6IHVuZGVmaW5lZCxcbiAgICAgIHVuY29udHJvbGxlZCxcbiAgICAgIGV4Y2x1ZGVkRnJvbU1vdmVyLFxuICAgICAgaWdub3JlS2V5ZG93bjogc2hvdWxkSWdub3JlS2V5ZG93blxuICAgIH0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgc3RhdGljIGdldFJvb3QodGFic3RlciwgZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBnZXRQYXJlbnQgPSB0YWJzdGVyLmdldFBhcmVudDtcbiAgICBmb3IgKGxldCBlbCA9IGVsZW1lbnQ7IGVsOyBlbCA9IGdldFBhcmVudChlbCkpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3Q7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBvblJvb3Qocm9vdCwgcmVtb3ZlZCkge1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBkZWxldGUgdGhpcy5yb290QnlJZFtyb290LnVpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdEJ5SWRbcm9vdC51aWRdID0gcm9vdDtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgX2NvbnRhaW5lckhpc3RvcnlMZW5ndGggPSAxMDtcbmNsYXNzIERlbG9zZXJJdGVtQmFzZSB7fVxuY2xhc3MgRGVsb3Nlckl0ZW0gZXh0ZW5kcyBEZWxvc2VySXRlbUJhc2Uge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBkZWxvc2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVpZCA9IGRlbG9zZXIudWlkO1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX2RlbG9zZXIgPSBkZWxvc2VyO1xuICB9XG4gIGJlbG9uZ3NUbyhkZWxvc2VyKSB7XG4gICAgcmV0dXJuIGRlbG9zZXIgPT09IHRoaXMuX2RlbG9zZXI7XG4gIH1cbiAgdW5zaGlmdChlbGVtZW50KSB7XG4gICAgdGhpcy5fZGVsb3Nlci51bnNoaWZ0KGVsZW1lbnQpO1xuICB9XG4gIGFzeW5jIGZvY3VzQXZhaWxhYmxlKCkge1xuICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuX2RlbG9zZXIuZmluZEF2YWlsYWJsZSgpO1xuICAgIGNvbnN0IGRlbG9zZXJFbGVtZW50ID0gdGhpcy5fZGVsb3Nlci5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGF2YWlsYWJsZSAmJiBkZWxvc2VyRWxlbWVudCkge1xuICAgICAgaWYgKCFkZWxvc2VyRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICBieTogXCJkZWxvc2VyXCIsXG4gICAgICAgIG93bmVyOiBkZWxvc2VyRWxlbWVudCxcbiAgICAgICAgbmV4dDogYXZhaWxhYmxlXG4gICAgICB9KSkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBhY3Rpb24gaXMgcHJldmVudGVkLCBkb24ndCBsb29rIGZ1cnRoZXIuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZm9jdXMoYXZhaWxhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlc2V0Rm9jdXMoKSB7XG4gICAgY29uc3QgZ2V0V2luZG93ID0gdGhpcy5fdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgcmV0dXJuIGdldFByb21pc2UoZ2V0V2luZG93KS5yZXNvbHZlKHRoaXMuX2RlbG9zZXIucmVzZXRGb2N1cygpKTtcbiAgfVxufVxuY2xhc3MgRGVsb3Nlckhpc3RvcnlCeVJvb3RCYXNlIHtcbiAgY29uc3RydWN0b3IodGFic3Rlciwgcm9vdFVJZCkge1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLnJvb3RVSWQgPSByb290VUlkO1xuICB9XG4gIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yeS5sZW5ndGg7XG4gIH1cbiAgcmVtb3ZlRGVsb3NlcihkZWxvc2VyKSB7XG4gICAgdGhpcy5faGlzdG9yeSA9IHRoaXMuX2hpc3RvcnkuZmlsdGVyKGMgPT4gIWMuYmVsb25nc1RvKGRlbG9zZXIpKTtcbiAgfVxuICBoYXNEZWxvc2VyKGRlbG9zZXIpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yeS5zb21lKGQgPT4gZC5iZWxvbmdzVG8oZGVsb3NlcikpO1xuICB9XG59XG5jbGFzcyBEZWxvc2VySGlzdG9yeUJ5Um9vdCBleHRlbmRzIERlbG9zZXJIaXN0b3J5QnlSb290QmFzZSB7XG4gIHVuc2hpZnRUb0RlbG9zZXIoZGVsb3NlciwgZWxlbWVudCkge1xuICAgIGxldCBpdGVtO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGlzdG9yeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlbaV0uYmVsb25nc1RvKGRlbG9zZXIpKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9oaXN0b3J5W2ldO1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgaXRlbSA9IG5ldyBEZWxvc2VySXRlbSh0aGlzLl90YWJzdGVyLCBkZWxvc2VyKTtcbiAgICB9XG4gICAgaXRlbS51bnNoaWZ0KGVsZW1lbnQpO1xuICAgIHRoaXMuX2hpc3RvcnkudW5zaGlmdChpdGVtKTtcbiAgICB0aGlzLl9oaXN0b3J5LnNwbGljZShfY29udGFpbmVySGlzdG9yeUxlbmd0aCwgdGhpcy5faGlzdG9yeS5sZW5ndGggLSBfY29udGFpbmVySGlzdG9yeUxlbmd0aCk7XG4gIH1cbiAgYXN5bmMgZm9jdXNBdmFpbGFibGUoZnJvbSkge1xuICAgIGxldCBza2lwID0gISFmcm9tO1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoZnJvbSAmJiBpLmJlbG9uZ3NUbyhmcm9tKSkge1xuICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaS5mb2N1c0F2YWlsYWJsZSgpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgbnVsbCB3aGVuIHRoZSBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGxvb2sgZnVydGhlci5cbiAgICAgICAgaWYgKHJlc3VsdCB8fCByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZXNldEZvY3VzKGZyb20pIHtcbiAgICBsZXQgc2tpcCA9ICEhZnJvbTtcbiAgICBjb25zdCByZXNldFF1ZXVlID0ge307XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2hpc3RvcnkpIHtcbiAgICAgIGlmIChmcm9tICYmIGkuYmVsb25nc1RvKGZyb20pKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcCAmJiAhcmVzZXRRdWV1ZVtpLnVpZF0pIHtcbiAgICAgICAgcmVzZXRRdWV1ZVtpLnVpZF0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RoaW5nIGlzIGZvdW5kLCBhdCBsZWFzdCB0cnkgdG8gcmVzZXQuXG4gICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhyZXNldFF1ZXVlKSkge1xuICAgICAgaWYgKGF3YWl0IHJlc2V0UXVldWVbaWRdLnJlc2V0Rm9jdXMoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBEZWxvc2VySGlzdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gIH1cbiAgcHJvY2VzcyhlbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgY29uc3Qgcm9vdFVJZCA9IGN0eCAmJiBjdHgucm9vdC51aWQ7XG4gICAgY29uc3QgZGVsb3NlciA9IERlbG9zZXJBUEkuZ2V0RGVsb3Nlcih0aGlzLl90YWJzdGVyLCBlbGVtZW50KTtcbiAgICBpZiAoIXJvb3RVSWQgfHwgIWRlbG9zZXIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlCeVJvb3QgPSB0aGlzLm1ha2Uocm9vdFVJZCwgKCkgPT4gbmV3IERlbG9zZXJIaXN0b3J5QnlSb290KHRoaXMuX3RhYnN0ZXIsIHJvb3RVSWQpKTtcbiAgICBpZiAoIWN0eCB8fCAhY3R4Lm1vZGFsaXplciB8fCAoKF9hID0gY3R4Lm1vZGFsaXplcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQWN0aXZlKCkpKSB7XG4gICAgICBoaXN0b3J5QnlSb290LnVuc2hpZnRUb0RlbG9zZXIoZGVsb3NlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBkZWxvc2VyO1xuICB9XG4gIG1ha2Uocm9vdFVJZCwgY3JlYXRlSW5zdGFuY2UpIHtcbiAgICBsZXQgaGlzdG9yeUJ5Um9vdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2hpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGhiciA9IHRoaXMuX2hpc3RvcnlbaV07XG4gICAgICBpZiAoaGJyLnJvb3RVSWQgPT09IHJvb3RVSWQpIHtcbiAgICAgICAgaGlzdG9yeUJ5Um9vdCA9IGhicjtcbiAgICAgICAgdGhpcy5faGlzdG9yeS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhpc3RvcnlCeVJvb3QpIHtcbiAgICAgIGhpc3RvcnlCeVJvb3QgPSBjcmVhdGVJbnN0YW5jZSgpO1xuICAgIH1cbiAgICB0aGlzLl9oaXN0b3J5LnVuc2hpZnQoaGlzdG9yeUJ5Um9vdCk7XG4gICAgdGhpcy5faGlzdG9yeS5zcGxpY2UoX2NvbnRhaW5lckhpc3RvcnlMZW5ndGgsIHRoaXMuX2hpc3RvcnkubGVuZ3RoIC0gX2NvbnRhaW5lckhpc3RvcnlMZW5ndGgpO1xuICAgIHJldHVybiBoaXN0b3J5QnlSb290O1xuICB9XG4gIHJlbW92ZURlbG9zZXIoZGVsb3Nlcikge1xuICAgIHRoaXMuX2hpc3RvcnkuZm9yRWFjaChpID0+IHtcbiAgICAgIGkucmVtb3ZlRGVsb3NlcihkZWxvc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9oaXN0b3J5ID0gdGhpcy5faGlzdG9yeS5maWx0ZXIoaSA9PiBpLmdldExlbmd0aCgpID4gMCk7XG4gIH1cbiAgYXN5bmMgZm9jdXNBdmFpbGFibGUoZnJvbSkge1xuICAgIGxldCBza2lwID0gISFmcm9tO1xuICAgIGZvciAoY29uc3QgaCBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoZnJvbSAmJiBoLmhhc0RlbG9zZXIoZnJvbSkpIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGguZm9jdXNBdmFpbGFibGUoZnJvbSk7XG4gICAgICAgIC8vIFJlc3VsdCBpcyBudWxsIHdoZW4gdGhlIGRlZmF1bHQgYWN0aW9uIGlzIHByZXZlbnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgLy8gYW5kIHdlIGRvbid0IG5lZWQgdG8gbG9vayBmdXJ0aGVyLlxuICAgICAgICBpZiAocmVzdWx0IHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlc2V0Rm9jdXMoZnJvbSkge1xuICAgIGxldCBza2lwID0gISFmcm9tO1xuICAgIGZvciAoY29uc3QgaCBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoZnJvbSAmJiBoLmhhc0RlbG9zZXIoZnJvbSkpIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwICYmIChhd2FpdCBoLnJlc2V0Rm9jdXMoZnJvbSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDIod2Vha0VsZW1lbnQsIHJlbW92ZSwgaXNBY3RpdmUsIHNuYXBzaG90SW5kZXgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHdlYWtFbGVtZW50LmdldCgpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXRhYnN0ZXItZGVsb3NlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRhYnN0ZXItZGVsb3NlclwiLCAoaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogXCJpbmFjdGl2ZVwiKSArIFwiLFwiICsgKFwic25hcHNob3QtXCIgKyBzbmFwc2hvdEluZGV4KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBidWlsZEVsZW1lbnRTZWxlY3RvcihlbGVtZW50LCB3aXRoQ2xhc3MsIHdpdGhJbmRleCkge1xuICBjb25zdCBzZWxlY3RvciA9IFtdO1xuICBjb25zdCBlc2NhcGVSZWdFeHAgPSAvKDp8XFwufFxcW3xcXF18LHw9fEApL2c7XG4gIGNvbnN0IGVzY2FwZVJlcGxhY2VWYWx1ZSA9IFwiXFxcXCQxXCI7XG4gIGNvbnN0IGVsZW1lbnRJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG4gIGlmIChlbGVtZW50SWQpIHtcbiAgICBzZWxlY3Rvci5wdXNoKFwiI1wiICsgZWxlbWVudElkLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCBlc2NhcGVSZXBsYWNlVmFsdWUpKTtcbiAgfVxuICBpZiAod2l0aENsYXNzICE9PSBmYWxzZSAmJiBlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGNscyA9PiB7XG4gICAgICBjbHMgPSBjbHMudHJpbSgpO1xuICAgICAgaWYgKGNscykge1xuICAgICAgICBzZWxlY3Rvci5wdXNoKFwiLlwiICsgY2xzLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCBlc2NhcGVSZXBsYWNlVmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgZWw7XG4gIGlmICh3aXRoSW5kZXggIT09IGZhbHNlICYmIHNlbGVjdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgIGVsID0gZWxlbWVudDtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHNlbGVjdG9yLnVuc2hpZnQoXCI6bnRoLWNoaWxkKFwiICsgaW5kZXggKyBcIilcIik7XG4gIH1cbiAgc2VsZWN0b3IudW5zaGlmdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiBzZWxlY3Rvci5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gYnVpbGRTZWxlY3RvcihlbGVtZW50KSB7XG4gIGlmICghZG9jdW1lbnRDb250YWlucyhlbGVtZW50Lm93bmVyRG9jdW1lbnQsIGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IFtidWlsZEVsZW1lbnRTZWxlY3RvcihlbGVtZW50KV07XG4gIGxldCBub2RlID0gZG9tLmdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgIC8vIFN0b3AgYXQgdGhlIHNoYWRvdyByb290IGFzIGNyb3NzIHNoYWRvdyBzZWxlY3RvcnMgd29uJ3Qgd29yay5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIGNvbnN0IGlzQm9keSA9IG5vZGUudGFnTmFtZSA9PT0gXCJCT0RZXCI7XG4gICAgICBzZWxlY3Rvci51bnNoaWZ0KGJ1aWxkRWxlbWVudFNlbGVjdG9yKG5vZGUsIGZhbHNlLCAhaXNCb2R5KSk7XG4gICAgICBpZiAoaXNCb2R5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gZG9tLmdldFBhcmVudE5vZGUobm9kZSk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdG9yLmpvaW4oXCIgXCIpO1xufVxuY2xhc3MgRGVsb3NlciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgb25EaXNwb3NlLCBwcm9wcykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbW11dO1xuICAgIHRoaXMuX3NuYXBzaG90SW5kZXggPSAwO1xuICAgIHRoaXMuaXNBY3RpdmUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5faXNBY3RpdmU7XG4gICAgfTtcbiAgICB0aGlzLnNldFNuYXBzaG90ID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy5fc25hcHNob3RJbmRleCA9IGluZGV4O1xuICAgICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gaW5kZXggKyAxKSB7XG4gICAgICAgIHRoaXMuX2hpc3Rvcnkuc3BsaWNlKGluZGV4ICsgMSwgdGhpcy5faGlzdG9yeS5sZW5ndGggLSBpbmRleCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9oaXN0b3J5W2luZGV4XSkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W2luZGV4XSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDIodGhpcy5fZWxlbWVudCwgZmFsc2UsIHRoaXMuX2lzQWN0aXZlLCB0aGlzLl9zbmFwc2hvdEluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZm9jdXNGaXJzdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgcmV0dXJuICEhZSAmJiB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzRmlyc3Qoe1xuICAgICAgICBjb250YWluZXI6IGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5mb2N1c0RlZmF1bHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIHJldHVybiAhIWUgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1c0RlZmF1bHQoZSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0Rm9jdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIHJldHVybiAhIWUgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5yZXNldEZvY3VzKGUpO1xuICAgIH07XG4gICAgdGhpcy5jbGVhckhpc3RvcnkgPSBwcmVzZXJ2ZUV4aXN0aW5nID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlbdGhpcy5fc25hcHNob3RJbmRleF0gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faGlzdG9yeVt0aGlzLl9zbmFwc2hvdEluZGV4XSA9IHRoaXMuX2hpc3RvcnlbdGhpcy5fc25hcHNob3RJbmRleF0uZmlsdGVyKHdlID0+IHtcbiAgICAgICAgY29uc3QgZSA9IHdlLmdldCgpO1xuICAgICAgICByZXR1cm4gZSAmJiBwcmVzZXJ2ZUV4aXN0aW5nID8gZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlKSA6IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnVpZCA9IGdldEVsZW1lbnRVSWQodGFic3Rlci5nZXRXaW5kb3csIGVsZW1lbnQpO1xuICAgIHRoaXMuc3RyYXRlZ3kgPSBwcm9wcy5zdHJhdGVneSB8fCBEZWxvc2VyU3RyYXRlZ2llcy5BdXRvO1xuICAgIHRoaXMuX29uRGlzcG9zZSA9IG9uRGlzcG9zZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDIodGhpcy5fZWxlbWVudCwgZmFsc2UsIHRoaXMuX2lzQWN0aXZlLCB0aGlzLl9zbmFwc2hvdEluZGV4KTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICB0aGlzLl9vbkRpc3Bvc2UodGhpcyk7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zbmFwc2hvdEluZGV4ID0gMDtcbiAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgfVxuICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBhY3RpdmU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQyKHRoaXMuX2VsZW1lbnQsIGZhbHNlLCB0aGlzLl9pc0FjdGl2ZSwgdGhpcy5fc25hcHNob3RJbmRleCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzRGVmYXVsdDogdGhpcy5mb2N1c0RlZmF1bHQsXG4gICAgICBmb2N1c0ZpcnN0OiB0aGlzLmZvY3VzRmlyc3QsXG4gICAgICByZXNldEZvY3VzOiB0aGlzLnJlc2V0Rm9jdXMsXG4gICAgICBjbGVhckhpc3Rvcnk6IHRoaXMuY2xlYXJIaXN0b3J5LFxuICAgICAgc2V0U25hcHNob3Q6IHRoaXMuc2V0U25hcHNob3QsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5pc0FjdGl2ZVxuICAgIH07XG4gIH1cbiAgdW5zaGlmdChlbGVtZW50KSB7XG4gICAgbGV0IGN1ciA9IHRoaXMuX2hpc3RvcnlbdGhpcy5fc25hcHNob3RJbmRleF07XG4gICAgY3VyID0gdGhpcy5faGlzdG9yeVt0aGlzLl9zbmFwc2hvdEluZGV4XSA9IGN1ci5maWx0ZXIod2UgPT4ge1xuICAgICAgY29uc3QgZSA9IHdlLmdldCgpO1xuICAgICAgcmV0dXJuIGUgJiYgZSAhPT0gZWxlbWVudDtcbiAgICB9KTtcbiAgICBjdXIudW5zaGlmdChuZXcgV2Vha0hUTUxFbGVtZW50KHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93LCBlbGVtZW50LCBidWlsZFNlbGVjdG9yKGVsZW1lbnQpKSk7XG4gICAgd2hpbGUgKGN1ci5sZW5ndGggPiBfY29udGFpbmVySGlzdG9yeUxlbmd0aCkge1xuICAgICAgY3VyLnBvcCgpO1xuICAgIH1cbiAgfVxuICBmaW5kQXZhaWxhYmxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgIGlmICghZWxlbWVudCB8fCAhdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlc3RvcmVGb2N1c09yZGVyID0gdGhpcy5fcHJvcHMucmVzdG9yZUZvY3VzT3JkZXI7XG4gICAgbGV0IGF2YWlsYWJsZSA9IG51bGw7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBlbGVtZW50KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBjdHgucm9vdDtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHJvb3QuZ2V0RWxlbWVudCgpO1xuICAgIGlmICghcm9vdEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzdG9yZUZvY3VzT3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdG9yZUZvY3VzT3JkZXIgPSByb290LmdldFByb3BzKCkucmVzdG9yZUZvY3VzT3JkZXI7XG4gICAgfVxuICAgIGlmIChyZXN0b3JlRm9jdXNPcmRlciA9PT0gUmVzdG9yZUZvY3VzT3JkZXJzLlJvb3REZWZhdWx0KSB7XG4gICAgICBhdmFpbGFibGUgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5maW5kRGVmYXVsdCh7XG4gICAgICAgIGNvbnRhaW5lcjogcm9vdEVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWF2YWlsYWJsZSAmJiByZXN0b3JlRm9jdXNPcmRlciA9PT0gUmVzdG9yZUZvY3VzT3JkZXJzLlJvb3RGaXJzdCkge1xuICAgICAgYXZhaWxhYmxlID0gdGhpcy5fZmluZEZpcnN0KHJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZTtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlSW5IaXN0b3J5ID0gdGhpcy5fZmluZEluSGlzdG9yeSgpO1xuICAgIGlmIChhdmFpbGFibGVJbkhpc3RvcnkgJiYgcmVzdG9yZUZvY3VzT3JkZXIgPT09IFJlc3RvcmVGb2N1c09yZGVycy5IaXN0b3J5KSB7XG4gICAgICByZXR1cm4gYXZhaWxhYmxlSW5IaXN0b3J5O1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVEZWZhdWx0ID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuZmluZERlZmF1bHQoe1xuICAgICAgY29udGFpbmVyOiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKGF2YWlsYWJsZURlZmF1bHQgJiYgcmVzdG9yZUZvY3VzT3JkZXIgPT09IFJlc3RvcmVGb2N1c09yZGVycy5EZWxvc2VyRGVmYXVsdCkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZURlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZUZpcnN0ID0gdGhpcy5fZmluZEZpcnN0KGVsZW1lbnQpO1xuICAgIGlmIChhdmFpbGFibGVGaXJzdCAmJiByZXN0b3JlRm9jdXNPcmRlciA9PT0gUmVzdG9yZUZvY3VzT3JkZXJzLkRlbG9zZXJGaXJzdCkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZUZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gYXZhaWxhYmxlRGVmYXVsdCB8fCBhdmFpbGFibGVJbkhpc3RvcnkgfHwgYXZhaWxhYmxlRmlyc3QgfHwgbnVsbDtcbiAgfVxuICBjdXN0b21Gb2N1c0xvc3RIYW5kbGVyKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBEZWxvc2VyRm9jdXNMb3N0RXZlbnQodGhpcy5nZXRBY3Rpb25zKCkpKTtcbiAgfVxuICBfZmluZEluSGlzdG9yeSgpIHtcbiAgICBjb25zdCBjdXIgPSB0aGlzLl9oaXN0b3J5W3RoaXMuX3NuYXBzaG90SW5kZXhdLnNsaWNlKDApO1xuICAgIHRoaXMuY2xlYXJIaXN0b3J5KHRydWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB3ZSA9IGN1cltpXTtcbiAgICAgIGNvbnN0IGUgPSB3ZS5nZXQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgaWYgKGUgJiYgZWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGUpKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlKSkge1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wcm9wcy5ub1NlbGVjdG9yQ2hlY2spIHtcbiAgICAgICAgLy8gRWxlbWVudCBpcyBub3QgaW4gdGhlIERPTSwgdHJ5IHRvIGxvY2F0ZSB0aGUgbm9kZSBieSBpdCdzXG4gICAgICAgIC8vIHNlbGVjdG9yLiBUaGlzIG1pZ2h0IHJldHVybiBub3QgZXhhY3RseSB0aGUgcmlnaHQgbm9kZSxcbiAgICAgICAgLy8gYnV0IGl0IHdvdWxkIGJlIGVhc2lseSBmaXhhYmxlIGJ5IGhhdmluZyBtb3JlIGRldGFpbGVkIHNlbGVjdG9ycy5cbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB3ZS5nZXREYXRhKCk7XG4gICAgICAgIGlmIChzZWxlY3RvciAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgbGV0IGVscztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudC5vd25lckRvY3VtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgdW5sZXNzIHRoZXJlIGlzIHNvbWUgYnVnIGluIGJ1aWxkRWxlbWVudFNlbGVjdG9yKCkuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBxdWVyeVNlbGVjdG9yQWxsKCcke3NlbGVjdG9yfScpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gZWxzW2ldO1xuICAgICAgICAgICAgaWYgKGVsICYmIHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9maW5kRmlyc3QoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl90YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSkge1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5maW5kRmlyc3Qoe1xuICAgICAgICBjb250YWluZXI6IGVsZW1lbnQsXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfcmVtb3ZlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUkMih0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIERlbG9zZXJBUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBwcm9wcykge1xuICAgIC8qKlxuICAgICAqIFRyYWNrcyBpZiBmb2N1cyBpcyBpbnNpZGUgYSBkZWxvc2VyXG4gICAgICovXG4gICAgdGhpcy5faW5EZWxvc2VyID0gZmFsc2U7XG4gICAgdGhpcy5faXNSZXN0b3JpbmdGb2N1cyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fb25SZXN0b3JlRm9jdXMgPSBldmVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gKF9hID0gRGVsb3NlckFQSS5nZXREZWxvc2VyKHRoaXMuX3RhYnN0ZXIsIHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kQXZhaWxhYmxlKCk7XG4gICAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKGF2YWlsYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZSA9PiB7XG4gICAgICBpZiAodGhpcy5fcmVzdG9yZUZvY3VzVGltZXIpIHtcbiAgICAgICAgdGhpcy5fd2luKCkuY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyKTtcbiAgICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWUpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsb3NlciA9IHRoaXMuX2hpc3RvcnkucHJvY2VzcyhlKTtcbiAgICAgIGlmIChkZWxvc2VyKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKGRlbG9zZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25EZWxvc2VyRGlzcG9zZSA9IGRlbG9zZXIgPT4ge1xuICAgICAgdGhpcy5faGlzdG9yeS5yZW1vdmVEZWxvc2VyKGRlbG9zZXIpO1xuICAgICAgaWYgKGRlbG9zZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlc3RvcmVGb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGhpcy5faGlzdG9yeSA9IG5ldyBEZWxvc2VySGlzdG9yeSh0YWJzdGVyKTtcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX3dpbigpLmRvY3VtZW50O1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoRGVsb3NlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSwgdGhpcy5fb25SZXN0b3JlRm9jdXMpO1xuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvbS5nZXRBY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50ICE9PSBkb2MuYm9keSkge1xuICAgICAgICAvLyBBZGRpbmcgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB0byB0aGUgZGVsb3NlciBoaXN0b3J5LlxuICAgICAgICB0aGlzLl9vbkZvY3VzKGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGF1dG9EZWxvc2VyID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmF1dG9EZWxvc2VyO1xuICAgIGlmIChhdXRvRGVsb3Nlcikge1xuICAgICAgdGhpcy5fYXV0b0RlbG9zZXIgPSBhdXRvRGVsb3NlcjtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICBpZiAodGhpcy5fcmVzdG9yZUZvY3VzVGltZXIpIHtcbiAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5fcmVzdG9yZUZvY3VzVGltZXIpO1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hdXRvRGVsb3Nlckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9hdXRvRGVsb3Nlckluc3RhbmNlLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9hdXRvRGVsb3Nlckluc3RhbmNlO1xuICAgICAgZGVsZXRlIHRoaXMuX2F1dG9EZWxvc2VyO1xuICAgIH1cbiAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnVuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKERlbG9zZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uUmVzdG9yZUZvY3VzKTtcbiAgICB0aGlzLl9oaXN0b3J5LmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgdGhpcy5fY3VyRGVsb3NlcjtcbiAgfVxuICBjcmVhdGVEZWxvc2VyKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgO1xuICAgIGNvbnN0IGRlbG9zZXIgPSBuZXcgRGVsb3Nlcih0aGlzLl90YWJzdGVyLCBlbGVtZW50LCB0aGlzLl9vbkRlbG9zZXJEaXNwb3NlLCBwcm9wcyk7XG4gICAgaWYgKGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgKF9hID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKSkge1xuICAgICAgdGhpcy5fYWN0aXZhdGUoZGVsb3Nlcik7XG4gICAgfVxuICAgIHJldHVybiBkZWxvc2VyO1xuICB9XG4gIGdldEFjdGlvbnMoZWxlbWVudCkge1xuICAgIGZvciAobGV0IGUgPSBlbGVtZW50OyBlOyBlID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZSkpIHtcbiAgICAgIGNvbnN0IHRhYnN0ZXJPbkVsZW1lbnQgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGUpO1xuICAgICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQgJiYgdGFic3Rlck9uRWxlbWVudC5kZWxvc2VyKSB7XG4gICAgICAgIHJldHVybiB0YWJzdGVyT25FbGVtZW50LmRlbG9zZXIuZ2V0QWN0aW9ucygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcmVzdG9yZUZvY3VzVGltZXIpIHtcbiAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh0aGlzLl9yZXN0b3JlRm9jdXNUaW1lcik7XG4gICAgICB0aGlzLl9yZXN0b3JlRm9jdXNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmVzdW1lKHJlc3RvcmUpIHtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlc3RvcmVGb2N1cygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuZCBzZXRzIHRoZSBjdXJyZW50IGRlbG9zZXJcbiAgICovXG4gIF9hY3RpdmF0ZShkZWxvc2VyKSB7XG4gICAgY29uc3QgY3VyRGVsb3NlciA9IHRoaXMuX2N1ckRlbG9zZXI7XG4gICAgaWYgKGN1ckRlbG9zZXIgIT09IGRlbG9zZXIpIHtcbiAgICAgIHRoaXMuX2luRGVsb3NlciA9IHRydWU7XG4gICAgICBjdXJEZWxvc2VyID09PSBudWxsIHx8IGN1ckRlbG9zZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ckRlbG9zZXIuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgIGRlbG9zZXIuc2V0QWN0aXZlKHRydWUpO1xuICAgICAgdGhpcy5fY3VyRGVsb3NlciA9IGRlbG9zZXI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBmb2N1cyBzaG91bGQgbm8gbG9uZ2VyIGJlIGluIGEgZGVsb3NlclxuICAgKi9cbiAgX2RlYWN0aXZhdGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX2luRGVsb3NlciA9IGZhbHNlO1xuICAgIChfYSA9IHRoaXMuX2N1ckRlbG9zZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoZmFsc2UpO1xuICAgIHRoaXMuX2N1ckRlbG9zZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3NjaGVkdWxlUmVzdG9yZUZvY3VzKGZvcmNlKSB7XG4gICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8IHRoaXMuX2lzUmVzdG9yaW5nRm9jdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdG9yZUZvY3VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBsYXN0Rm9jdXNlZCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0TGFzdEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAoIWZvcmNlICYmICh0aGlzLl9pc1Jlc3RvcmluZ0ZvY3VzIHx8ICF0aGlzLl9pbkRlbG9zZXIgfHwgbGFzdEZvY3VzZWQgJiYgIWlzRGlzcGxheU5vbmUobGFzdEZvY3VzZWQpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJEZWxvc2VyID0gdGhpcy5fY3VyRGVsb3NlcjtcbiAgICAgIGxldCBpc01hbnVhbCA9IGZhbHNlO1xuICAgICAgaWYgKGN1ckRlbG9zZXIpIHtcbiAgICAgICAgaWYgKGxhc3RGb2N1c2VkICYmIGN1ckRlbG9zZXIuY3VzdG9tRm9jdXNMb3N0SGFuZGxlcihsYXN0Rm9jdXNlZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ckRlbG9zZXIuc3RyYXRlZ3kgPT09IERlbG9zZXJTdHJhdGVnaWVzLk1hbnVhbCkge1xuICAgICAgICAgIGlzTWFudWFsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjdXJEZWxvc2VyRWxlbWVudCA9IGN1ckRlbG9zZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgIGNvbnN0IGVsID0gY3VyRGVsb3Nlci5maW5kQXZhaWxhYmxlKCk7XG4gICAgICAgICAgaWYgKGVsICYmICghKGN1ckRlbG9zZXJFbGVtZW50ID09PSBudWxsIHx8IGN1ckRlbG9zZXJFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJEZWxvc2VyRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICAgICAgYnk6IFwiZGVsb3NlclwiLFxuICAgICAgICAgICAgb3duZXI6IGN1ckRlbG9zZXJFbGVtZW50LFxuICAgICAgICAgICAgbmV4dDogZWxcbiAgICAgICAgICB9KSkpIHx8IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZm9jdXMoZWwpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZSgpO1xuICAgICAgaWYgKGlzTWFudWFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzUmVzdG9yaW5nRm9jdXMgPSB0cnVlO1xuICAgICAgLy8gZm9jdXNBdmFpbGFibGUgcmV0dXJucyBudWxsIHdoZW4gdGhlIGRlZmF1bHQgYWN0aW9uIGlzIHByZXZlbnRlZCBieSB0aGUgYXBwbGljYXRpb24sIGZhbHNlXG4gICAgICAvLyB3aGVuIG5vdGhpbmcgd2FzIGZvY3VzZWQgYW5kIHRydWUgd2hlbiBzb21ldGhpbmcgd2FzIGZvY3VzZWQuXG4gICAgICBpZiAoKGF3YWl0IHRoaXMuX2hpc3RvcnkuZm9jdXNBdmFpbGFibGUobnVsbCkpID09PSBmYWxzZSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9oaXN0b3J5LnJlc2V0Rm9jdXMobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1Jlc3RvcmluZ0ZvY3VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHJlc3RvcmVGb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN0b3JlRm9jdXNUaW1lciA9IHRoaXMuX3dpbigpLnNldFRpbWVvdXQocmVzdG9yZUZvY3VzLCAxMDApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0RGVsb3Nlcih0YWJzdGVyLCBlbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCByb290O1xuICAgIGZvciAobGV0IGUgPSBlbGVtZW50OyBlOyBlID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZSkpIHtcbiAgICAgIGNvbnN0IHRhYnN0ZXJPbkVsZW1lbnQgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRhYnN0ZXIsIGUpO1xuICAgICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgcm9vdCA9IHRhYnN0ZXJPbkVsZW1lbnQucm9vdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxvc2VyID0gdGFic3Rlck9uRWxlbWVudC5kZWxvc2VyO1xuICAgICAgICBpZiAoZGVsb3Nlcikge1xuICAgICAgICAgIHJldHVybiBkZWxvc2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbG9zZXJBUEkgPSB0YWJzdGVyLmRlbG9zZXIgJiYgdGFic3Rlci5kZWxvc2VyO1xuICAgIGlmIChkZWxvc2VyQVBJKSB7XG4gICAgICBpZiAoZGVsb3NlckFQSS5fYXV0b0RlbG9zZXJJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZGVsb3NlckFQSS5fYXV0b0RlbG9zZXJJbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1dG9EZWxvc2VyUHJvcHMgPSBkZWxvc2VyQVBJLl9hdXRvRGVsb3NlcjtcbiAgICAgIGlmIChyb290ICYmICFkZWxvc2VyQVBJLl9hdXRvRGVsb3Nlckluc3RhbmNlICYmIGF1dG9EZWxvc2VyUHJvcHMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IChfYSA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvZHk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgZGVsb3NlckFQSS5fYXV0b0RlbG9zZXJJbnN0YW5jZSA9IG5ldyBEZWxvc2VyKHRhYnN0ZXIsIGJvZHksIHRhYnN0ZXIuZGVsb3Nlci5fb25EZWxvc2VyRGlzcG9zZSwgYXV0b0RlbG9zZXJQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxvc2VyQVBJLl9hdXRvRGVsb3Nlckluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXRpYyBnZXRIaXN0b3J5KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9oaXN0b3J5O1xuICB9XG4gIHN0YXRpYyBmb3JjZVJlc3RvcmVGb2N1cyhpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLl9zY2hlZHVsZVJlc3RvcmVGb2N1cyh0cnVlKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgIGRlbGV0ZSB0aGlzLl92YWw7XG4gIH1cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgc3Vic2NyaWJlRmlyc3QoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBjYWxsYmFja3MudW5zaGlmdChjYWxsYmFjayk7XG4gIH1cbiAgdW5zdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHNldFZhbCh2YWwsIGRldGFpbCkge1xuICAgIGlmICh0aGlzLl92YWwgPT09IHZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl92YWwgPSB2YWw7XG4gICAgdGhpcy5fY2FsbENhbGxiYWNrcyh2YWwsIGRldGFpbCk7XG4gIH1cbiAgZ2V0VmFsKCkge1xuICAgIHJldHVybiB0aGlzLl92YWw7XG4gIH1cbiAgdHJpZ2dlcih2YWwsIGRldGFpbCkge1xuICAgIHRoaXMuX2NhbGxDYWxsYmFja3ModmFsLCBkZXRhaWwpO1xuICB9XG4gIF9jYWxsQ2FsbGJhY2tzKHZhbCwgZGV0YWlsKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodmFsLCBkZXRhaWwpKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jb25zdCBfdHJhbnNhY3Rpb25UaW1lb3V0ID0gMTUwMDtcbmNvbnN0IF9waW5nVGltZW91dCA9IDMwMDA7XG5jb25zdCBfdGFyZ2V0SWRVcCA9IFwidXBcIjtcbmNvbnN0IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcyA9IHtcbiAgQm9vdHN0cmFwOiAxLFxuICBGb2N1c0VsZW1lbnQ6IDIsXG4gIFN0YXRlOiAzLFxuICBHZXRFbGVtZW50OiA0LFxuICBSZXN0b3JlRm9jdXNJbkRlbG9zZXI6IDUsXG4gIFBpbmc6IDZcbn07XG5jbGFzcyBDcm9zc09yaWdpbkRlbG9zZXJJdGVtIGV4dGVuZHMgRGVsb3Nlckl0ZW1CYXNlIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZGVsb3NlciwgdHJhc2FjdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlbG9zZXIgPSBkZWxvc2VyO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IHRyYXNhY3Rpb25zO1xuICB9XG4gIGJlbG9uZ3NUbyhkZWxvc2VyKSB7XG4gICAgcmV0dXJuIGRlbG9zZXIuZGVsb3NlclVJZCA9PT0gdGhpcy5fZGVsb3Nlci5kZWxvc2VyVUlkO1xuICB9XG4gIGFzeW5jIGZvY3VzQXZhaWxhYmxlKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi50aGlzLl9kZWxvc2VyLFxuICAgICAgcmVzZXQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oUmVzdG9yZUZvY3VzSW5EZWxvc2VyVHJhbnNhY3Rpb24sIGRhdGEpLnRoZW4odmFsdWUgPT4gISF2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcmVzZXRGb2N1cygpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4udGhpcy5fZGVsb3NlcixcbiAgICAgIHJlc2V0OiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oUmVzdG9yZUZvY3VzSW5EZWxvc2VyVHJhbnNhY3Rpb24sIGRhdGEpLnRoZW4odmFsdWUgPT4gISF2YWx1ZSk7XG4gIH1cbn1cbmNsYXNzIENyb3NzT3JpZ2luRGVsb3Nlckhpc3RvcnlCeVJvb3QgZXh0ZW5kcyBEZWxvc2VySGlzdG9yeUJ5Um9vdEJhc2Uge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCByb290VUlkLCB0cmFuc2FjdGlvbnMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCByb290VUlkKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gIH1cbiAgdW5zaGlmdChkZWxvc2VyKSB7XG4gICAgbGV0IGl0ZW07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oaXN0b3J5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5faGlzdG9yeVtpXS5iZWxvbmdzVG8oZGVsb3NlcikpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2hpc3RvcnlbaV07XG4gICAgICAgIHRoaXMuX2hpc3Rvcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBpdGVtID0gbmV3IENyb3NzT3JpZ2luRGVsb3Nlckl0ZW0odGhpcy5fdGFic3RlciwgZGVsb3NlciwgdGhpcy5fdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgdGhpcy5faGlzdG9yeS51bnNoaWZ0KGl0ZW0pO1xuICAgIHRoaXMuX2hpc3Rvcnkuc3BsaWNlKDEwLCB0aGlzLl9oaXN0b3J5Lmxlbmd0aCAtIDEwKTtcbiAgfVxuICBhc3luYyBmb2N1c0F2YWlsYWJsZSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5faGlzdG9yeSkge1xuICAgICAgaWYgKGF3YWl0IGkuZm9jdXNBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlc2V0Rm9jdXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2hpc3RvcnkpIHtcbiAgICAgIGlmIChhd2FpdCBpLnJlc2V0Rm9jdXMoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpblRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZ2V0T3duZXIsIGtub3duVGFyZ2V0cywgdmFsdWUsIHRpbWVvdXQsIHNlbnRUbywgdGFyZ2V0SWQsIHNlbmRVcCkge1xuICAgIHRoaXMuX2luUHJvZ3Jlc3MgPSB7fTtcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1NlbGZSZXNwb25kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2VudENvdW50ID0gMDtcbiAgICB0aGlzLnRhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMub3duZXIgPSBnZXRPd25lcjtcbiAgICB0aGlzLm93bmVySWQgPSBnZXRXaW5kb3dVSWQoZ2V0T3duZXIoKSk7XG4gICAgdGhpcy5pZCA9IGdldFVJZChnZXRPd25lcigpKTtcbiAgICB0aGlzLmJlZ2luRGF0YSA9IHZhbHVlO1xuICAgIHRoaXMuX2tub3duVGFyZ2V0cyA9IGtub3duVGFyZ2V0cztcbiAgICB0aGlzLl9zZW50VG8gPSBzZW50VG8gfHwge1xuICAgICAgW3RoaXMub3duZXJJZF06IHRydWVcbiAgICB9O1xuICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICB0aGlzLnNlbmRVcCA9IHNlbmRVcDtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgKGdldFByb21pc2UoZ2V0T3duZXIpKSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuICBnZXRUYXJnZXRzKGtub3duVGFyZ2V0cykge1xuICAgIHJldHVybiB0aGlzLnRhcmdldElkID09PSBfdGFyZ2V0SWRVcCA/IHRoaXMuc2VuZFVwID8ge1xuICAgICAgW190YXJnZXRJZFVwXToge1xuICAgICAgICBzZW5kOiB0aGlzLnNlbmRVcFxuICAgICAgfVxuICAgIH0gOiBudWxsIDogdGhpcy50YXJnZXRJZCA/IGtub3duVGFyZ2V0c1t0aGlzLnRhcmdldElkXSA/IHtcbiAgICAgIFt0aGlzLnRhcmdldElkXToge1xuICAgICAgICBzZW5kOiBrbm93blRhcmdldHNbdGhpcy50YXJnZXRJZF0uc2VuZFxuICAgICAgfVxuICAgIH0gOiBudWxsIDogT2JqZWN0LmtleXMoa25vd25UYXJnZXRzKS5sZW5ndGggPT09IDAgJiYgdGhpcy5zZW5kVXAgPyB7XG4gICAgICBbX3RhcmdldElkVXBdOiB7XG4gICAgICAgIHNlbmQ6IHRoaXMuc2VuZFVwXG4gICAgICB9XG4gICAgfSA6IE9iamVjdC5rZXlzKGtub3duVGFyZ2V0cykubGVuZ3RoID4gMCA/IGtub3duVGFyZ2V0cyA6IG51bGw7XG4gIH1cbiAgYmVnaW4oc2VsZlJlc3BvbnNlKSB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMuZ2V0VGFyZ2V0cyh0aGlzLl9rbm93blRhcmdldHMpO1xuICAgIGNvbnN0IHNlbnRUbyA9IHtcbiAgICAgIC4uLnRoaXMuX3NlbnRUb1xuICAgIH07XG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModGFyZ2V0cykpIHtcbiAgICAgICAgc2VudFRvW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0cmFuc2FjdGlvbjogdGhpcy5pZCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGlzUmVzcG9uc2U6IGZhbHNlLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgb3duZXI6IHRoaXMub3duZXJJZCxcbiAgICAgIHNlbnR0bzogc2VudFRvLFxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgYmVnaW5EYXRhOiB0aGlzLmJlZ2luRGF0YVxuICAgIH07XG4gICAgaWYgKHRoaXMudGFyZ2V0SWQpIHtcbiAgICAgIGRhdGEudGFyZ2V0ID0gdGhpcy50YXJnZXRJZDtcbiAgICB9XG4gICAgaWYgKHNlbGZSZXNwb25zZSkge1xuICAgICAgdGhpcy5faXNTZWxmUmVzcG9uZGluZyA9IHRydWU7XG4gICAgICBzZWxmUmVzcG9uc2UoZGF0YSkudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuX2lzU2VsZlJlc3BvbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5lbmREYXRhID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZERhdGEgfHwgdGhpcy5fc2VudENvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHRhcmdldHMpKSB7XG4gICAgICAgIGlmICghKGlkIGluIHRoaXMuX3NlbnRUbykpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kKHRhcmdldHNbaWRdLnNlbmQsIGlkLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fc2VudENvdW50ID09PSAwICYmICF0aGlzLl9pc1NlbGZSZXNwb25kaW5nKSB7XG4gICAgICB0aGlzLmVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgfVxuICBfc2VuZChzZW5kLCB0YXJnZXRJZCwgZGF0YSkge1xuICAgIGlmICh0aGlzLl9pblByb2dyZXNzW3RhcmdldElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9pblByb2dyZXNzW3RhcmdldElkXSA9IHRydWU7XG4gICAgICB0aGlzLl9zZW50Q291bnQrKztcbiAgICAgIHNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIGVuZChlcnJvcikge1xuICAgIGlmICh0aGlzLl9pc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5lbmREYXRhID09PSB1bmRlZmluZWQgJiYgZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLl9yZWplY3QpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5lbmREYXRhKTtcbiAgICB9XG4gIH1cbiAgb25SZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgZW5kRGF0YSA9IGRhdGEuZW5kRGF0YTtcbiAgICBpZiAoZW5kRGF0YSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmVuZERhdGEpIHtcbiAgICAgIHRoaXMuZW5kRGF0YSA9IGVuZERhdGE7XG4gICAgfVxuICAgIGNvbnN0IGluUHJvZ3Jlc3NJZCA9IGRhdGEudGFyZ2V0ID09PSBfdGFyZ2V0SWRVcCA/IF90YXJnZXRJZFVwIDogZGF0YS5vd25lcjtcbiAgICBpZiAodGhpcy5faW5Qcm9ncmVzc1tpblByb2dyZXNzSWRdKSB7XG4gICAgICB0aGlzLl9pblByb2dyZXNzW2luUHJvZ3Jlc3NJZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NlbnRDb3VudC0tO1xuICAgICAgaWYgKHRoaXMuZW5kRGF0YSB8fCB0aGlzLl9zZW50Q291bnQgPT09IDAgJiYgIXRoaXMuX2lzU2VsZlJlc3BvbmRpbmcpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJvb3RzdHJhcFRyYW5zYWN0aW9uIGV4dGVuZHMgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLkJvb3RzdHJhcDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1ha2VSZXNwb25zZSh0YWJzdGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZDogdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKClcbiAgICB9O1xuICB9XG59XG5jbGFzcyBGb2N1c0VsZW1lbnRUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5Gb2N1c0VsZW1lbnQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZFNlbGZSZXNwb25kKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBzaG91bGRGb3J3YXJkKHRhYnN0ZXIsIGRhdGEsIGdldE93bmVyKSB7XG4gICAgY29uc3QgZWwgPSBHZXRFbGVtZW50VHJhbnNhY3Rpb24uZmluZEVsZW1lbnQodGFic3RlciwgZ2V0T3duZXIsIGRhdGEuYmVnaW5EYXRhKTtcbiAgICByZXR1cm4gIWVsIHx8ICF0YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1ha2VSZXNwb25zZSh0YWJzdGVyLCBkYXRhLCBnZXRPd25lciwgb3duZXJJZCwgdHJhbnNhY3Rpb25zLCBmb3J3YXJkUmVzdWx0KSB7XG4gICAgY29uc3QgZWwgPSBHZXRFbGVtZW50VHJhbnNhY3Rpb24uZmluZEVsZW1lbnQodGFic3RlciwgZ2V0T3duZXIsIGRhdGEuYmVnaW5EYXRhKTtcbiAgICByZXR1cm4gISFlbCAmJiB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKGVsLCB0cnVlKSB8fCAhIShhd2FpdCBmb3J3YXJkUmVzdWx0KTtcbiAgfVxufVxuY29uc3QgQ3Jvc3NPcmlnaW5TdGF0ZXMgPSB7XG4gIEZvY3VzZWQ6IDEsXG4gIEJsdXJyZWQ6IDIsXG4gIE9ic2VydmVkOiAzLFxuICBEZWFkV2luZG93OiA0LFxuICBLZXlib2FyZE5hdmlnYXRpb246IDUsXG4gIE91dGxpbmU6IDZcbn07XG5jbGFzcyBTdGF0ZVRyYW5zYWN0aW9uIGV4dGVuZHMgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLlN0YXRlO1xuICB9XG4gIHN0YXRpYyBzaG91bGRTZWxmUmVzcG9uZCh0YWJzdGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc3RhdGUgIT09IENyb3NzT3JpZ2luU3RhdGVzLkRlYWRXaW5kb3cgJiYgZGF0YS5zdGF0ZSAhPT0gQ3Jvc3NPcmlnaW5TdGF0ZXMuS2V5Ym9hcmROYXZpZ2F0aW9uO1xuICB9XG4gIHN0YXRpYyBhc3luYyBtYWtlUmVzcG9uc2UodGFic3RlciwgZGF0YSwgZ2V0T3duZXIsIG93bmVySWQsIHRyYW5zYWN0aW9ucywgZm9yd2FyZFJlc3VsdCwgaXNTZWxmUmVzcG9uc2UpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRhLnRpbWVzdGFtcDtcbiAgICBjb25zdCBiZWdpbkRhdGEgPSBkYXRhLmJlZ2luRGF0YTtcbiAgICBpZiAodGltZXN0YW1wICYmIGJlZ2luRGF0YSkge1xuICAgICAgc3dpdGNoIChiZWdpbkRhdGEuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5Gb2N1c2VkOlxuICAgICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uLl9tYWtlRm9jdXNlZFJlc3BvbnNlKHRhYnN0ZXIsIHRpbWVzdGFtcCwgYmVnaW5EYXRhLCB0cmFuc2FjdGlvbnMsIGlzU2VsZlJlc3BvbnNlKTtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5CbHVycmVkOlxuICAgICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uLl9tYWtlQmx1cnJlZFJlc3BvbnNlKHRhYnN0ZXIsIHRpbWVzdGFtcCwgYmVnaW5EYXRhLCB0cmFuc2FjdGlvbnMuY3R4KTtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5PYnNlcnZlZDpcbiAgICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbi5fbWFrZU9ic2VydmVkUmVzcG9uc2UodGFic3RlciwgYmVnaW5EYXRhKTtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5EZWFkV2luZG93OlxuICAgICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uLl9tYWtlRGVhZFdpbmRvd1Jlc3BvbnNlKHRhYnN0ZXIsIGJlZ2luRGF0YSwgdHJhbnNhY3Rpb25zLCBmb3J3YXJkUmVzdWx0KTtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5LZXlib2FyZE5hdmlnYXRpb246XG4gICAgICAgICAgcmV0dXJuIFN0YXRlVHJhbnNhY3Rpb24uX21ha2VLZXlib2FyZE5hdmlnYXRpb25SZXNwb25zZSh0YWJzdGVyLCB0cmFuc2FjdGlvbnMuY3R4LCBiZWdpbkRhdGEuaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKTtcbiAgICAgICAgY2FzZSBDcm9zc09yaWdpblN0YXRlcy5PdXRsaW5lOlxuICAgICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uLl9tYWtlT3V0bGluZVJlc3BvbnNlKHRhYnN0ZXIsIHRyYW5zYWN0aW9ucy5jdHgsIGJlZ2luRGF0YS5vdXRsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUVsZW1lbnQodGFic3RlciwgYmVnaW5EYXRhKSB7XG4gICAgcmV0dXJuIGJlZ2luRGF0YS51aWQgPyBuZXcgQ3Jvc3NPcmlnaW5FbGVtZW50KHRhYnN0ZXIsIGJlZ2luRGF0YS51aWQsIGJlZ2luRGF0YS5vd25lclVJZCwgYmVnaW5EYXRhLmlkLCBiZWdpbkRhdGEucm9vdFVJZCwgYmVnaW5EYXRhLm9ic2VydmVkTmFtZSwgYmVnaW5EYXRhLm9ic2VydmVkRGV0YWlscykgOiBudWxsO1xuICB9XG4gIHN0YXRpYyBhc3luYyBfbWFrZUZvY3VzZWRSZXNwb25zZSh0YWJzdGVyLCB0aW1lc3RhbXAsIGJlZ2luRGF0YSwgdHJhbnNhY3Rpb25zLCBpc1NlbGZSZXNwb25zZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBTdGF0ZVRyYW5zYWN0aW9uLmNyZWF0ZUVsZW1lbnQodGFic3RlciwgYmVnaW5EYXRhKTtcbiAgICBpZiAoYmVnaW5EYXRhICYmIGJlZ2luRGF0YS5vd25lclVJZCAmJiBlbGVtZW50KSB7XG4gICAgICB0cmFuc2FjdGlvbnMuY3R4LmZvY3VzT3duZXIgPSBiZWdpbkRhdGEub3duZXJVSWQ7XG4gICAgICB0cmFuc2FjdGlvbnMuY3R4LmZvY3VzT3duZXJUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICBpZiAoIWlzU2VsZlJlc3BvbnNlICYmIGJlZ2luRGF0YS5yb290VUlkICYmIGJlZ2luRGF0YS5kZWxvc2VyVUlkKSB7XG4gICAgICAgIGNvbnN0IGRlbG9zZXJBUEkgPSB0YWJzdGVyLmRlbG9zZXI7XG4gICAgICAgIGlmIChkZWxvc2VyQVBJKSB7XG4gICAgICAgICAgY29uc3QgaGlzdG9yeSA9IERlbG9zZXJBUEkuZ2V0SGlzdG9yeShkZWxvc2VyQVBJKTtcbiAgICAgICAgICBjb25zdCBkZWxvc2VyID0ge1xuICAgICAgICAgICAgb3duZXJVSWQ6IGJlZ2luRGF0YS5vd25lclVJZCxcbiAgICAgICAgICAgIGRlbG9zZXJVSWQ6IGJlZ2luRGF0YS5kZWxvc2VyVUlkLFxuICAgICAgICAgICAgcm9vdFVJZDogYmVnaW5EYXRhLnJvb3RVSWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGhpc3RvcnlJdGVtID0gaGlzdG9yeS5tYWtlKGJlZ2luRGF0YS5yb290VUlkLCAoKSA9PiBuZXcgQ3Jvc3NPcmlnaW5EZWxvc2VySGlzdG9yeUJ5Um9vdCh0YWJzdGVyLCBkZWxvc2VyLnJvb3RVSWQsIHRyYW5zYWN0aW9ucykpO1xuICAgICAgICAgIGhpc3RvcnlJdGVtLnVuc2hpZnQoZGVsb3Nlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENyb3NzT3JpZ2luRm9jdXNlZEVsZW1lbnRTdGF0ZS5zZXRWYWwoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgdGFic3Rlci5jcm9zc09yaWdpbi5mb2N1c2VkRWxlbWVudCwgZWxlbWVudCwge1xuICAgICAgICBpc0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5OiBiZWdpbkRhdGEuaXNGb2N1c2VkUHJvZ3JhbW1hdGljYWxseVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBfbWFrZUJsdXJyZWRSZXNwb25zZSh0YWJzdGVyLCB0aW1lc3RhbXAsIGJlZ2luRGF0YSwgY29udGV4dCkge1xuICAgIGlmIChiZWdpbkRhdGEgJiYgKGJlZ2luRGF0YS5vd25lclVJZCA9PT0gY29udGV4dC5mb2N1c093bmVyIHx8IGJlZ2luRGF0YS5mb3JjZSkgJiYgKCFjb250ZXh0LmZvY3VzT3duZXJUaW1lc3RhbXAgfHwgY29udGV4dC5mb2N1c093bmVyVGltZXN0YW1wIDwgdGltZXN0YW1wKSkge1xuICAgICAgQ3Jvc3NPcmlnaW5Gb2N1c2VkRWxlbWVudFN0YXRlLnNldFZhbChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICB0YWJzdGVyLmNyb3NzT3JpZ2luLmZvY3VzZWRFbGVtZW50LCB1bmRlZmluZWQsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIF9tYWtlT2JzZXJ2ZWRSZXNwb25zZSh0YWJzdGVyLCBiZWdpbkRhdGEpIHtcbiAgICBjb25zdCBuYW1lID0gYmVnaW5EYXRhLm9ic2VydmVkTmFtZTtcbiAgICBjb25zdCBlbGVtZW50ID0gU3RhdGVUcmFuc2FjdGlvbi5jcmVhdGVFbGVtZW50KHRhYnN0ZXIsIGJlZ2luRGF0YSk7XG4gICAgaWYgKG5hbWUgJiYgZWxlbWVudCkge1xuICAgICAgQ3Jvc3NPcmlnaW5PYnNlcnZlZEVsZW1lbnRTdGF0ZS50cmlnZ2VyKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHRhYnN0ZXIuY3Jvc3NPcmlnaW4ub2JzZXJ2ZWRFbGVtZW50LCBlbGVtZW50LCB7XG4gICAgICAgIG5hbWVzOiBbbmFtZV0sXG4gICAgICAgIGRldGFpbHM6IGJlZ2luRGF0YS5vYnNlcnZlZERldGFpbHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgX21ha2VEZWFkV2luZG93UmVzcG9uc2UodGFic3RlciwgYmVnaW5EYXRhLCB0cmFuc2FjdGlvbnMsIGZvcndhcmRSZXN1bHQpIHtcbiAgICBjb25zdCBkZWFkVUlkID0gYmVnaW5EYXRhICYmIGJlZ2luRGF0YS5vd25lclVJZDtcbiAgICBpZiAoZGVhZFVJZCkge1xuICAgICAgdHJhbnNhY3Rpb25zLnJlbW92ZVRhcmdldChkZWFkVUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcndhcmRSZXN1bHQudGhlbigoKSA9PiB7XG4gICAgICBpZiAoZGVhZFVJZCA9PT0gdHJhbnNhY3Rpb25zLmN0eC5mb2N1c093bmVyKSB7XG4gICAgICAgIGNvbnN0IGRlbG9zZXJBUEkgPSB0YWJzdGVyLmRlbG9zZXI7XG4gICAgICAgIGlmIChkZWxvc2VyQVBJKSB7XG4gICAgICAgICAgRGVsb3NlckFQSS5mb3JjZVJlc3RvcmVGb2N1cyhkZWxvc2VyQVBJKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIF9tYWtlS2V5Ym9hcmROYXZpZ2F0aW9uUmVzcG9uc2UodGFic3RlciwgY29udGV4dCwgaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKSB7XG4gICAgaWYgKGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCAhPT0gdW5kZWZpbmVkICYmIHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpICE9PSBpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpIHtcbiAgICAgIGNvbnRleHQuaWdub3JlS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVVcGRhdGUgPSB0cnVlO1xuICAgICAgdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uc2V0TmF2aWdhdGluZ1dpdGhLZXlib2FyZChpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpO1xuICAgICAgY29udGV4dC5pZ25vcmVLZXlib2FyZE5hdmlnYXRpb25TdGF0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgX21ha2VPdXRsaW5lUmVzcG9uc2UodGFic3RlciwgY29udGV4dCwgcHJvcHMpIHtcbiAgICBpZiAoY29udGV4dC5vcmlnT3V0bGluZVNldHVwKSB7XG4gICAgICBjb250ZXh0Lm9yaWdPdXRsaW5lU2V0dXAuY2FsbChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICB0YWJzdGVyLm91dGxpbmUsIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIEdldEVsZW1lbnRUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5HZXRFbGVtZW50O1xuICB9XG4gIHN0YXRpYyBzaG91bGRTZWxmUmVzcG9uZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZmluZEVsZW1lbnQodGFic3RlciwgZ2V0T3duZXIsIGRhdGEpIHtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBpZiAoZGF0YSAmJiAoIWRhdGEub3duZXJJZCB8fCBkYXRhLm93bmVySWQgPT09IGdldFdpbmRvd1VJZChnZXRPd25lcigpKSkpIHtcbiAgICAgIGlmIChkYXRhLmlkKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb20uZ2V0RWxlbWVudEJ5SWQoZ2V0T3duZXIoKS5kb2N1bWVudCwgZGF0YS5pZCk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGRhdGEucm9vdElkKSB7XG4gICAgICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICAgICAgICBpZiAoIWN0eCB8fCBjdHgucm9vdC51aWQgIT09IGRhdGEucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS51aWQpIHtcbiAgICAgICAgY29uc3QgcmVmID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldE93bmVyKS5lbGVtZW50QnlVSWRbZGF0YS51aWRdO1xuICAgICAgICBlbGVtZW50ID0gcmVmICYmIHJlZi5nZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5vYnNlcnZlZE5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgZWxlbWVudCA9IHRhYnN0ZXIub2JzZXJ2ZWRFbGVtZW50LmdldEVsZW1lbnQoZGF0YS5vYnNlcnZlZE5hbWUsIGRhdGEuYWNjZXNzaWJpbGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50IHx8IG51bGw7XG4gIH1cbiAgc3RhdGljIGdldEVsZW1lbnREYXRhKHRhYnN0ZXIsIGVsZW1lbnQsIGdldE93bmVyLCBjb250ZXh0LCBvd25lclVJZCkge1xuICAgIGNvbnN0IGRlbG9zZXIgPSBEZWxvc2VyQVBJLmdldERlbG9zZXIodGFic3RlciwgZWxlbWVudCk7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICBjb25zdCBvYnNlcnZlZCA9IHRhYnN0ZXJPbkVsZW1lbnQgJiYgdGFic3Rlck9uRWxlbWVudC5vYnNlcnZlZDtcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiBnZXRFbGVtZW50VUlkKGdldE93bmVyLCBlbGVtZW50KSxcbiAgICAgIG93bmVyVUlkLFxuICAgICAgaWQ6IGVsZW1lbnQuaWQgfHwgdW5kZWZpbmVkLFxuICAgICAgcm9vdFVJZDogY3R4ID8gY3R4LnJvb3QudWlkIDogdW5kZWZpbmVkLFxuICAgICAgZGVsb3NlclVJZDogZGVsb3NlciA/IGdldERlbG9zZXJVSUQoZ2V0T3duZXIsIGNvbnRleHQsIGRlbG9zZXIpIDogdW5kZWZpbmVkLFxuICAgICAgb2JzZXJ2ZWROYW1lOiBvYnNlcnZlZCAmJiBvYnNlcnZlZC5uYW1lcyAmJiBvYnNlcnZlZC5uYW1lc1swXSxcbiAgICAgIG9ic2VydmVkRGV0YWlsczogb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWQuZGV0YWlsc1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1ha2VSZXNwb25zZSh0YWJzdGVyLCBkYXRhLCBnZXRPd25lciwgb3duZXJVSWQsIHRyYW5zYWN0aW9ucywgZm9yd2FyZFJlc3VsdCkge1xuICAgIGNvbnN0IGJlZ2luRGF0YSA9IGRhdGEuYmVnaW5EYXRhO1xuICAgIGxldCBlbGVtZW50O1xuICAgIGxldCBkYXRhT3V0O1xuICAgIGlmIChiZWdpbkRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudCA9IHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGJlZ2luRGF0YSkge1xuICAgICAgZWxlbWVudCA9IEdldEVsZW1lbnRUcmFuc2FjdGlvbi5maW5kRWxlbWVudCh0YWJzdGVyLCBnZXRPd25lciwgYmVnaW5EYXRhKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCAmJiBiZWdpbkRhdGEpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBiZWdpbkRhdGEub2JzZXJ2ZWROYW1lO1xuICAgICAgY29uc3QgdGltZW91dCA9IGRhdGEudGltZW91dDtcbiAgICAgIGNvbnN0IGFjY2Vzc2liaWxpdHkgPSBiZWdpbkRhdGEuYWNjZXNzaWJpbGl0eTtcbiAgICAgIGlmIChuYW1lICYmIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgZSA9IGF3YWl0IG5ldyAoZ2V0UHJvbWlzZShnZXRPd25lcikpKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGxldCBpc1dhaXRFbGVtZW50UmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgaXNGb3J3YXJkUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQud2FpdEVsZW1lbnQobmFtZSwgdGltZW91dCwgYWNjZXNzaWJpbGl0eSkucmVzdWx0LnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaXNXYWl0RWxlbWVudFJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZCAmJiAodmFsdWUgfHwgaXNGb3J3YXJkUmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3J3YXJkUmVzdWx0LnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaXNGb3J3YXJkUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkICYmICh2YWx1ZSB8fCBpc1dhaXRFbGVtZW50UmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZS5lbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudCA9IGUuZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgZGF0YU91dCA9IGUuY3Jvc3NPcmlnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBHZXRFbGVtZW50VHJhbnNhY3Rpb24uZ2V0RWxlbWVudERhdGEodGFic3RlciwgZWxlbWVudCwgZ2V0T3duZXIsIHRyYW5zYWN0aW9ucy5jdHgsIG93bmVyVUlkKSA6IGRhdGFPdXQ7XG4gIH1cbn1cbmNsYXNzIFJlc3RvcmVGb2N1c0luRGVsb3NlclRyYW5zYWN0aW9uIGV4dGVuZHMgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLlJlc3RvcmVGb2N1c0luRGVsb3NlcjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWFrZVJlc3BvbnNlKHRhYnN0ZXIsIGRhdGEsIGdldE93bmVyLCBvd25lcklkLCB0cmFuc2FjdGlvbnMsIGZvcndhcmRSZXN1bHQpIHtcbiAgICBjb25zdCBmb3J3YXJkUmV0ID0gYXdhaXQgZm9yd2FyZFJlc3VsdDtcbiAgICBjb25zdCBiZWdpbiA9ICFmb3J3YXJkUmV0ICYmIGRhdGEuYmVnaW5EYXRhO1xuICAgIGNvbnN0IHVpZCA9IGJlZ2luICYmIGJlZ2luLmRlbG9zZXJVSWQ7XG4gICAgY29uc3QgZGVsb3NlciA9IHVpZCAmJiB0cmFuc2FjdGlvbnMuY3R4LmRlbG9zZXJCeVVJZFt1aWRdO1xuICAgIGNvbnN0IGRlbG9zZXJBUEkgPSB0YWJzdGVyLmRlbG9zZXI7XG4gICAgaWYgKGJlZ2luICYmIGRlbG9zZXIgJiYgZGVsb3NlckFQSSkge1xuICAgICAgY29uc3QgaGlzdG9yeSA9IERlbG9zZXJBUEkuZ2V0SGlzdG9yeShkZWxvc2VyQVBJKTtcbiAgICAgIHJldHVybiBiZWdpbi5yZXNldCA/IGhpc3RvcnkucmVzZXRGb2N1cyhkZWxvc2VyKSA6IGhpc3RvcnkuZm9jdXNBdmFpbGFibGUoZGVsb3Nlcik7XG4gICAgfVxuICAgIHJldHVybiAhIWZvcndhcmRSZXQ7XG4gIH1cbn1cbmNsYXNzIFBpbmdUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5QaW5nO1xuICB9XG4gIHN0YXRpYyBzaG91bGRGb3J3YXJkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWFrZVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpblRyYW5zYWN0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGdldE93bmVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fa25vd25UYXJnZXRzID0ge307XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25zID0ge307XG4gICAgdGhpcy5faXNEZWZhdWx0U2VuZFVwID0gZmFsc2U7XG4gICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgdGhpcy5fb25NZXNzYWdlID0gZSA9PiB7XG4gICAgICBpZiAoZS5kYXRhLm93bmVyID09PSB0aGlzLl9vd25lclVJZCB8fCAhdGhpcy5fdGFic3Rlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbklkO1xuICAgICAgaWYgKCFkYXRhIHx8ICEodHJhbnNhY3Rpb25JZCA9IGRhdGEudHJhbnNhY3Rpb24pIHx8ICFkYXRhLnR5cGUgfHwgIWRhdGEudGltZXN0YW1wIHx8ICFkYXRhLm93bmVyIHx8ICFkYXRhLnNlbnR0bykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQga25vd25UYXJnZXQgPSB0aGlzLl9rbm93blRhcmdldHNbZGF0YS5vd25lcl07XG4gICAgICBpZiAoIWtub3duVGFyZ2V0ICYmIGUuc2VuZCAmJiBkYXRhLm93bmVyICE9PSB0aGlzLl9vd25lclVJZCkge1xuICAgICAgICBrbm93blRhcmdldCA9IHRoaXMuX2tub3duVGFyZ2V0c1tkYXRhLm93bmVyXSA9IHtcbiAgICAgICAgICBzZW5kOiBlLnNlbmRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChrbm93blRhcmdldCkge1xuICAgICAgICBrbm93blRhcmdldC5sYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmlzUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkXTtcbiAgICAgICAgaWYgKHQgJiYgdC50cmFuc2FjdGlvbiAmJiB0LnRyYW5zYWN0aW9uLnR5cGUgPT09IGRhdGEudHlwZSkge1xuICAgICAgICAgIHQudHJhbnNhY3Rpb24ub25SZXNwb25zZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgVHJhbnNhY3Rpb24gPSB0aGlzLl9nZXRUcmFuc2FjdGlvbkNsYXNzKGRhdGEudHlwZSk7XG4gICAgICAgIGNvbnN0IGZvcndhcmRSZXN1bHQgPSB0aGlzLmZvcndhcmRUcmFuc2FjdGlvbihkYXRhKTtcbiAgICAgICAgaWYgKFRyYW5zYWN0aW9uICYmIGUuc2VuZCkge1xuICAgICAgICAgIFRyYW5zYWN0aW9uLm1ha2VSZXNwb25zZSh0aGlzLl90YWJzdGVyLCBkYXRhLCB0aGlzLl9vd25lciwgdGhpcy5fb3duZXJVSWQsIHRoaXMsIGZvcndhcmRSZXN1bHQsIGZhbHNlKS50aGVuKHIgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogZGF0YS50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgICAgICAgICBpc1Jlc3BvbnNlOiB0cnVlLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIG93bmVyOiB0aGlzLl9vd25lclVJZCxcbiAgICAgICAgICAgICAgdGltZW91dDogZGF0YS50aW1lb3V0LFxuICAgICAgICAgICAgICBzZW50dG86IHt9LFxuICAgICAgICAgICAgICB0YXJnZXQ6IGRhdGEudGFyZ2V0ID09PSBfdGFyZ2V0SWRVcCA/IF90YXJnZXRJZFVwIDogZGF0YS5vd25lcixcbiAgICAgICAgICAgICAgZW5kRGF0YTogclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGUuc2VuZChyZXNwb25zZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uUGFnZUhpZGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9kZWFkKCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkJyb3dzZXJNZXNzYWdlID0gZSA9PiB7XG4gICAgICBpZiAoZS5zb3VyY2UgPT09IHRoaXMuX293bmVyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIGNvbnN0IHNlbmQgPSBkYXRhID0+IHtcbiAgICAgICAgaWYgKGUuc291cmNlICYmIGUuc291cmNlLnBvc3RNZXNzYWdlKSB7XG4gICAgICAgICAgZS5zb3VyY2UucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIFwiKlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX29uTWVzc2FnZSh7XG4gICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShlLmRhdGEpLFxuICAgICAgICAgIHNlbmRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogSWdub3JlICovXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl9vd25lciA9IGdldE93bmVyO1xuICAgIHRoaXMuX293bmVyVUlkID0gZ2V0V2luZG93VUlkKGdldE93bmVyKCkpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgfVxuICBzZXR1cChzZW5kVXApIHtcbiAgICBpZiAodGhpcy5pc1NldFVwKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNyb3NzT3JpZ2luIGlzIGFscmVhZHkgc2V0IHVwLlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc1NldFVwID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0U2VuZFVwKHNlbmRVcCk7XG4gICAgICB0aGlzLl9vd25lcigpLmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCB0aGlzLl9vblBhZ2VIaWRlKTtcbiAgICAgIHRoaXMuX3BpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29uTWVzc2FnZTtcbiAgfVxuICBzZXRTZW5kVXAoc2VuZFVwKSB7XG4gICAgaWYgKCF0aGlzLmlzU2V0VXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyb3NzT3JpZ2luIGlzIG5vdCBzZXQgdXAuXCIpO1xuICAgIH1cbiAgICB0aGlzLnNlbmRVcCA9IHNlbmRVcCB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3duZXIgPSB0aGlzLl9vd25lcigpO1xuICAgIGlmIChzZW5kVXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0RlZmF1bHRTZW5kVXApIHtcbiAgICAgICAgaWYgKG93bmVyLmRvY3VtZW50KSB7XG4gICAgICAgICAgdGhpcy5faXNEZWZhdWx0U2VuZFVwID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3duZXIucGFyZW50ICYmIG93bmVyLnBhcmVudCAhPT0gb3duZXIgJiYgb3duZXIucGFyZW50LnBvc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRVcCA9IChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIG93bmVyLnBhcmVudC5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShkYXRhKSwgXCIqXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3duZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Ccm93c2VyTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRGVmYXVsdFNlbmRVcCkge1xuICAgICAgb3duZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Ccm93c2VyTWVzc2FnZSk7XG4gICAgICB0aGlzLl9pc0RlZmF1bHRTZW5kVXAgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29uTWVzc2FnZTtcbiAgfVxuICBhc3luYyBkaXNwb3NlKCkge1xuICAgIGNvbnN0IG93bmVyID0gdGhpcy5fb3duZXIoKTtcbiAgICBpZiAodGhpcy5fcGluZ1RpbWVyKSB7XG4gICAgICBvd25lci5jbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVyKTtcbiAgICAgIHRoaXMuX3BpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3duZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Ccm93c2VyTWVzc2FnZSk7XG4gICAgb3duZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIHRoaXMuX29uUGFnZUhpZGUpO1xuICAgIGF3YWl0IHRoaXMuX2RlYWQoKTtcbiAgICBkZWxldGUgdGhpcy5fZGVhZFByb21pc2U7XG4gICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyh0aGlzLl90cmFuc2FjdGlvbnMpKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNhY3Rpb25zW2lkXTtcbiAgICAgIGlmICh0LnRpbWVyKSB7XG4gICAgICAgIG93bmVyLmNsZWFyVGltZW91dCh0LnRpbWVyKTtcbiAgICAgICAgZGVsZXRlIHQudGltZXI7XG4gICAgICB9XG4gICAgICB0LnRyYW5zYWN0aW9uLmVuZCgpO1xuICAgIH1cbiAgICB0aGlzLl9rbm93blRhcmdldHMgPSB7fTtcbiAgICBkZWxldGUgdGhpcy5zZW5kVXA7XG4gIH1cbiAgYmVnaW5UcmFuc2FjdGlvbihUcmFuc2FjdGlvbiwgdmFsdWUsIHRpbWVvdXQsIHNlbnRUbywgdGFyZ2V0SWQsIHdpdGhSZWplY3QpIHtcbiAgICBpZiAoIXRoaXMuX293bmVyKSB7XG4gICAgICByZXR1cm4gZ2V0UHJvbWlzZSh0aGlzLl9vd25lcikucmVqZWN0KCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX3RhYnN0ZXIsIHRoaXMuX293bmVyLCB0aGlzLl9rbm93blRhcmdldHMsIHZhbHVlLCB0aW1lb3V0LCBzZW50VG8sIHRhcmdldElkLCB0aGlzLnNlbmRVcCk7XG4gICAgbGV0IHNlbGZSZXNwb25zZTtcbiAgICBpZiAoVHJhbnNhY3Rpb24uc2hvdWxkU2VsZlJlc3BvbmQgJiYgVHJhbnNhY3Rpb24uc2hvdWxkU2VsZlJlc3BvbmQodGhpcy5fdGFic3RlciwgdmFsdWUsIHRoaXMuX293bmVyLCB0aGlzLl9vd25lclVJZCkpIHtcbiAgICAgIHNlbGZSZXNwb25zZSA9IGRhdGEgPT4ge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24ubWFrZVJlc3BvbnNlKHRoaXMuX3RhYnN0ZXIsIGRhdGEsIHRoaXMuX293bmVyLCB0aGlzLl9vd25lclVJZCwgdGhpcywgZ2V0UHJvbWlzZSh0aGlzLl9vd25lcikucmVzb2x2ZSh1bmRlZmluZWQpLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iZWdpblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0aW1lb3V0LCBzZWxmUmVzcG9uc2UsIHdpdGhSZWplY3QpO1xuICB9XG4gIHJlbW92ZVRhcmdldCh1aWQpIHtcbiAgICBkZWxldGUgdGhpcy5fa25vd25UYXJnZXRzW3VpZF07XG4gIH1cbiAgX2JlZ2luVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHRpbWVvdXQsIHNlbGZSZXNwb25zZSwgd2l0aFJlamVjdCkge1xuICAgIGNvbnN0IG93bmVyID0gdGhpcy5fb3duZXIoKTtcbiAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB0aW1lcjogb3duZXIuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB3cmFwcGVyLnRpbWVyO1xuICAgICAgICB0cmFuc2FjdGlvbi5lbmQoXCJDcm9zcyBvcmlnaW4gdHJhbnNhY3Rpb24gdGltZWQgb3V0LlwiKTtcbiAgICAgIH0sIF90cmFuc2FjdGlvblRpbWVvdXQgKyAodGltZW91dCB8fCAwKSlcbiAgICB9O1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbi5pZF0gPSB3cmFwcGVyO1xuICAgIGNvbnN0IHJldCA9IHRyYW5zYWN0aW9uLmJlZ2luKHNlbGZSZXNwb25zZSk7XG4gICAgcmV0LmNhdGNoKCgpID0+IHtcbiAgICAgIC8qKi9cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmICh3cmFwcGVyLnRpbWVyKSB7XG4gICAgICAgIG93bmVyLmNsZWFyVGltZW91dCh3cmFwcGVyLnRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24uaWRdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQudGhlbih2YWx1ZSA9PiB2YWx1ZSwgd2l0aFJlamVjdCA/IHVuZGVmaW5lZCA6ICgpID0+IHVuZGVmaW5lZCk7XG4gIH1cbiAgZm9yd2FyZFRyYW5zYWN0aW9uKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBkYXRhXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICkge1xuICAgIGNvbnN0IG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgbGV0IHRhcmdldElkID0gZGF0YS50YXJnZXQ7XG4gICAgaWYgKHRhcmdldElkID09PSB0aGlzLl9vd25lclVJZCkge1xuICAgICAgcmV0dXJuIGdldFByb21pc2Uob3duZXIpLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgVHJhbnNhY3Rpb24gPSB0aGlzLl9nZXRUcmFuc2FjdGlvbkNsYXNzKGRhdGEudHlwZSk7XG4gICAgaWYgKFRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoVHJhbnNhY3Rpb24uc2hvdWxkRm9yd2FyZCA9PT0gdW5kZWZpbmVkIHx8IFRyYW5zYWN0aW9uLnNob3VsZEZvcndhcmQodGhpcy5fdGFic3RlciwgZGF0YSwgb3duZXIsIHRoaXMuX293bmVyVUlkKSkge1xuICAgICAgICBjb25zdCBzZW50VG8gPSBkYXRhLnNlbnR0bztcbiAgICAgICAgaWYgKHRhcmdldElkID09PSBfdGFyZ2V0SWRVcCkge1xuICAgICAgICAgIHRhcmdldElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbnRUb1t0aGlzLl9vd25lclVJZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzZW50VG9bX3RhcmdldElkVXBdO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW5UcmFuc2FjdGlvbihuZXcgVHJhbnNhY3Rpb24odGhpcy5fdGFic3Rlciwgb3duZXIsIHRoaXMuX2tub3duVGFyZ2V0cywgZGF0YS5iZWdpbkRhdGEsIGRhdGEudGltZW91dCwgc2VudFRvLCB0YXJnZXRJZCwgdGhpcy5zZW5kVXApLCBkYXRhLnRpbWVvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFByb21pc2Uob3duZXIpLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldFByb21pc2Uob3duZXIpLnJlamVjdChgVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlICR7ZGF0YS50eXBlfWApO1xuICB9XG4gIF9nZXRUcmFuc2FjdGlvbkNsYXNzKHR5cGVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5Cb290c3RyYXA6XG4gICAgICAgIHJldHVybiBCb290c3RyYXBUcmFuc2FjdGlvbjtcbiAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLkZvY3VzRWxlbWVudDpcbiAgICAgICAgcmV0dXJuIEZvY3VzRWxlbWVudFRyYW5zYWN0aW9uO1xuICAgICAgY2FzZSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuU3RhdGU6XG4gICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uO1xuICAgICAgY2FzZSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuR2V0RWxlbWVudDpcbiAgICAgICAgcmV0dXJuIEdldEVsZW1lbnRUcmFuc2FjdGlvbjtcbiAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLlJlc3RvcmVGb2N1c0luRGVsb3NlcjpcbiAgICAgICAgcmV0dXJuIFJlc3RvcmVGb2N1c0luRGVsb3NlclRyYW5zYWN0aW9uO1xuICAgICAgY2FzZSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuUGluZzpcbiAgICAgICAgcmV0dXJuIFBpbmdUcmFuc2FjdGlvbjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBfZGVhZCgpIHtcbiAgICBpZiAoIXRoaXMuX2RlYWRQcm9taXNlICYmIHRoaXMuY3R4LmZvY3VzT3duZXIgPT09IHRoaXMuX293bmVyVUlkKSB7XG4gICAgICB0aGlzLl9kZWFkUHJvbWlzZSA9IHRoaXMuYmVnaW5UcmFuc2FjdGlvbihTdGF0ZVRyYW5zYWN0aW9uLCB7XG4gICAgICAgIG93bmVyVUlkOiB0aGlzLl9vd25lclVJZCxcbiAgICAgICAgc3RhdGU6IENyb3NzT3JpZ2luU3RhdGVzLkRlYWRXaW5kb3dcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVhZFByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlYWRQcm9taXNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBfcGluZygpIHtcbiAgICBpZiAodGhpcy5fcGluZ1RpbWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWFkV2luZG93cztcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRhcmdldHMgPSBPYmplY3Qua2V5cyh0aGlzLl9rbm93blRhcmdldHMpLmZpbHRlcih1aWQgPT4gbm93IC0gKHRoaXMuX2tub3duVGFyZ2V0c1t1aWRdLmxhc3QgfHwgMCkgPiBfcGluZ1RpbWVvdXQpO1xuICAgIGlmICh0aGlzLnNlbmRVcCkge1xuICAgICAgdGFyZ2V0cy5wdXNoKF90YXJnZXRJZFVwKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBnZXRQcm9taXNlKHRoaXMuX293bmVyKS5hbGwodGFyZ2V0cy5tYXAodWlkID0+IHRoaXMuYmVnaW5UcmFuc2FjdGlvbihQaW5nVHJhbnNhY3Rpb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVpZCwgdHJ1ZSkudGhlbigoKSA9PiB0cnVlLCAoKSA9PiB7XG4gICAgICAgIGlmICh1aWQgIT09IF90YXJnZXRJZFVwKSB7XG4gICAgICAgICAgaWYgKCFkZWFkV2luZG93cykge1xuICAgICAgICAgICAgZGVhZFdpbmRvd3MgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVhZFdpbmRvd3NbdWlkXSA9IHRydWU7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2tub3duVGFyZ2V0c1t1aWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIGlmIChkZWFkV2luZG93cykge1xuICAgICAgY29uc3QgZm9jdXNlZCA9IGF3YWl0IHRoaXMuYmVnaW5UcmFuc2FjdGlvbihHZXRFbGVtZW50VHJhbnNhY3Rpb24sIHVuZGVmaW5lZCk7XG4gICAgICBpZiAoIWZvY3VzZWQgJiYgdGhpcy5jdHguZm9jdXNPd25lciAmJiB0aGlzLmN0eC5mb2N1c093bmVyIGluIGRlYWRXaW5kb3dzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYmVnaW5UcmFuc2FjdGlvbihTdGF0ZVRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgb3duZXJVSWQ6IHRoaXMuX293bmVyVUlkLFxuICAgICAgICAgIHN0YXRlOiBDcm9zc09yaWdpblN0YXRlcy5CbHVycmVkLFxuICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWxvc2VyQVBJID0gdGhpcy5fdGFic3Rlci5kZWxvc2VyO1xuICAgICAgICBpZiAoZGVsb3NlckFQSSkge1xuICAgICAgICAgIERlbG9zZXJBUEkuZm9yY2VSZXN0b3JlRm9jdXMoZGVsb3NlckFQSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGluZ1RpbWVyID0gdGhpcy5fb3duZXIoKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3BpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3BpbmcoKTtcbiAgICB9LCBfcGluZ1RpbWVvdXQpO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpbkVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCB1aWQsIG93bmVySWQsIGlkLCByb290SWQsIG9ic2VydmVkTmFtZSwgb2JzZXJ2ZWREZXRhaWxzKSB7XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5yb290SWQgPSByb290SWQ7XG4gICAgdGhpcy5vYnNlcnZlZE5hbWUgPSBvYnNlcnZlZE5hbWU7XG4gICAgdGhpcy5vYnNlcnZlZERldGFpbHMgPSBvYnNlcnZlZERldGFpbHM7XG4gIH1cbiAgZm9jdXMobm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4gdGhpcy5fdGFic3Rlci5jcm9zc09yaWdpbi5mb2N1c2VkRWxlbWVudC5mb2N1cyh0aGlzLCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2spO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpbkZvY3VzZWRFbGVtZW50U3RhdGUgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgfVxuICBhc3luYyBmb2N1cyhlbGVtZW50LCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2spIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXMoe1xuICAgICAgdWlkOiBlbGVtZW50LnVpZCxcbiAgICAgIGlkOiBlbGVtZW50LmlkLFxuICAgICAgcm9vdElkOiBlbGVtZW50LnJvb3RJZCxcbiAgICAgIG93bmVySWQ6IGVsZW1lbnQub3duZXJJZCxcbiAgICAgIG9ic2VydmVkTmFtZTogZWxlbWVudC5vYnNlcnZlZE5hbWVcbiAgICB9LCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2spO1xuICB9XG4gIGFzeW5jIGZvY3VzQnlJZChlbGVtZW50SWQsIHJvb3RJZCwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzKHtcbiAgICAgIGlkOiBlbGVtZW50SWQsXG4gICAgICByb290SWRcbiAgICB9LCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2spO1xuICB9XG4gIGFzeW5jIGZvY3VzQnlPYnNlcnZlZE5hbWUob2JzZXJ2ZWROYW1lLCB0aW1lb3V0LCByb290SWQsIG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLCBub0FjY2Vzc2libGVDaGVjaykge1xuICAgIHJldHVybiB0aGlzLl9mb2N1cyh7XG4gICAgICBvYnNlcnZlZE5hbWUsXG4gICAgICByb290SWRcbiAgICB9LCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2ssIHRpbWVvdXQpO1xuICB9XG4gIGFzeW5jIF9mb2N1cyhlbGVtZW50RGF0YSwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKEZvY3VzRWxlbWVudFRyYW5zYWN0aW9uLCB7XG4gICAgICAuLi5lbGVtZW50RGF0YSxcbiAgICAgIG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLFxuICAgICAgbm9BY2Nlc3NpYmxlQ2hlY2tcbiAgICB9LCB0aW1lb3V0KS50aGVuKHZhbHVlID0+ICEhdmFsdWUpO1xuICB9XG4gIHN0YXRpYyBzZXRWYWwoaW5zdGFuY2UsIHZhbCwgZGV0YWlsKSB7XG4gICAgaW5zdGFuY2Uuc2V0VmFsKHZhbCwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5PYnNlcnZlZEVsZW1lbnRTdGF0ZSBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIHRyYW5zYWN0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RGb2N1c0lkID0gMDtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gIH1cbiAgYXN5bmMgZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUsIGFjY2Vzc2liaWxpdHkpIHtcbiAgICByZXR1cm4gdGhpcy53YWl0RWxlbWVudChvYnNlcnZlZE5hbWUsIDAsIGFjY2Vzc2liaWxpdHkpO1xuICB9XG4gIGFzeW5jIHdhaXRFbGVtZW50KG9ic2VydmVkTmFtZSwgdGltZW91dCwgYWNjZXNzaWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihHZXRFbGVtZW50VHJhbnNhY3Rpb24sIHtcbiAgICAgIG9ic2VydmVkTmFtZSxcbiAgICAgIGFjY2Vzc2liaWxpdHlcbiAgICB9LCB0aW1lb3V0KS50aGVuKHZhbHVlID0+IHZhbHVlID8gU3RhdGVUcmFuc2FjdGlvbi5jcmVhdGVFbGVtZW50KHRoaXMuX3RhYnN0ZXIsIHZhbHVlKSA6IG51bGwpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RGb2N1cyhvYnNlcnZlZE5hbWUsIHRpbWVvdXQpIHtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSArK3RoaXMuX2xhc3RSZXF1ZXN0Rm9jdXNJZDtcbiAgICByZXR1cm4gdGhpcy53YWl0RWxlbWVudChvYnNlcnZlZE5hbWUsIHRpbWVvdXQsIE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5Gb2N1c2FibGUpLnRoZW4oZWxlbWVudCA9PiB0aGlzLl9sYXN0UmVxdWVzdEZvY3VzSWQgPT09IHJlcXVlc3RJZCAmJiBlbGVtZW50ID9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIHRoaXMuX3RhYnN0ZXIuY3Jvc3NPcmlnaW4uZm9jdXNlZEVsZW1lbnQuZm9jdXMoZWxlbWVudCwgdHJ1ZSkgOiBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIHRyaWdnZXIoaW5zdGFuY2UsIGVsZW1lbnQsIGRldGFpbHMpIHtcbiAgICBpbnN0YW5jZS50cmlnZ2VyKGVsZW1lbnQsIGRldGFpbHMpO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpbkFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLl9pbml0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgICB0YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5zdWJzY3JpYmUodGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQpO1xuICAgICAgdGFic3Rlci5mb2N1c2VkRWxlbWVudC5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQuc3Vic2NyaWJlKHRoaXMuX29uT2JzZXJ2ZWQpO1xuICAgICAgaWYgKCF0aGlzLl9jdHgub3JpZ091dGxpbmVTZXR1cCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0aGlzLl9jdHgub3JpZ091dGxpbmVTZXR1cCA9IHRhYnN0ZXIub3V0bGluZS5zZXR1cDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdGFic3Rlci5vdXRsaW5lLnNldHVwID0gdGhpcy5fb3V0bGluZVNldHVwO1xuICAgICAgfVxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oQm9vdHN0cmFwVHJhbnNhY3Rpb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIF90YXJnZXRJZFVwKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YSAmJiB0aGlzLl90YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSAhPT0gZGF0YS5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpIHtcbiAgICAgICAgICB0aGlzLl9jdHguaWdub3JlS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3RhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLnNldE5hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoZGF0YS5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpO1xuICAgICAgICAgIHRoaXMuX2N0eC5pZ25vcmVLZXlib2FyZE5hdmlnYXRpb25TdGF0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX29uS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVDaGFuZ2VkID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jdHguaWdub3JlS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICAgIHN0YXRlOiBDcm9zc09yaWdpblN0YXRlcy5LZXlib2FyZE5hdmlnYXRpb24sXG4gICAgICAgICAgb3duZXJVSWQ6IGdldFdpbmRvd1VJZCh0aGlzLl93aW4oKSksXG4gICAgICAgICAgaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uRm9jdXMgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgY29uc3Qgb3duZXJVSWQgPSBnZXRXaW5kb3dVSWQod2luKTtcbiAgICAgIGlmICh0aGlzLl9ibHVyVGltZXIpIHtcbiAgICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9ibHVyVGltZXIpO1xuICAgICAgICB0aGlzLl9ibHVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihTdGF0ZVRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgLi4uR2V0RWxlbWVudFRyYW5zYWN0aW9uLmdldEVsZW1lbnREYXRhKHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQsIHRoaXMuX3dpbiwgdGhpcy5fY3R4LCBvd25lclVJZCksXG4gICAgICAgICAgc3RhdGU6IENyb3NzT3JpZ2luU3RhdGVzLkZvY3VzZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ibHVyVGltZXIgPSB3aW4uc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYmx1clRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0aGlzLl9jdHguZm9jdXNPd25lciAmJiB0aGlzLl9jdHguZm9jdXNPd25lciA9PT0gb3duZXJVSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKEdldEVsZW1lbnRUcmFuc2FjdGlvbiwgdW5kZWZpbmVkKS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLl9jdHguZm9jdXNPd25lciA9PT0gb3duZXJVSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihTdGF0ZVRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICBvd25lclVJZCxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBDcm9zc09yaWdpblN0YXRlcy5CbHVycmVkLFxuICAgICAgICAgICAgICAgICAgZm9yY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbk9ic2VydmVkID0gKGVsZW1lbnQsIGRldGFpbHMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGQgPSBHZXRFbGVtZW50VHJhbnNhY3Rpb24uZ2V0RWxlbWVudERhdGEodGhpcy5fdGFic3RlciwgZWxlbWVudCwgdGhpcy5fd2luLCB0aGlzLl9jdHgsIGdldFdpbmRvd1VJZCh0aGlzLl93aW4oKSkpO1xuICAgICAgZC5zdGF0ZSA9IENyb3NzT3JpZ2luU3RhdGVzLk9ic2VydmVkO1xuICAgICAgZC5vYnNlcnZlZE5hbWUgPSAoX2EgPSBkZXRhaWxzLm5hbWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICBkLm9ic2VydmVkRGV0YWlscyA9IGRldGFpbHMuZGV0YWlscztcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKFN0YXRlVHJhbnNhY3Rpb24sIGQpO1xuICAgIH07XG4gICAgdGhpcy5fb3V0bGluZVNldHVwID0gcHJvcHMgPT4ge1xuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICBzdGF0ZTogQ3Jvc3NPcmlnaW5TdGF0ZXMuT3V0bGluZSxcbiAgICAgICAgb3duZXJVSWQ6IGdldFdpbmRvd1VJZCh0aGlzLl93aW4oKSksXG4gICAgICAgIG91dGxpbmU6IHByb3BzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3dpbiA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgIGlnbm9yZUtleWJvYXJkTmF2aWdhdGlvblN0YXRlVXBkYXRlOiBmYWxzZSxcbiAgICAgIGRlbG9zZXJCeVVJZDoge31cbiAgICB9O1xuICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IG5ldyBDcm9zc09yaWdpblRyYW5zYWN0aW9ucyh0YWJzdGVyLCB0aGlzLl93aW4sIHRoaXMuX2N0eCk7XG4gICAgdGhpcy5mb2N1c2VkRWxlbWVudCA9IG5ldyBDcm9zc09yaWdpbkZvY3VzZWRFbGVtZW50U3RhdGUodGhpcy5fdHJhbnNhY3Rpb25zKTtcbiAgICB0aGlzLm9ic2VydmVkRWxlbWVudCA9IG5ldyBDcm9zc09yaWdpbk9ic2VydmVkRWxlbWVudFN0YXRlKHRhYnN0ZXIsIHRoaXMuX3RyYW5zYWN0aW9ucyk7XG4gIH1cbiAgc2V0dXAoc2VuZFVwKSB7XG4gICAgaWYgKHRoaXMuaXNTZXRVcCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLnNldFNlbmRVcChzZW5kVXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90YWJzdGVyLnF1ZXVlSW5pdCh0aGlzLl9pbml0KTtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbnMuc2V0dXAoc2VuZFVwKTtcbiAgICB9XG4gIH1cbiAgaXNTZXRVcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLmlzU2V0VXA7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24udW5zdWJzY3JpYmUodGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQpO1xuICAgIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgKF9hID0gdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnN1YnNjcmliZSh0aGlzLl9vbk9ic2VydmVkKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMuZGlzcG9zZSgpO1xuICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgIHRoaXMub2JzZXJ2ZWRFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9jdHguZGVsb3NlckJ5VUlkID0ge307XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERlbG9zZXJVSUQoZ2V0V2luZG93LCBjb250ZXh0LCBkZWxvc2VyKSB7XG4gIGNvbnN0IGRlbG9zZXJFbGVtZW50ID0gZGVsb3Nlci5nZXRFbGVtZW50KCk7XG4gIGlmIChkZWxvc2VyRWxlbWVudCkge1xuICAgIGNvbnN0IHVpZCA9IGdldEVsZW1lbnRVSWQoZ2V0V2luZG93LCBkZWxvc2VyRWxlbWVudCk7XG4gICAgaWYgKCFjb250ZXh0LmRlbG9zZXJCeVVJZFt1aWRdKSB7XG4gICAgICBjb250ZXh0LmRlbG9zZXJCeVVJZFt1aWRdID0gZGVsb3NlcjtcbiAgICB9XG4gICAgcmV0dXJuIHVpZDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBGb2N1c2FibGVBUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyKSB7XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICAvKiovXG4gIH1cbiAgZ2V0UHJvcHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHRhYnN0ZXJPbkVsZW1lbnQgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpO1xuICAgIHJldHVybiB0YWJzdGVyT25FbGVtZW50ICYmIHRhYnN0ZXJPbkVsZW1lbnQuZm9jdXNhYmxlIHx8IHt9O1xuICB9XG4gIGlzRm9jdXNhYmxlKGVsLCBpbmNsdWRlUHJvZ3JhbW1hdGljYWxseUZvY3VzYWJsZSwgbm9WaXNpYmxlQ2hlY2ssIG5vQWNjZXNzaWJsZUNoZWNrKSB7XG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcihlbCwgRk9DVVNBQkxFX1NFTEVDVE9SKSAmJiAoaW5jbHVkZVByb2dyYW1tYXRpY2FsbHlGb2N1c2FibGUgfHwgZWwudGFiSW5kZXggIT09IC0xKSkge1xuICAgICAgcmV0dXJuIChub1Zpc2libGVDaGVjayB8fCB0aGlzLmlzVmlzaWJsZShlbCkpICYmIChub0FjY2Vzc2libGVDaGVjayB8fCB0aGlzLmlzQWNjZXNzaWJsZShlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNWaXNpYmxlKGVsKSB7XG4gICAgaWYgKCFlbC5vd25lckRvY3VtZW50IHx8IGVsLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGF5Tm9uZShlbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IGVsLm93bmVyRG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAocmVjdC53aWR0aCA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgLy8gVGhpcyBtaWdodCBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBvdXIgPGJvZHk+IGlzIGluIGhpZGRlbiA8aWZyYW1lPi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNBY2Nlc3NpYmxlKGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAobGV0IGUgPSBlbDsgZTsgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGUpKSB7XG4gICAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlKTtcbiAgICAgIGlmICh0aGlzLl9pc0hpZGRlbihlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBpZ25vcmVEaXNhYmxlZCA9IChfYSA9IHRhYnN0ZXJPbkVsZW1lbnQgPT09IG51bGwgfHwgdGFic3Rlck9uRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFic3Rlck9uRWxlbWVudC5mb2N1c2FibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZ25vcmVBcmlhRGlzYWJsZWQ7XG4gICAgICBpZiAoIWlnbm9yZURpc2FibGVkICYmIHRoaXMuX2lzRGlzYWJsZWQoZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfaXNEaXNhYmxlZChlbCkge1xuICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgfVxuICBfaXNIaWRkZW4oZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXR0clZhbCA9IGVsLmdldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgIGlmIChhdHRyVmFsICYmIGF0dHJWYWwudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuX3RhYnN0ZXIubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBdWdtZW50ZWQoZWwpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZpbmRGaXJzdChvcHRpb25zLCBvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudCh7XG4gICAgICAuLi5vcHRpb25zXG4gICAgfSwgb3V0KTtcbiAgfVxuICBmaW5kTGFzdChvcHRpb25zLCBvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudCh7XG4gICAgICBpc0JhY2t3YXJkOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sIG91dCk7XG4gIH1cbiAgZmluZE5leHQob3B0aW9ucywgb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnQoe1xuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sIG91dCk7XG4gIH1cbiAgZmluZFByZXYob3B0aW9ucywgb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnQoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGlzQmFja3dhcmQ6IHRydWVcbiAgICB9LCBvdXQpO1xuICB9XG4gIGZpbmREZWZhdWx0KG9wdGlvbnMsIG91dCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50KHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY2NlcHRDb25kaXRpb246IGVsID0+IHRoaXMuaXNGb2N1c2FibGUoZWwsIG9wdGlvbnMuaW5jbHVkZVByb2dyYW1tYXRpY2FsbHlGb2N1c2FibGUpICYmICEhdGhpcy5nZXRQcm9wcyhlbCkuaXNEZWZhdWx0XG4gICAgfSwgb3V0KSB8fCBudWxsO1xuICB9XG4gIGZpbmRBbGwob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9maW5kRWxlbWVudHModHJ1ZSwgb3B0aW9ucykgfHwgW107XG4gIH1cbiAgZmluZEVsZW1lbnQob3B0aW9ucywgb3V0KSB7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLl9maW5kRWxlbWVudHMoZmFsc2UsIG9wdGlvbnMsIG91dCk7XG4gICAgcmV0dXJuIGZvdW5kID8gZm91bmRbMF0gOiBmb3VuZDtcbiAgfVxuICBfZmluZEVsZW1lbnRzKGlzRmluZEFsbCwgb3B0aW9ucywgb3V0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsLFxuICAgICAgaW5jbHVkZVByb2dyYW1tYXRpY2FsbHlGb2N1c2FibGUsXG4gICAgICB1c2VBY3RpdmVNb2RhbGl6ZXIsXG4gICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5LFxuICAgICAgbW9kYWxpemVySWQsXG4gICAgICBpc0JhY2t3YXJkLFxuICAgICAgb25FbGVtZW50XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFvdXQpIHtcbiAgICAgIG91dCA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGxldCB7XG4gICAgICBhY2NlcHRDb25kaXRpb25cbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBoYXNDdXN0b21Db25kaXRpb24gPSAhIWFjY2VwdENvbmRpdGlvbjtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYWNjZXB0Q29uZGl0aW9uKSB7XG4gICAgICBhY2NlcHRDb25kaXRpb24gPSBlbCA9PiB0aGlzLmlzRm9jdXNhYmxlKGVsLCBpbmNsdWRlUHJvZ3JhbW1hdGljYWxseUZvY3VzYWJsZSwgZmFsc2UsIGlnbm9yZUFjY2Vzc2liaWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBhY2NlcHRFbGVtZW50U3RhdGUgPSB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBtb2RhbGl6ZXJVc2VySWQ6IG1vZGFsaXplcklkID09PSB1bmRlZmluZWQgJiYgdXNlQWN0aXZlTW9kYWxpemVyID8gKF9hID0gdGhpcy5fdGFic3Rlci5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVJZCA6IG1vZGFsaXplcklkIHx8ICgoX2MgPSAoX2IgPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGNvbnRhaW5lcikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VySWQpLFxuICAgICAgZnJvbTogY3VycmVudEVsZW1lbnQgfHwgY29udGFpbmVyLFxuICAgICAgaXNCYWNrd2FyZCxcbiAgICAgIGlzRmluZEFsbCxcbiAgICAgIGFjY2VwdENvbmRpdGlvbixcbiAgICAgIGhhc0N1c3RvbUNvbmRpdGlvbixcbiAgICAgIGluY2x1ZGVQcm9ncmFtbWF0aWNhbGx5Rm9jdXNhYmxlLFxuICAgICAgaWdub3JlQWNjZXNzaWJpbGl0eSxcbiAgICAgIGNhY2hlZEdyb3VwcGVyczoge30sXG4gICAgICBjYWNoZWRSYWRpb0dyb3Vwczoge31cbiAgICB9O1xuICAgIGNvbnN0IHdhbGtlciA9IGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKGNvbnRhaW5lci5vd25lckRvY3VtZW50LCBjb250YWluZXIsIG5vZGUgPT4gdGhpcy5fYWNjZXB0RWxlbWVudChub2RlLCBhY2NlcHRFbGVtZW50U3RhdGUpKTtcbiAgICBpZiAoIXdhbGtlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByZXBhcmVGb3JOZXh0RWxlbWVudCA9IHNob3VsZENvbnRpbnVlSWZOb3RGb3VuZCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZm91bmRFbGVtZW50ID0gKF9hID0gYWNjZXB0RWxlbWVudFN0YXRlLmZvdW5kRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYWNjZXB0RWxlbWVudFN0YXRlLmZvdW5kQmFja3dhcmQ7XG4gICAgICBpZiAoZm91bmRFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZm91bmRFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpbmRBbGwpIHtcbiAgICAgICAgaWYgKGZvdW5kRWxlbWVudCkge1xuICAgICAgICAgIGFjY2VwdEVsZW1lbnRTdGF0ZS5mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGRlbGV0ZSBhY2NlcHRFbGVtZW50U3RhdGUuZm91bmRFbGVtZW50O1xuICAgICAgICAgIGRlbGV0ZSBhY2NlcHRFbGVtZW50U3RhdGUuZm91bmRCYWNrd2FyZDtcbiAgICAgICAgICBkZWxldGUgYWNjZXB0RWxlbWVudFN0YXRlLmZyb21DdHg7XG4gICAgICAgICAgYWNjZXB0RWxlbWVudFN0YXRlLmZyb20gPSBmb3VuZEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKG9uRWxlbWVudCAmJiAhb25FbGVtZW50KGZvdW5kRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKGZvdW5kRWxlbWVudCB8fCBzaG91bGRDb250aW51ZUlmTm90Rm91bmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kRWxlbWVudCAmJiBvdXQpIHtcbiAgICAgICAgICBvdXQudW5jb250cm9sbGVkID0gKF9iID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBmb3VuZEVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudW5jb250cm9sbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIShzaG91bGRDb250aW51ZUlmTm90Rm91bmQgJiYgIWZvdW5kRWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XG4gICAgICBvdXQub3V0T2ZET01PcmRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdXJyZW50RWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGNvbnRhaW5lciwgY3VycmVudEVsZW1lbnQpKSB7XG4gICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBjdXJyZW50RWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IGdldExhc3RDaGlsZCQyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoIWxhc3RDaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hY2NlcHRFbGVtZW50KGxhc3RDaGlsZCwgYWNjZXB0RWxlbWVudFN0YXRlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUICYmICFwcmVwYXJlRm9yTmV4dEVsZW1lbnQodHJ1ZSkpIHtcbiAgICAgICAgaWYgKGFjY2VwdEVsZW1lbnRTdGF0ZS5za2lwcGVkRm9jdXNhYmxlKSB7XG4gICAgICAgICAgb3V0Lm91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGxhc3RDaGlsZDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgd2Fsa2VyLnByZXZpb3VzTm9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocHJlcGFyZUZvck5leHRFbGVtZW50KCkpO1xuICAgIGlmIChhY2NlcHRFbGVtZW50U3RhdGUuc2tpcHBlZEZvY3VzYWJsZSkge1xuICAgICAgb3V0Lm91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoID8gZWxlbWVudHMgOiBudWxsO1xuICB9XG4gIF9hY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKHN0YXRlLmZvdW5kKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cbiAgICBjb25zdCBmb3VuZEJhY2t3YXJkID0gc3RhdGUuZm91bmRCYWNrd2FyZDtcbiAgICBpZiAoZm91bmRCYWNrd2FyZCAmJiAoZWxlbWVudCA9PT0gZm91bmRCYWNrd2FyZCB8fCAhZG9tLm5vZGVDb250YWlucyhmb3VuZEJhY2t3YXJkLCBlbGVtZW50KSkpIHtcbiAgICAgIHN0YXRlLmZvdW5kID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZvdW5kRWxlbWVudCA9IGZvdW5kQmFja3dhcmQ7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBzdGF0ZS5jb250YWluZXI7XG4gICAgaWYgKGVsZW1lbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICAgIGlmICghZG9tLm5vZGVDb250YWlucyhjb250YWluZXIsIGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgIH1cbiAgICBpZiAoZ2V0RHVtbXlJbnB1dENvbnRhaW5lcihlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICB9XG4gICAgaWYgKGRvbS5ub2RlQ29udGFpbnMoc3RhdGUucmVqZWN0RWxlbWVudHNGcm9tLCBlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gc3RhdGUuY3VycmVudEN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgLy8gVGFic3RlciBpcyBvcHQgaW4sIGlmIGl0IGlzIG5vdCBtYW5hZ2VkLCBkb24ndCB0cnkgYW5kIGdldCBkbyBhbnl0aGluZyBzcGVjaWFsXG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkSWdub3JlRm9jdXMoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9XG4gICAgLy8gV2UgYXNzdW1lIGlmcmFtZXMgYXJlIGZvY3VzYWJsZSBiZWNhdXNlIG5hdGl2ZSB0YWIgYmVoYXZpb3VyIHdvdWxkIHRhYiBpbnNpZGUuXG4gICAgLy8gQnV0IHdlIGRvIGl0IG9ubHkgZHVyaW5nIHRoZSBzdGFuZGFyZCBzZWFyY2ggd2hlbiB0aGVyZSBpcyBubyBjdXN0b20gYWNjZXB0XG4gICAgLy8gZWxlbWVudCBjb25kaXRpb24uXG4gICAgaWYgKCFzdGF0ZS5oYXNDdXN0b21Db25kaXRpb24gJiYgKGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJRlJBTUVcIiB8fCBlbGVtZW50LnRhZ05hbWUgPT09IFwiV0VCVklFV1wiKSkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpICYmICgoX2EgPSBjdHgubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlcklkKSA9PT0gKChfYiA9IHRoaXMuX3RhYnN0ZXIubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0aXZlSWQpKSB7XG4gICAgICAgIHN0YXRlLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVqZWN0RWxlbWVudHNGcm9tID0gc3RhdGUuZm91bmRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhdGUuaWdub3JlQWNjZXNzaWJpbGl0eSAmJiAhdGhpcy5pc0FjY2Vzc2libGUoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQsIGZhbHNlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGZyb21DdHggPSBzdGF0ZS5mcm9tQ3R4O1xuICAgIGlmICghZnJvbUN0eCkge1xuICAgICAgZnJvbUN0eCA9IHN0YXRlLmZyb21DdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIHN0YXRlLmZyb20pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW92ZXIgPSBmcm9tQ3R4ID09PSBudWxsIHx8IGZyb21DdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyb21DdHgubW92ZXI7XG4gICAgbGV0IGdyb3VwcGVyID0gY3R4Lmdyb3VwcGVyO1xuICAgIGxldCBtb3ZlciA9IGN0eC5tb3ZlcjtcbiAgICByZXN1bHQgPSAoX2MgPSB0aGlzLl90YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjY2VwdEVsZW1lbnQoZWxlbWVudCwgc3RhdGUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiAoZ3JvdXBwZXIgfHwgbW92ZXIgfHwgZnJvbU1vdmVyKSkge1xuICAgICAgY29uc3QgZ3JvdXBwZXJFbGVtZW50ID0gZ3JvdXBwZXIgPT09IG51bGwgfHwgZ3JvdXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwcGVyLmdldEVsZW1lbnQoKTtcbiAgICAgIGNvbnN0IGZyb21Nb3ZlckVsZW1lbnQgPSBmcm9tTW92ZXIgPT09IG51bGwgfHwgZnJvbU1vdmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcm9tTW92ZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgbGV0IG1vdmVyRWxlbWVudCA9IG1vdmVyID09PSBudWxsIHx8IG1vdmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3Zlci5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAobW92ZXJFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZnJvbU1vdmVyRWxlbWVudCwgbW92ZXJFbGVtZW50KSAmJiBkb20ubm9kZUNvbnRhaW5zKGNvbnRhaW5lciwgZnJvbU1vdmVyRWxlbWVudCkgJiYgKCFncm91cHBlckVsZW1lbnQgfHwgIW1vdmVyIHx8IGRvbS5ub2RlQ29udGFpbnMoZnJvbU1vdmVyRWxlbWVudCwgZ3JvdXBwZXJFbGVtZW50KSkpIHtcbiAgICAgICAgbW92ZXIgPSBmcm9tTW92ZXI7XG4gICAgICAgIG1vdmVyRWxlbWVudCA9IGZyb21Nb3ZlckVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZ3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICAgIGlmIChncm91cHBlckVsZW1lbnQgPT09IGNvbnRhaW5lciB8fCAhZG9tLm5vZGVDb250YWlucyhjb250YWluZXIsIGdyb3VwcGVyRWxlbWVudCkpIHtcbiAgICAgICAgICBncm91cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICghZG9tLm5vZGVDb250YWlucyhncm91cHBlckVsZW1lbnQsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gX2FjY2VwdEVsZW1lbnQoKSBjYWxsYmFjayBpcyBjYWxsZWQgZHVyaW5nIHRoZSB0cmVlIHdhbGtpbmcuXG4gICAgICAgICAgLy8gR2l2ZW4gdGhlIHBvdGVudGlhbGl0eSBvZiB2aXJ0dWFsIHBhcmVudHMgKGRyaXZlbiBieSB0aGUgY3VzdG9tIGdldFBhcmVudCgpIGZ1bmN0aW9uKSxcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBncm91cHBlciBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnQncyBjb250ZXh0IGlzIG5vdCxcbiAgICAgICAgICAvLyBwb3J0YWxpbmcgdXMgb3V0IG9mIHRoZSBET00gb3JkZXIuXG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1vdmVyRWxlbWVudCkge1xuICAgICAgICBpZiAoIWRvbS5ub2RlQ29udGFpbnMoY29udGFpbmVyLCBtb3ZlckVsZW1lbnQpKSB7XG4gICAgICAgICAgbW92ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRvbS5ub2RlQ29udGFpbnMobW92ZXJFbGVtZW50LCBlbGVtZW50KSkge1xuICAgICAgICAgIC8vIF9hY2NlcHRFbGVtZW50KCkgY2FsbGJhY2sgaXMgY2FsbGVkIGR1cmluZyB0aGUgdHJlZSB3YWxraW5nLlxuICAgICAgICAgIC8vIEdpdmVuIHRoZSBwb3RlbnRpYWxpdHkgb2YgdmlydHVhbCBwYXJlbnRzIChkcml2ZW4gYnkgdGhlIGN1c3RvbSBnZXRQYXJlbnQoKSBmdW5jdGlvbiksXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgbW92ZXIgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50J3MgY29udGV4dCBpcyBub3QsXG4gICAgICAgICAgLy8gcG9ydGFsaW5nIHVzIG91dCBvZiB0aGUgRE9NIG9yZGVyLlxuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChncm91cHBlciAmJiBtb3Zlcikge1xuICAgICAgICBpZiAobW92ZXJFbGVtZW50ICYmIGdyb3VwcGVyRWxlbWVudCAmJiAhZG9tLm5vZGVDb250YWlucyhncm91cHBlckVsZW1lbnQsIG1vdmVyRWxlbWVudCkpIHtcbiAgICAgICAgICBtb3ZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGdyb3VwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IGdyb3VwcGVyLmFjY2VwdEVsZW1lbnQoZWxlbWVudCwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdmVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG1vdmVyLmFjY2VwdEVsZW1lbnQoZWxlbWVudCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IHN0YXRlLmFjY2VwdENvbmRpdGlvbihlbGVtZW50KSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQICYmIHRoaXMuaXNGb2N1c2FibGUoZWxlbWVudCwgZmFsc2UsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgJiYgIXN0YXRlLmZvdW5kKSB7XG4gICAgICBpZiAoIXN0YXRlLmlzRmluZEFsbCAmJiBpc1JhZGlvKGVsZW1lbnQpICYmICFlbGVtZW50LmNoZWNrZWQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBtaW1pYyB0aGUgYnJvd3NlcidzIGJlaGF2aW91ciB0byBza2lwIHVuY2hlY2tlZCByYWRpbyBidXR0b25zLlxuICAgICAgICBjb25zdCByYWRpb0dyb3VwTmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgbGV0IHJhZGlvR3JvdXAgPSBzdGF0ZS5jYWNoZWRSYWRpb0dyb3Vwc1tyYWRpb0dyb3VwTmFtZV07XG4gICAgICAgIGlmICghcmFkaW9Hcm91cCkge1xuICAgICAgICAgIHJhZGlvR3JvdXAgPSBnZXRSYWRpb0J1dHRvbkdyb3VwKGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChyYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jYWNoZWRSYWRpb0dyb3Vwc1tyYWRpb0dyb3VwTmFtZV0gPSByYWRpb0dyb3VwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHJhZGlvR3JvdXAgPT09IG51bGwgfHwgcmFkaW9Hcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFkaW9Hcm91cC5jaGVja2VkKSAmJiByYWRpb0dyb3VwLmNoZWNrZWQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBDdXJyZW50bHkgZm91bmQgZWxlbWVudCBpcyBhIHJhZGlvIGJ1dHRvbiBpbiBhIGdyb3VwIHRoYXQgaGFzIGFub3RoZXIgcmFkaW8gYnV0dG9uIGNoZWNrZWQuXG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0JhY2t3YXJkKSB7XG4gICAgICAgIC8vIFdoZW4gVHJlZVdhbGtlciBnb2VzIGJhY2t3YXJkcywgaXQgdmlzaXRzIHRoZSBjb250YWluZXIgZmlyc3QsXG4gICAgICAgIC8vIHRoZW4gaXQgZ29lcyBpbnNpZGUuIFNvLCBpZiB0aGUgY29udGFpbmVyIGlzIGFjY2VwdGVkLCB3ZSByZW1lbWJlciBpdCxcbiAgICAgICAgLy8gYnV0IGFsbG93aW5nIHRoZSBUcmVlV2Fsa2VyIHRvIGNoZWNrIGluc2lkZS5cbiAgICAgICAgc3RhdGUuZm91bmRCYWNrd2FyZCA9IGVsZW1lbnQ7XG4gICAgICAgIHJlc3VsdCA9IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5mb3VuZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmZvdW5kRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgS2V5cyA9IHtcbiAgVGFiOiBcIlRhYlwiLFxuICBFbnRlcjogXCJFbnRlclwiLFxuICBFc2NhcGU6IFwiRXNjYXBlXCIsXG4gIFBhZ2VVcDogXCJQYWdlVXBcIixcbiAgUGFnZURvd246IFwiUGFnZURvd25cIixcbiAgRW5kOiBcIkVuZFwiLFxuICBIb21lOiBcIkhvbWVcIixcbiAgQXJyb3dMZWZ0OiBcIkFycm93TGVmdFwiLFxuICBBcnJvd1VwOiBcIkFycm93VXBcIixcbiAgQXJyb3dSaWdodDogXCJBcnJvd1JpZ2h0XCIsXG4gIEFycm93RG93bjogXCJBcnJvd0Rvd25cIlxufTtcblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5jb250cm9sbGVkQ29tcGxldGVseUNvbnRhaW5lcih0YWJzdGVyLCBlbGVtZW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZ2V0UGFyZW50ID0gdGFic3Rlci5nZXRQYXJlbnQ7XG4gIGxldCBlbCA9IGVsZW1lbnQ7XG4gIGRvIHtcbiAgICBjb25zdCB1bmNvbnRyb2xsZWRPbkVsZW1lbnQgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuY29udHJvbGxlZDtcbiAgICBpZiAodW5jb250cm9sbGVkT25FbGVtZW50ICYmIHRhYnN0ZXIudW5jb250cm9sbGVkLmlzVW5jb250cm9sbGVkQ29tcGxldGVseShlbCwgISF1bmNvbnRyb2xsZWRPbkVsZW1lbnQuY29tcGxldGVseSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgZWwgPSBnZXRQYXJlbnQoZWwpO1xuICB9IHdoaWxlIChlbCk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBBc3luY0ZvY3VzSW50ZW50UHJpb3JpdHlCeVNvdXJjZSA9IHtcbiAgW0FzeW5jRm9jdXNTb3VyY2VzLlJlc3RvcmVyXTogMCxcbiAgW0FzeW5jRm9jdXNTb3VyY2VzLkRlbG9zZXJdOiAxLFxuICBbQXN5bmNGb2N1c1NvdXJjZXMuRXNjYXBlR3JvdXBwZXJdOiAyXG59O1xuY2xhc3MgRm9jdXNlZEVsZW1lbnRTdGF0ZSBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGdldFdpbmRvdykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faW5pdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgICAgLy8gQWRkIHRoZXNlIGV2ZW50IGxpc3RlbmVycyBhcyBjYXB0dXJlIC0gd2Ugd2FudCBUYWJzdGVyIHRvIHJ1biBiZWZvcmUgdXNlciBldmVudCBoYW5kbGVyc1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoS0VZQk9SR19GT0NVU0lOLCB0aGlzLl9vbkZvY3VzSW4sIHRydWUpO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoS0VZQk9SR19GT0NVU09VVCwgdGhpcy5fb25Gb2N1c091dCwgdHJ1ZSk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb20uZ2V0QWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudCAhPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZEVsZW1lbnQoYWN0aXZlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZSh0aGlzLl9vbkNoYW5nZWQpO1xuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c0luID0gZSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0aGlzLl9zZXRGb2N1c2VkRWxlbWVudCh0YXJnZXQsIGUuZGV0YWlsLnJlbGF0ZWRUYXJnZXQsIGUuZGV0YWlsLmlzRm9jdXNlZFByb2dyYW1tYXRpY2FsbHkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c091dCA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZEVsZW1lbnQodW5kZWZpbmVkLCAoX2EgPSBlLmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yaWdpbmFsRXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdGhpcy5fdmFsaWRhdGVGb2N1c2VkRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgaXMgbm90IG5lZWRlZCBhbnltb3JlIGFuZCB3cml0ZSB0ZXN0cy5cbiAgICB9O1xuICAgIHRoaXMuX29uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEtleXMuVGFiIHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSB0aGlzLmdldFZhbCgpO1xuICAgICAgaWYgKCFjdXJyZW50RWxlbWVudCB8fCAhY3VycmVudEVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBjdXJyZW50RWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgICAgY29uc3QgY29udHJvbFRhYiA9IHRhYnN0ZXIuY29udHJvbFRhYjtcbiAgICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKCFjdHggfHwgY3R4Lmlnbm9yZUtleWRvd24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgIGNvbnN0IG5leHQgPSBGb2N1c2VkRWxlbWVudFN0YXRlLmZpbmROZXh0VGFiYmFibGUodGFic3RlciwgY3R4LCB1bmRlZmluZWQsIGN1cnJlbnRFbGVtZW50LCB1bmRlZmluZWQsIGlzQmFja3dhcmQsIHRydWUpO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBjdHgucm9vdC5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gbmV4dCA9PT0gbnVsbCB8fCBuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0LmVsZW1lbnQ7XG4gICAgICBjb25zdCB1bmNvbnRyb2xsZWRDb21wbGV0ZWx5Q29udGFpbmVyID0gZ2V0VW5jb250cm9sbGVkQ29tcGxldGVseUNvbnRhaW5lcih0YWJzdGVyLCBjdXJyZW50RWxlbWVudCk7XG4gICAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbmV4dFVuY29udHJvbGxlZCA9IG5leHQudW5jb250cm9sbGVkO1xuICAgICAgICBpZiAoY3R4LnVuY29udHJvbGxlZCB8fCBkb20ubm9kZUNvbnRhaW5zKG5leHRVbmNvbnRyb2xsZWQsIGN1cnJlbnRFbGVtZW50KSkge1xuICAgICAgICAgIGlmICghbmV4dC5vdXRPZkRPTU9yZGVyICYmIG5leHRVbmNvbnRyb2xsZWQgPT09IGN0eC51bmNvbnRyb2xsZWQgfHwgdW5jb250cm9sbGVkQ29tcGxldGVseUNvbnRhaW5lciAmJiAhZG9tLm5vZGVDb250YWlucyh1bmNvbnRyb2xsZWRDb21wbGV0ZWx5Q29udGFpbmVyLCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIGV2ZXJ5dGhpbmcgd2lsbCBiZSBkb25lIGJ5IHRoZSBicm93c2VyIG9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gdGhhdCBjb250cm9scyB0aGUgdW5jb250cm9sbGVkIGFyZWEuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlIGFyZSBpbiB1bmNvbnRyb2xsZWQgYXJlYS4gV2UgYWxsb3cgd2hhdGV2ZXIgY29udHJvbHMgaXQgdG8gbW92ZVxuICAgICAgICAgIC8vIGZvY3VzLCBidXQgd2UgYWRkIGEgcGhhbnRvbSBkdW1teSB0byBtYWtlIHN1cmUgdGhlIGZvY3VzIGlzIG1vdmVkXG4gICAgICAgICAgLy8gdG8gdGhlIGNvcnJlY3QgcGxhY2UgaWYgdGhlIHVuY29udHJvbGxlZCBhcmVhIGFsbG93cyBkZWZhdWx0IGFjdGlvbi5cbiAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdGhhdCBpbiB0aGUgY29udHJvbGxlZCBtb2RlLCBiZWNhdXNlIGluIHVuY29udHJvbGxlZFxuICAgICAgICAgIC8vIG1vZGUgd2UgaGF2ZSBkdW1teSBpbnB1dHMgYXJvdW5kIGV2ZXJ5dGhpbmcgdGhhdCByZWRpcmVjdHMgZm9jdXMuXG4gICAgICAgICAgRHVtbXlJbnB1dE1hbmFnZXIuYWRkUGhhbnRvbUR1bW15V2l0aFRhcmdldCh0YWJzdGVyLCBjdXJyZW50RWxlbWVudCwgaXNCYWNrd2FyZCwgbmV4dEVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dFVuY29udHJvbGxlZCAmJiB0YWJzdGVyLmZvY3VzYWJsZS5pc1Zpc2libGUobmV4dFVuY29udHJvbGxlZCkgfHwgbmV4dEVsZW1lbnQudGFnTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiB0YWJzdGVyLmZvY3VzYWJsZS5pc1Zpc2libGUobmV4dEVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gRm9yIGlmcmFtZXMgYW5kIHVuY29udHJvbGxlZCBhcmVhcyB3ZSBhbHdheXMgd2FudCB0byB1c2UgZGVmYXVsdCBhY3Rpb24gdG9cbiAgICAgICAgICAvLyBtb3ZlIGZvY3VzIGludG8uXG4gICAgICAgICAgaWYgKHJvb3RFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFRhYnN0ZXJNb3ZlRm9jdXNFdmVudCh7XG4gICAgICAgICAgICBieTogXCJyb290XCIsXG4gICAgICAgICAgICBvd25lcjogcm9vdEVsZW1lbnQsXG4gICAgICAgICAgICBuZXh0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudDogZXZlbnRcbiAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgIER1bW15SW5wdXRNYW5hZ2VyLm1vdmVXaXRoUGhhbnRvbUR1bW15KHRhYnN0ZXIsIG5leHRVbmNvbnRyb2xsZWQgIT09IG51bGwgJiYgbmV4dFVuY29udHJvbGxlZCAhPT0gdm9pZCAwID8gbmV4dFVuY29udHJvbGxlZCA6IG5leHRFbGVtZW50LCBmYWxzZSwgaXNCYWNrd2FyZCwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xUYWIgfHwgKG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dC5vdXRPZkRPTU9yZGVyKSkge1xuICAgICAgICAgIGlmIChyb290RWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICAgICAgYnk6IFwicm9vdFwiLFxuICAgICAgICAgICAgb3duZXI6IHJvb3RFbGVtZW50LFxuICAgICAgICAgICAgbmV4dDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBuYXRpdmVGb2N1cyhuZXh0RWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZENvbXBsZXRlbHlDb250YWluZXIgJiYgcm9vdEVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgICBieTogXCJyb290XCIsXG4gICAgICAgICAgb3duZXI6IHJvb3RFbGVtZW50LFxuICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgcmVsYXRlZEV2ZW50OiBldmVudFxuICAgICAgICB9KSkpIHtcbiAgICAgICAgICBjdHgucm9vdC5tb3ZlT3V0V2l0aERlZmF1bHRBY3Rpb24oaXNCYWNrd2FyZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkNoYW5nZWQgPSAoZWxlbWVudCwgZGV0YWlsKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyRm9jdXNJbkV2ZW50KGRldGFpbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IChfYSA9IHRoaXMuX2xhc3RWYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICBjb25zdCBkID0ge1xuICAgICAgICAgICAgLi4uZGV0YWlsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBsYXN0Q3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBsYXN0KTtcbiAgICAgICAgICBjb25zdCBtb2RhbGl6ZXJJZCA9IChfYiA9IGxhc3RDdHggPT09IG51bGwgfHwgbGFzdEN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdEN0eC5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VySWQ7XG4gICAgICAgICAgaWYgKG1vZGFsaXplcklkKSB7XG4gICAgICAgICAgICBkLm1vZGFsaXplcklkID0gbW9kYWxpemVySWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3QuZGlzcGF0Y2hFdmVudChuZXcgVGFic3RlckZvY3VzT3V0RXZlbnQoZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSBnZXRXaW5kb3c7XG4gICAgdGFic3Rlci5xdWV1ZUluaXQodGhpcy5faW5pdCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKEtFWUJPUkdfRk9DVVNJTiwgdGhpcy5fb25Gb2N1c0luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTT1VULCB0aGlzLl9vbkZvY3VzT3V0LCB0cnVlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKHRoaXMuX29uQ2hhbmdlZCk7XG4gICAgY29uc3QgYXN5bmNGb2N1cyA9IHRoaXMuX2FzeW5jRm9jdXM7XG4gICAgaWYgKGFzeW5jRm9jdXMpIHtcbiAgICAgIHdpbi5jbGVhclRpbWVvdXQoYXN5bmNGb2N1cy50aW1lb3V0KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9hc3luY0ZvY3VzO1xuICAgIH1cbiAgICBkZWxldGUgRm9jdXNlZEVsZW1lbnRTdGF0ZS5fbGFzdFJlc2V0RWxlbWVudDtcbiAgICBkZWxldGUgdGhpcy5fbmV4dFZhbDtcbiAgICBkZWxldGUgdGhpcy5fbGFzdFZhbDtcbiAgfVxuICBzdGF0aWMgZm9yZ2V0TWVtb3JpemVkKGluc3RhbmNlLCBwYXJlbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCB3ZWwgPSBGb2N1c2VkRWxlbWVudFN0YXRlLl9sYXN0UmVzZXRFbGVtZW50O1xuICAgIGxldCBlbCA9IHdlbCAmJiB3ZWwuZ2V0KCk7XG4gICAgaWYgKGVsICYmIGRvbS5ub2RlQ29udGFpbnMocGFyZW50LCBlbCkpIHtcbiAgICAgIGRlbGV0ZSBGb2N1c2VkRWxlbWVudFN0YXRlLl9sYXN0UmVzZXRFbGVtZW50O1xuICAgIH1cbiAgICBlbCA9IChfYiA9IChfYSA9IGluc3RhbmNlLl9uZXh0VmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCgpO1xuICAgIGlmIChlbCAmJiBkb20ubm9kZUNvbnRhaW5zKHBhcmVudCwgZWwpKSB7XG4gICAgICBkZWxldGUgaW5zdGFuY2UuX25leHRWYWw7XG4gICAgfVxuICAgIHdlbCA9IGluc3RhbmNlLl9sYXN0VmFsO1xuICAgIGVsID0gd2VsICYmIHdlbC5nZXQoKTtcbiAgICBpZiAoZWwgJiYgZG9tLm5vZGVDb250YWlucyhwYXJlbnQsIGVsKSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLl9sYXN0VmFsO1xuICAgIH1cbiAgfVxuICBnZXRGb2N1c2VkRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWwoKTtcbiAgfVxuICBnZXRMYXN0Rm9jdXNlZEVsZW1lbnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBlbCA9IChfYSA9IHRoaXMuX2xhc3RWYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICBpZiAoIWVsIHx8IGVsICYmICFkb2N1bWVudENvbnRhaW5zKGVsLm93bmVyRG9jdW1lbnQsIGVsKSkge1xuICAgICAgdGhpcy5fbGFzdFZhbCA9IGVsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgZm9jdXMoZWxlbWVudCwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrLCBwcmV2ZW50U2Nyb2xsKSB7XG4gICAgaWYgKCF0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbGVtZW50LCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgZmFsc2UsIG5vQWNjZXNzaWJsZUNoZWNrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtZW50LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb2N1c0RlZmF1bHQoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5maW5kRGVmYXVsdCh7XG4gICAgICBjb250YWluZXJcbiAgICB9KTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZm9jdXMoZWwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRGaXJzdE9yTGFzdFRhYmJhYmxlKGlzRmlyc3QsIHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHlcbiAgICB9ID0gcHJvcHM7XG4gICAgbGV0IHRvRm9jdXM7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBjb250YWluZXIpO1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0b0ZvY3VzID0gKF9hID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5maW5kTmV4dFRhYmJhYmxlKHRoaXMuX3RhYnN0ZXIsIGN0eCwgY29udGFpbmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgIWlzRmlyc3QsIGlnbm9yZUFjY2Vzc2liaWxpdHkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvRm9jdXMgJiYgIWRvbS5ub2RlQ29udGFpbnMoY29udGFpbmVyLCB0b0ZvY3VzKSkge1xuICAgICAgdG9Gb2N1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRm9jdXMgfHwgdW5kZWZpbmVkO1xuICB9XG4gIF9mb2N1c0ZpcnN0T3JMYXN0KGlzRmlyc3QsIHByb3BzKSB7XG4gICAgY29uc3QgdG9Gb2N1cyA9IHRoaXMuZ2V0Rmlyc3RPckxhc3RUYWJiYWJsZShpc0ZpcnN0LCBwcm9wcyk7XG4gICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgIHRoaXMuZm9jdXModG9Gb2N1cywgZmFsc2UsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb2N1c0ZpcnN0KHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzRmlyc3RPckxhc3QodHJ1ZSwgcHJvcHMpO1xuICB9XG4gIGZvY3VzTGFzdChwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c0ZpcnN0T3JMYXN0KGZhbHNlLCBwcm9wcyk7XG4gIH1cbiAgcmVzZXRGb2N1cyhjb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzVmlzaWJsZShjb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoY29udGFpbmVyLCB0cnVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29uc3QgcHJldlRhYkluZGV4ID0gY29udGFpbmVyLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuICAgICAgY29uc3QgcHJldkFyaWFIaWRkZW4gPSBjb250YWluZXIuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICBGb2N1c2VkRWxlbWVudFN0YXRlLl9sYXN0UmVzZXRFbGVtZW50ID0gbmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl93aW4sIGNvbnRhaW5lcik7XG4gICAgICB0aGlzLmZvY3VzKGNvbnRhaW5lciwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9zZXRPclJlbW92ZUF0dHJpYnV0ZShjb250YWluZXIsIFwidGFiaW5kZXhcIiwgcHJldlRhYkluZGV4KTtcbiAgICAgIHRoaXMuX3NldE9yUmVtb3ZlQXR0cmlidXRlKGNvbnRhaW5lciwgXCJhcmlhLWhpZGRlblwiLCBwcmV2QXJpYUhpZGRlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9jdXMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVxdWVzdEFzeW5jRm9jdXMoc291cmNlLCBjYWxsYmFjaywgZGVsYXkpIHtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl90YWJzdGVyLmdldFdpbmRvdygpO1xuICAgIGNvbnN0IGN1cnJlbnRBc3luY0ZvY3VzID0gdGhpcy5fYXN5bmNGb2N1cztcbiAgICBpZiAoY3VycmVudEFzeW5jRm9jdXMpIHtcbiAgICAgIGlmIChBc3luY0ZvY3VzSW50ZW50UHJpb3JpdHlCeVNvdXJjZVtzb3VyY2VdID4gQXN5bmNGb2N1c0ludGVudFByaW9yaXR5QnlTb3VyY2VbY3VycmVudEFzeW5jRm9jdXMuc291cmNlXSkge1xuICAgICAgICAvLyBQcmV2aW91c2x5IHJlZ2lzdGVyZWQgaW50ZW50IGhhcyBoaWdoZXIgcHJpb3JpdHkuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIE5ldyBpbnRlbnQgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgICAgIHdpbi5jbGVhclRpbWVvdXQoY3VycmVudEFzeW5jRm9jdXMudGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuX2FzeW5jRm9jdXMgPSB7XG4gICAgICBzb3VyY2UsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIHRpbWVvdXQ6IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYXN5bmNGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0sIGRlbGF5KVxuICAgIH07XG4gIH1cbiAgY2FuY2VsQXN5bmNGb2N1cyhzb3VyY2UpIHtcbiAgICBjb25zdCBhc3luY0ZvY3VzID0gdGhpcy5fYXN5bmNGb2N1cztcbiAgICBpZiAoKGFzeW5jRm9jdXMgPT09IG51bGwgfHwgYXN5bmNGb2N1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN5bmNGb2N1cy5zb3VyY2UpID09PSBzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93KCkuY2xlYXJUaW1lb3V0KGFzeW5jRm9jdXMudGltZW91dCk7XG4gICAgICB0aGlzLl9hc3luY0ZvY3VzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfc2V0T3JSZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIF9zZXRGb2N1c2VkRWxlbWVudChlbGVtZW50LCByZWxhdGVkVGFyZ2V0LCBpc0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGhpcy5fdGFic3Rlci5fbm9vcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgbGFzdFJlc2V0RWxlbWVudCA9IChfYSA9IEZvY3VzZWRFbGVtZW50U3RhdGUuX2xhc3RSZXNldEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICAgIEZvY3VzZWRFbGVtZW50U3RhdGUuX2xhc3RSZXNldEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAobGFzdFJlc2V0RWxlbWVudCA9PT0gZWxlbWVudCB8fCBzaG91bGRJZ25vcmVGb2N1cyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZXRhaWwuaXNGb2N1c2VkUHJvZ3JhbW1hdGljYWxseSA9IGlzRm9jdXNlZFByb2dyYW1tYXRpY2FsbHk7XG4gICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpO1xuICAgICAgY29uc3QgbW9kYWxpemVySWQgPSAoX2IgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXNlcklkO1xuICAgICAgaWYgKG1vZGFsaXplcklkKSB7XG4gICAgICAgIGRldGFpbC5tb2RhbGl6ZXJJZCA9IG1vZGFsaXplcklkO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0VmFsID0gdGhpcy5fbmV4dFZhbCA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQgPyBuZXcgV2Vha0hUTUxFbGVtZW50KHRoaXMuX3dpbiwgZWxlbWVudCkgOiB1bmRlZmluZWQsXG4gICAgICBkZXRhaWxcbiAgICB9O1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IHRoaXMuX3ZhbCkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVGb2N1c2VkRWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gX3ZhbGlkYXRlRm9jdXNlZEVsZW1lbnQoKSBtaWdodCBjYXVzZSB0aGUgcmVmb2N1cyB3aGljaCB3aWxsIHRyaWdnZXJcbiAgICAvLyBhbm90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi4gTWFraW5nIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgY29ycmVjdC5cbiAgICBpZiAodGhpcy5fbmV4dFZhbCA9PT0gbmV4dFZhbCkge1xuICAgICAgdGhpcy5zZXRWYWwoZWxlbWVudCwgZGV0YWlsKTtcbiAgICB9XG4gICAgdGhpcy5fbmV4dFZhbCA9IHVuZGVmaW5lZDtcbiAgfVxuICBzZXRWYWwodmFsLCBkZXRhaWwpIHtcbiAgICBzdXBlci5zZXRWYWwodmFsLCBkZXRhaWwpO1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMuX2xhc3RWYWwgPSBuZXcgV2Vha0hUTUxFbGVtZW50KHRoaXMuX3dpbiwgdmFsKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZpbmROZXh0VGFiYmFibGUodGFic3RlciwgY3R4LCBjb250YWluZXIsIGN1cnJlbnRFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50LCBpc0JhY2t3YXJkLCBpZ25vcmVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgY29uc3QgYWN0dWFsQ29udGFpbmVyID0gY29udGFpbmVyIHx8IGN0eC5yb290LmdldEVsZW1lbnQoKTtcbiAgICBpZiAoIWFjdHVhbENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gbnVsbDtcbiAgICBjb25zdCBpc1RhYmJpbmdUaW1lciA9IEZvY3VzZWRFbGVtZW50U3RhdGUuX2lzVGFiYmluZ1RpbWVyO1xuICAgIGNvbnN0IHdpbiA9IHRhYnN0ZXIuZ2V0V2luZG93KCk7XG4gICAgaWYgKGlzVGFiYmluZ1RpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KGlzVGFiYmluZ1RpbWVyKTtcbiAgICB9XG4gICAgRm9jdXNlZEVsZW1lbnRTdGF0ZS5pc1RhYmJpbmcgPSB0cnVlO1xuICAgIEZvY3VzZWRFbGVtZW50U3RhdGUuX2lzVGFiYmluZ1RpbWVyID0gd2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVsZXRlIEZvY3VzZWRFbGVtZW50U3RhdGUuX2lzVGFiYmluZ1RpbWVyO1xuICAgICAgRm9jdXNlZEVsZW1lbnRTdGF0ZS5pc1RhYmJpbmcgPSBmYWxzZTtcbiAgICB9LCAwKTtcbiAgICBjb25zdCBtb2RhbGl6ZXIgPSBjdHgubW9kYWxpemVyO1xuICAgIGNvbnN0IGdyb3VwcGVyID0gY3R4Lmdyb3VwcGVyO1xuICAgIGNvbnN0IG1vdmVyID0gY3R4Lm1vdmVyO1xuICAgIGNvbnN0IGNhbGxGaW5kTmV4dCA9IHdoYXQgPT4ge1xuICAgICAgbmV4dCA9IHdoYXQuZmluZE5leHRUYWJiYWJsZShjdXJyZW50RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgaWdub3JlQWNjZXNzaWJpbGl0eSk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnQgJiYgIShuZXh0ID09PSBudWxsIHx8IG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHQuZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IHdoYXQgIT09IG1vZGFsaXplciAmJiBkb20uZ2V0UGFyZW50RWxlbWVudCh3aGF0LmdldEVsZW1lbnQoKSk7XG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50Q3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBjdXJyZW50RWxlbWVudCwge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudDogcGFyZW50RWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChwYXJlbnRDdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY29wZUVsZW1lbnQgPSB3aGF0LmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0N1cnJlbnQgPSBpc0JhY2t3YXJkID8gY3VycmVudFNjb3BlRWxlbWVudCA6IGN1cnJlbnRTY29wZUVsZW1lbnQgJiYgZ2V0TGFzdENoaWxkJDIoY3VycmVudFNjb3BlRWxlbWVudCkgfHwgY3VycmVudFNjb3BlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChuZXdDdXJyZW50KSB7XG4gICAgICAgICAgICAgIG5leHQgPSBGb2N1c2VkRWxlbWVudFN0YXRlLmZpbmROZXh0VGFiYmFibGUodGFic3RlciwgcGFyZW50Q3R4LCBjb250YWluZXIsIG5ld0N1cnJlbnQsIHBhcmVudEVsZW1lbnQsIGlzQmFja3dhcmQsIGlnbm9yZUFjY2Vzc2liaWxpdHkpO1xuICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQub3V0T2ZET01PcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChncm91cHBlciAmJiBtb3Zlcikge1xuICAgICAgY2FsbEZpbmROZXh0KGN0eC5ncm91cHBlckJlZm9yZU1vdmVyID8gZ3JvdXBwZXIgOiBtb3Zlcik7XG4gICAgfSBlbHNlIGlmIChncm91cHBlcikge1xuICAgICAgY2FsbEZpbmROZXh0KGdyb3VwcGVyKTtcbiAgICB9IGVsc2UgaWYgKG1vdmVyKSB7XG4gICAgICBjYWxsRmluZE5leHQobW92ZXIpO1xuICAgIH0gZWxzZSBpZiAobW9kYWxpemVyKSB7XG4gICAgICBjYWxsRmluZE5leHQobW9kYWxpemVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmluZFByb3BzID0ge1xuICAgICAgICBjb250YWluZXI6IGFjdHVhbENvbnRhaW5lcixcbiAgICAgICAgY3VycmVudEVsZW1lbnQsXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQsXG4gICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRQcm9wc091dCA9IHt9O1xuICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzYWJsZVtpc0JhY2t3YXJkID8gXCJmaW5kUHJldlwiIDogXCJmaW5kTmV4dFwiXShmaW5kUHJvcHMsIGZpbmRQcm9wc091dCk7XG4gICAgICBuZXh0ID0ge1xuICAgICAgICBlbGVtZW50OiBuZXh0RWxlbWVudCxcbiAgICAgICAgb3V0T2ZET01PcmRlcjogZmluZFByb3BzT3V0Lm91dE9mRE9NT3JkZXIsXG4gICAgICAgIHVuY29udHJvbGxlZDogZmluZFByb3BzT3V0LnVuY29udHJvbGxlZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn1cbkZvY3VzZWRFbGVtZW50U3RhdGUuaXNUYWJiaW5nID0gZmFsc2U7XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEdyb3VwcGVyRHVtbXlNYW5hZ2VyIGV4dGVuZHMgRHVtbXlJbnB1dE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBncm91cHBlciwgdGFic3Rlciwgc3lzKSB7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgRHVtbXlJbnB1dE1hbmFnZXJQcmlvcml0aWVzLkdyb3VwcGVyLCBzeXMsIHRydWUpO1xuICAgIHRoaXMuX3NldEhhbmRsZXJzKChkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZWxlbWVudC5nZXQoKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZHVtbXlJbnB1dC5pbnB1dDtcbiAgICAgIGlmIChjb250YWluZXIgJiYgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBpbnB1dCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICBuZXh0ID0gKF9hID0gZ3JvdXBwZXIuZmluZE5leHRUYWJiYWJsZShyZWxhdGVkVGFyZ2V0IHx8IHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpc0JhY2t3YXJkLCB0cnVlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZW1lbnQ7XG4gICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBuZXh0ID0gKF9iID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5maW5kTmV4dFRhYmJhYmxlKHRhYnN0ZXIsIGN0eCwgdW5kZWZpbmVkLCBkdW1teUlucHV0LmlzT3V0c2lkZSA/IGlucHV0IDogZ2V0QWRqYWNlbnRFbGVtZW50KGNvbnRhaW5lciwgIWlzQmFja3dhcmQpLCB1bmRlZmluZWQsIGlzQmFja3dhcmQsIHRydWUpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5hdGl2ZUZvY3VzKG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHcm91cHBlciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgb25EaXNwb3NlLCBwcm9wcywgc3lzKSB7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgcHJvcHMpO1xuICAgIHRoaXMuX3Nob3VsZFRhYkluc2lkZSA9IGZhbHNlO1xuICAgIHRoaXMubWFrZVRhYmJhYmxlKGZhbHNlKTtcbiAgICB0aGlzLl9vbkRpc3Bvc2UgPSBvbkRpc3Bvc2U7XG4gICAgaWYgKCF0YWJzdGVyLmNvbnRyb2xUYWIpIHtcbiAgICAgIHRoaXMuZHVtbXlNYW5hZ2VyID0gbmV3IEdyb3VwcGVyRHVtbXlNYW5hZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMsIHRhYnN0ZXIsIHN5cyk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX29uRGlzcG9zZSh0aGlzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAoX2EgPSB0aGlzLmR1bW15TWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgdGhpcy5kdW1teU1hbmFnZXI7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQxKHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fZmlyc3Q7XG4gIH1cbiAgZmluZE5leHRUYWJiYWJsZShjdXJyZW50RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgaWdub3JlQWNjZXNzaWJpbGl0eSkge1xuICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGlmICghZ3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudElzRHVtbXkgPSBnZXREdW1teUlucHV0Q29udGFpbmVyKGN1cnJlbnRFbGVtZW50KSA9PT0gZ3JvdXBwZXJFbGVtZW50O1xuICAgIGlmICghdGhpcy5fc2hvdWxkVGFiSW5zaWRlICYmIGN1cnJlbnRFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZ3JvdXBwZXJFbGVtZW50LCBjdXJyZW50RWxlbWVudCkgJiYgIWN1cnJlbnRJc0R1bW15KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIG91dE9mRE9NT3JkZXI6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwcGVyRmlyc3RGb2N1c2FibGUgPSB0aGlzLmdldEZpcnN0KHRydWUpO1xuICAgIGlmICghY3VycmVudEVsZW1lbnQgfHwgIWRvbS5ub2RlQ29udGFpbnMoZ3JvdXBwZXJFbGVtZW50LCBjdXJyZW50RWxlbWVudCkgfHwgY3VycmVudElzRHVtbXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQ6IGdyb3VwcGVyRmlyc3RGb2N1c2FibGUsXG4gICAgICAgIG91dE9mRE9NT3JkZXI6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGxldCBuZXh0ID0gbnVsbDtcbiAgICBsZXQgb3V0T2ZET01PcmRlciA9IGZhbHNlO1xuICAgIGxldCB1bmNvbnRyb2xsZWQ7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFRhYkluc2lkZSAmJiBncm91cHBlckZpcnN0Rm9jdXNhYmxlKSB7XG4gICAgICBjb25zdCBmaW5kUHJvcHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZ3JvdXBwZXJFbGVtZW50LFxuICAgICAgICBjdXJyZW50RWxlbWVudCxcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCxcbiAgICAgICAgaWdub3JlQWNjZXNzaWJpbGl0eSxcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZFByb3BzT3V0ID0ge307XG4gICAgICBuZXh0ID0gdGFic3Rlci5mb2N1c2FibGVbaXNCYWNrd2FyZCA/IFwiZmluZFByZXZcIiA6IFwiZmluZE5leHRcIl0oZmluZFByb3BzLCBmaW5kUHJvcHNPdXQpO1xuICAgICAgb3V0T2ZET01PcmRlciA9ICEhZmluZFByb3BzT3V0Lm91dE9mRE9NT3JkZXI7XG4gICAgICBpZiAoIW5leHQgJiYgdGhpcy5fcHJvcHMudGFiYmFiaWxpdHkgPT09IEdyb3VwcGVyVGFiYmFiaWxpdGllcy5MaW1pdGVkVHJhcEZvY3VzKSB7XG4gICAgICAgIG5leHQgPSB0YWJzdGVyLmZvY3VzYWJsZVtpc0JhY2t3YXJkID8gXCJmaW5kTGFzdFwiIDogXCJmaW5kRmlyc3RcIl0oe1xuICAgICAgICAgIGNvbnRhaW5lcjogZ3JvdXBwZXJFbGVtZW50LFxuICAgICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0sIGZpbmRQcm9wc091dCk7XG4gICAgICAgIG91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdW5jb250cm9sbGVkID0gZmluZFByb3BzT3V0LnVuY29udHJvbGxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IG5leHQsXG4gICAgICB1bmNvbnRyb2xsZWQsXG4gICAgICBvdXRPZkRPTU9yZGVyXG4gICAgfTtcbiAgfVxuICBtYWtlVGFiYmFibGUoaXNUYWJiYWJsZSkge1xuICAgIHRoaXMuX3Nob3VsZFRhYkluc2lkZSA9IGlzVGFiYmFibGUgfHwgIXRoaXMuX3Byb3BzLnRhYmJhYmlsaXR5O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUkMSh0aGlzLl9lbGVtZW50LCAhdGhpcy5fc2hvdWxkVGFiSW5zaWRlKTtcbiAgICB9XG4gIH1cbiAgaXNBY3RpdmUobm9JZkZpcnN0SXNGb2N1c2VkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKSB8fCBudWxsO1xuICAgIGxldCBpc1BhcmVudEFjdGl2ZSA9IHRydWU7XG4gICAgZm9yIChsZXQgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpOyBlOyBlID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZSkpIHtcbiAgICAgIGNvbnN0IGcgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JvdXBwZXI7XG4gICAgICBpZiAoZykge1xuICAgICAgICBpZiAoIWcuX3Nob3VsZFRhYkluc2lkZSkge1xuICAgICAgICAgIGlzUGFyZW50QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJldCA9IGlzUGFyZW50QWN0aXZlID8gdGhpcy5fcHJvcHMudGFiYmFiaWxpdHkgPyB0aGlzLl9zaG91bGRUYWJJbnNpZGUgOiBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICBpZiAocmV0ICYmIG5vSWZGaXJzdElzRm9jdXNlZCkge1xuICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgIHJldCA9IGZvY3VzZWQgIT09IHRoaXMuZ2V0Rmlyc3QodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZ2V0Rmlyc3Qob3JDb250YWluZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZ3JvdXBwZXJFbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgbGV0IGZpcnN0O1xuICAgIGlmIChncm91cHBlckVsZW1lbnQpIHtcbiAgICAgIGlmIChvckNvbnRhaW5lciAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShncm91cHBlckVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBncm91cHBlckVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IChfYSA9IHRoaXMuX2ZpcnN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuZmluZEZpcnN0KHtcbiAgICAgICAgICBjb250YWluZXI6IGdyb3VwcGVyRWxlbWVudCxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICB0aGlzLnNldEZpcnN0KGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbiAgc2V0Rmlyc3QoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdCA9IG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fdGFic3Rlci5nZXRXaW5kb3csIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fZmlyc3Q7XG4gICAgfVxuICB9XG4gIGFjY2VwdEVsZW1lbnQoZWxlbWVudCwgc3RhdGUpIHtcbiAgICBjb25zdCBjYWNoZWRHcm91cHBlcnMgPSBzdGF0ZS5jYWNoZWRHcm91cHBlcnM7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHRoaXMuZ2V0RWxlbWVudCgpKTtcbiAgICBjb25zdCBwYXJlbnRDdHggPSBwYXJlbnRFbGVtZW50ICYmIFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgcGFyZW50RWxlbWVudCk7XG4gICAgY29uc3QgcGFyZW50Q3R4R3JvdXBwZXIgPSBwYXJlbnRDdHggPT09IG51bGwgfHwgcGFyZW50Q3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRDdHguZ3JvdXBwZXI7XG4gICAgY29uc3QgcGFyZW50R3JvdXBwZXIgPSAocGFyZW50Q3R4ID09PSBudWxsIHx8IHBhcmVudEN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Q3R4Lmdyb3VwcGVyQmVmb3JlTW92ZXIpID8gcGFyZW50Q3R4R3JvdXBwZXIgOiB1bmRlZmluZWQ7XG4gICAgbGV0IHBhcmVudEdyb3VwcGVyRWxlbWVudDtcbiAgICBjb25zdCBnZXRJc0FjdGl2ZSA9IGdyb3VwcGVyID0+IHtcbiAgICAgIGxldCBjYWNoZWQgPSBjYWNoZWRHcm91cHBlcnNbZ3JvdXBwZXIuaWRdO1xuICAgICAgbGV0IGlzQWN0aXZlO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBpc0FjdGl2ZSA9IGNhY2hlZC5pc0FjdGl2ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgY2FjaGVkID0gY2FjaGVkR3JvdXBwZXJzW2dyb3VwcGVyLmlkXSA9IHtcbiAgICAgICAgICBpc0FjdGl2ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWN0aXZlO1xuICAgIH07XG4gICAgaWYgKHBhcmVudEdyb3VwcGVyKSB7XG4gICAgICBwYXJlbnRHcm91cHBlckVsZW1lbnQgPSBwYXJlbnRHcm91cHBlci5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAoIWdldElzQWN0aXZlKHBhcmVudEdyb3VwcGVyKSAmJiBwYXJlbnRHcm91cHBlckVsZW1lbnQgJiYgc3RhdGUuY29udGFpbmVyICE9PSBwYXJlbnRHcm91cHBlckVsZW1lbnQgJiYgZG9tLm5vZGVDb250YWlucyhzdGF0ZS5jb250YWluZXIsIHBhcmVudEdyb3VwcGVyRWxlbWVudCkpIHtcbiAgICAgICAgLy8gRG8gbm90IGZhbGwgaW50byBhIGNoaWxkIGdyb3VwcGVyIG9mIGluYWN0aXZlIHBhcmVudCBncm91cHBlciBpZiBpdCdzIGluIHRoZSBzY29wZSBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNBY3RpdmUgPSBnZXRJc0FjdGl2ZSh0aGlzKTtcbiAgICBjb25zdCBncm91cHBlckVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBpZiAoZ3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICBpZiAoaXNBY3RpdmUgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGdyb3VwcGVyRWxlbWVudCA9PT0gZWxlbWVudCAmJiBwYXJlbnRDdHhHcm91cHBlcikge1xuICAgICAgICAgIGlmICghcGFyZW50R3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnRHcm91cHBlckVsZW1lbnQgPSBwYXJlbnRDdHhHcm91cHBlci5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnRHcm91cHBlckVsZW1lbnQgJiYgIWdldElzQWN0aXZlKHBhcmVudEN0eEdyb3VwcGVyKSAmJiBkb20ubm9kZUNvbnRhaW5zKHN0YXRlLmNvbnRhaW5lciwgcGFyZW50R3JvdXBwZXJFbGVtZW50KSAmJiBwYXJlbnRHcm91cHBlckVsZW1lbnQgIT09IHN0YXRlLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBwZXJFbGVtZW50ICE9PSBlbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZ3JvdXBwZXJFbGVtZW50LCBlbGVtZW50KSkge1xuICAgICAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVkR3JvdXBwZXJzW3RoaXMuaWRdO1xuICAgICAgICBsZXQgZmlyc3Q7XG4gICAgICAgIGlmIChcImZpcnN0XCIgaW4gY2FjaGVkKSB7XG4gICAgICAgICAgZmlyc3QgPSBjYWNoZWQuZmlyc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBjYWNoZWQuZmlyc3QgPSB0aGlzLmdldEZpcnN0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdCAmJiBzdGF0ZS5hY2NlcHRDb25kaXRpb24oZmlyc3QpKSB7XG4gICAgICAgICAgc3RhdGUucmVqZWN0RWxlbWVudHNGcm9tID0gZ3JvdXBwZXJFbGVtZW50O1xuICAgICAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgICAgICAgIGlmIChmaXJzdCAhPT0gc3RhdGUuZnJvbSkge1xuICAgICAgICAgICAgc3RhdGUuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUuZm91bmRFbGVtZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5jbGFzcyBHcm91cHBlckFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGdldFdpbmRvdykge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB7fTtcbiAgICB0aGlzLl9ncm91cHBlcnMgPSB7fTtcbiAgICB0aGlzLl9pbml0ID0gKCkgPT4ge1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgICAvLyBNYWtpbmcgc3VyZSBncm91cHBlcidzIG9uRm9jdXMgaXMgY2FsbGVkIGJlZm9yZSBtb2RhbGl6ZXIncyBvbkZvY3VzLlxuICAgICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5zdWJzY3JpYmVGaXJzdCh0aGlzLl9vbkZvY3VzKTtcbiAgICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb20uZ2V0QWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fb25Gb2N1cyhhY3RpdmVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIHRydWUpO1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uTW92ZUZvY3VzKTtcbiAgICB9O1xuICAgIHRoaXMuX29uR3JvdXBwZXJEaXNwb3NlID0gZ3JvdXBwZXIgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX2dyb3VwcGVyc1tncm91cHBlci5pZF07XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Nb3VzZURvd24gPSBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHdoaWxlICh0YXJnZXQgJiYgIXRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFic3Rlci5nZXRQYXJlbnQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gS2V5cy5FbnRlciAmJiBldmVudC5rZXkgIT09IEtleXMuRXNjYXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdpdmUgYSBjaGFuY2UgdG8gb3RoZXIgbGlzdGVuZXJzIHRvIGhhbmRsZSB0aGUgZXZlbnQuXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVLZXlQcmVzcyhlbGVtZW50LCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbk1vdmVGb2N1cyA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBjb25zdCBhY3Rpb24gPSAoX2EgPSBlLmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGlvbjtcbiAgICAgIGlmIChlbGVtZW50ICYmIGFjdGlvbiAhPT0gdW5kZWZpbmVkICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gR3JvdXBwZXJNb3ZlRm9jdXNBY3Rpb25zLkVudGVyKSB7XG4gICAgICAgICAgdGhpcy5fZW50ZXJHcm91cHBlcihlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lc2NhcGVHcm91cHBlcihlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gZ2V0V2luZG93O1xuICAgIHRhYnN0ZXIucXVldWVJbml0KHRoaXMuX2luaXQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5jYW5jZWxBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLkVzY2FwZUdyb3VwcGVyKTtcbiAgICB0aGlzLl9jdXJyZW50ID0ge307XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICB9XG4gICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC51bnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uTW92ZUZvY3VzKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9ncm91cHBlcnMpLmZvckVhY2goZ3JvdXBwZXJJZCA9PiB7XG4gICAgICBpZiAodGhpcy5fZ3JvdXBwZXJzW2dyb3VwcGVySWRdKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwcGVyc1tncm91cHBlcklkXS5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cHBlcnNbZ3JvdXBwZXJJZF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlR3JvdXBwZXIoZWxlbWVudCwgcHJvcHMsIHN5cykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgO1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IG5ld0dyb3VwcGVyID0gbmV3IEdyb3VwcGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHRoaXMuX29uR3JvdXBwZXJEaXNwb3NlLCBwcm9wcywgc3lzKTtcbiAgICB0aGlzLl9ncm91cHBlcnNbbmV3R3JvdXBwZXIuaWRdID0gbmV3R3JvdXBwZXI7XG4gICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgLy8gTmV3bHkgY3JlYXRlZCBncm91cHBlciBjb250YWlucyBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LCB1cGRhdGUgdGhlIHN0YXRlIG9uIHRoZSBuZXh0IHRpY2sgKHRvXG4gICAgLy8gbWFrZSBzdXJlIGFsbCBncm91cHBlcnMgYXJlIHByb2Nlc3NlZCkuXG4gICAgaWYgKGZvY3VzZWRFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZm9jdXNlZEVsZW1lbnQpICYmICF0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZVRpbWVyO1xuICAgICAgICAvLyBNYWtpbmcgc3VyZSB0aGUgZm9jdXNlZCBlbGVtZW50IGhhc24ndCBjaGFuZ2VkLlxuICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgPT09IHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnQoZm9jdXNlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0dyb3VwcGVyO1xuICB9XG4gIGZvcmdldEN1cnJlbnRHcm91cHBlcnMoKSB7XG4gICAgdGhpcy5fY3VycmVudCA9IHt9O1xuICB9XG4gIF91cGRhdGVDdXJyZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlVGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZVRpbWVyO1xuICAgIH1cbiAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICBjb25zdCBuZXdJZHMgPSB7fTtcbiAgICBmb3IgKGxldCBlbCA9IHRhYnN0ZXIuZ2V0UGFyZW50KGVsZW1lbnQpOyBlbDsgZWwgPSB0YWJzdGVyLmdldFBhcmVudChlbCkpIHtcbiAgICAgIGNvbnN0IGdyb3VwcGVyID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ncm91cHBlcjtcbiAgICAgIGlmIChncm91cHBlcikge1xuICAgICAgICBuZXdJZHNbZ3JvdXBwZXIuaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFtncm91cHBlci5pZF0gPSBncm91cHBlcjtcbiAgICAgICAgY29uc3QgaXNUYWJiYWJsZSA9IGdyb3VwcGVyLmlzQWN0aXZlKCkgfHwgZWxlbWVudCAhPT0gZWwgJiYgKCFncm91cHBlci5nZXRQcm9wcygpLmRlbGVnYXRlZCB8fCBncm91cHBlci5nZXRGaXJzdChmYWxzZSkgIT09IGVsZW1lbnQpO1xuICAgICAgICBncm91cHBlci5tYWtlVGFiYmFibGUoaXNUYWJiYWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModGhpcy5fY3VycmVudCkpIHtcbiAgICAgIGNvbnN0IGdyb3VwcGVyID0gdGhpcy5fY3VycmVudFtpZF07XG4gICAgICBpZiAoIShncm91cHBlci5pZCBpbiBuZXdJZHMpKSB7XG4gICAgICAgIGdyb3VwcGVyLm1ha2VUYWJiYWJsZShmYWxzZSk7XG4gICAgICAgIGdyb3VwcGVyLnNldEZpcnN0KHVuZGVmaW5lZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50W2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2VudGVyR3JvdXBwZXIoZWxlbWVudCwgcmVsYXRlZEV2ZW50KSB7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICBjb25zdCBncm91cHBlciA9IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguZ3JvdXBwZXIpIHx8IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgubW9kYWxpemVySW5Hcm91cHBlcik7XG4gICAgY29uc3QgZ3JvdXBwZXJFbGVtZW50ID0gZ3JvdXBwZXIgPT09IG51bGwgfHwgZ3JvdXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwcGVyLmdldEVsZW1lbnQoKTtcbiAgICBpZiAoZ3JvdXBwZXIgJiYgZ3JvdXBwZXJFbGVtZW50ICYmIChlbGVtZW50ID09PSBncm91cHBlckVsZW1lbnQgfHwgZ3JvdXBwZXIuZ2V0UHJvcHMoKS5kZWxlZ2F0ZWQgJiYgZWxlbWVudCA9PT0gZ3JvdXBwZXIuZ2V0Rmlyc3QoZmFsc2UpKSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRhYnN0ZXIuZm9jdXNhYmxlLmZpbmROZXh0KHtcbiAgICAgICAgY29udGFpbmVyOiBncm91cHBlckVsZW1lbnQsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50OiBlbGVtZW50LFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG5leHQgJiYgKCFyZWxhdGVkRXZlbnQgfHwgcmVsYXRlZEV2ZW50ICYmIGdyb3VwcGVyRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICBieTogXCJncm91cHBlclwiLFxuICAgICAgICBvd25lcjogZ3JvdXBwZXJFbGVtZW50LFxuICAgICAgICBuZXh0LFxuICAgICAgICByZWxhdGVkRXZlbnRcbiAgICAgIH0pKSkpIHtcbiAgICAgICAgaWYgKHJlbGF0ZWRFdmVudCkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGFwcGxpY2F0aW9uIGhhc24ndCBwcmV2ZW50ZWQgZGVmYXVsdCxcbiAgICAgICAgICAvLyB3ZSBjb25zaWRlciB0aGUgZXZlbnQgY29tcGxldGVseSBoYW5kbGVkLCBoZW5jZSB3ZVxuICAgICAgICAgIC8vIHByZXZlbnQgdGhlIGluaXRpYWwgZXZlbnQncyBkZWZhdWx0IGFjdGlvbiBhbmQgc3RvcFxuICAgICAgICAgIC8vIHByb3BhZ2F0aW9uLlxuICAgICAgICAgIHJlbGF0ZWRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJlbGF0ZWRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfZXNjYXBlR3JvdXBwZXIoZWxlbWVudCwgcmVsYXRlZEV2ZW50LCBmcm9tTW9kYWxpemVyKSB7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICBsZXQgZ3JvdXBwZXIgPSAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lmdyb3VwcGVyKSB8fCAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vZGFsaXplckluR3JvdXBwZXIpO1xuICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IGdyb3VwcGVyID09PSBudWxsIHx8IGdyb3VwcGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cHBlci5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGdyb3VwcGVyICYmIGdyb3VwcGVyRWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGdyb3VwcGVyRWxlbWVudCwgZWxlbWVudCkpIHtcbiAgICAgIGxldCBuZXh0O1xuICAgICAgaWYgKGVsZW1lbnQgIT09IGdyb3VwcGVyRWxlbWVudCB8fCBmcm9tTW9kYWxpemVyKSB7XG4gICAgICAgIG5leHQgPSBncm91cHBlci5nZXRGaXJzdCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChncm91cHBlckVsZW1lbnQpO1xuICAgICAgICBjb25zdCBwYXJlbnRDdHggPSBwYXJlbnRFbGVtZW50ID8gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBwYXJlbnRFbGVtZW50KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZ3JvdXBwZXIgPSBwYXJlbnRDdHggPT09IG51bGwgfHwgcGFyZW50Q3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRDdHguZ3JvdXBwZXI7XG4gICAgICAgIG5leHQgPSBncm91cHBlciA9PT0gbnVsbCB8fCBncm91cHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBwZXIuZ2V0Rmlyc3QodHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobmV4dCAmJiAoIXJlbGF0ZWRFdmVudCB8fCByZWxhdGVkRXZlbnQgJiYgZ3JvdXBwZXJFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFRhYnN0ZXJNb3ZlRm9jdXNFdmVudCh7XG4gICAgICAgIGJ5OiBcImdyb3VwcGVyXCIsXG4gICAgICAgIG93bmVyOiBncm91cHBlckVsZW1lbnQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIHJlbGF0ZWRFdmVudFxuICAgICAgfSkpKSkge1xuICAgICAgICBpZiAoZ3JvdXBwZXIpIHtcbiAgICAgICAgICBncm91cHBlci5tYWtlVGFiYmFibGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcGFydCBoYXBwZW5zIGFzeW5jaHJvbm91c2x5IGluc2lkZSBzZXRUaW1lb3V0LFxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIHByZXZlbnQgZGVmYXVsdCBvciBzdG9wIHByb3BhZ2F0aW9uLlxuICAgICAgICBuZXh0LmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtb3ZlRm9jdXMoZWxlbWVudCwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9PT0gR3JvdXBwZXJNb3ZlRm9jdXNBY3Rpb25zLkVudGVyID8gdGhpcy5fZW50ZXJHcm91cHBlcihlbGVtZW50KSA6IHRoaXMuX2VzY2FwZUdyb3VwcGVyKGVsZW1lbnQpO1xuICB9XG4gIGhhbmRsZUtleVByZXNzKGVsZW1lbnQsIGV2ZW50LCBmcm9tTW9kYWxpemVyKSB7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBlbGVtZW50KTtcbiAgICBpZiAoY3R4ICYmICgoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lmdyb3VwcGVyKSB8fCAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vZGFsaXplckluR3JvdXBwZXIpKSkge1xuICAgICAgdGFic3Rlci5mb2N1c2VkRWxlbWVudC5jYW5jZWxBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLkVzY2FwZUdyb3VwcGVyKTtcbiAgICAgIGlmIChjdHguaWdub3JlS2V5ZG93bihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICB0aGlzLl9lbnRlckdyb3VwcGVyKGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICAvLyBXZSB3aWxsIGhhbmRsZSBFc2MgYXN5bmNocm9ub3VzbHksIGlmIHNvbWV0aGluZyBpbiB0aGUgYXBwbGljYXRpb24gd2lsbFxuICAgICAgICAvLyBtb3ZlIGZvY3VzIGR1cmluZyB0aGUga2V5cHJlc3MgaGFuZGxpbmcsIHdlIHdpbGwgbm90IGludGVyZmVyZS5cbiAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQucmVxdWVzdEFzeW5jRm9jdXMoQXN5bmNGb2N1c1NvdXJjZXMuRXNjYXBlR3JvdXBwZXIsICgpID0+IHtcbiAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgIT09IHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSAmJiAoXG4gICAgICAgICAgLy8gQSBwYXJ0IG9mIE1vZGFsaXplciB0aGF0IGhhcyBjYWxsZWQgdGhpcyBoYW5kbGVyIHRvIGVzY2FwZSB0aGUgYWN0aXZlIGdyb3VwcGVyXG4gICAgICAgICAgLy8gbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBET00sIGlmIHRoZSBmb2N1cyBpcyBvbiBib2R5LCB3ZSBzdGlsbCB3YW50IHRvIGhhbmRsZSBFc2MuXG4gICAgICAgICAgZnJvbU1vZGFsaXplciAmJiAhZm9jdXNlZEVsZW1lbnQgfHwgIWZyb21Nb2RhbGl6ZXIpKSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgZWxzZSBpbiB0aGUgYXBwbGljYXRpb24gaGFzIG1vdmVkIGZvY3VzLCB3ZSB3aWxsIG5vdCBoYW5kbGUgRXNjLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lc2NhcGVHcm91cHBlcihlbGVtZW50LCBldmVudCwgZnJvbU1vZGFsaXplcik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3NldEluZm9ybWF0aXZlU3R5bGUkMSh3ZWFrRWxlbWVudCwgcmVtb3ZlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB3ZWFrRWxlbWVudC5nZXQoKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS10YWJzdGVyLWdyb3VwcGVyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGFic3Rlci1ncm91cHBlclwiLCBcInVubGltaXRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY2xhc3MgS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGUgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3RvcihnZXRXaW5kb3cpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX29uQ2hhbmdlID0gaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkID0+IHtcbiAgICAgIHRoaXMuc2V0VmFsKGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHRoaXMuX2tleWJvcmcgPSBjcmVhdGVLZXlib3JnKGdldFdpbmRvdygpKTtcbiAgICB0aGlzLl9rZXlib3JnLnN1YnNjcmliZSh0aGlzLl9vbkNoYW5nZSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgaWYgKHRoaXMuX2tleWJvcmcpIHtcbiAgICAgIHRoaXMuX2tleWJvcmcudW5zdWJzY3JpYmUodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgZGlzcG9zZUtleWJvcmcodGhpcy5fa2V5Ym9yZyk7XG4gICAgICBkZWxldGUgdGhpcy5fa2V5Ym9yZztcbiAgICB9XG4gIH1cbiAgc2V0TmF2aWdhdGluZ1dpdGhLZXlib2FyZChpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fa2V5Ym9yZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFZhbChpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQpO1xuICB9XG4gIGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHRoaXMuX2tleWJvcmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xubGV0IF93YXNGb2N1c2VkQ291bnRlciA9IDA7XG5jb25zdCBfYXJpYUhpZGRlbiA9IFwiYXJpYS1oaWRkZW5cIjtcbmZ1bmN0aW9uIF9zZXRJbmZvcm1hdGl2ZVN0eWxlKHdlYWtFbGVtZW50LCByZW1vdmUsIGludGVybmFsSWQsIHVzZXJJZCwgaXNBY3RpdmUsIHdhc0ZvY3VzZWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHdlYWtFbGVtZW50LmdldCgpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXRhYnN0ZXItbW9kYWxpemVyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGFic3Rlci1tb2RhbGl6ZXJcIiwgaW50ZXJuYWxJZCArIFwiLFwiICsgdXNlcklkICsgXCIsXCIgKyAoaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogXCJpbmFjdGl2ZVwiKSArIFwiLFwiICsgXCIsXCIgKyAod2FzRm9jdXNlZCA/IGBmb2N1c2VkKCR7d2FzRm9jdXNlZH0pYCA6IFwibm90LWZvY3VzZWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBkdW1teSBpbnB1dHMgZm9yIHRoZSBNb2RhbGl6ZXIuXG4gKi9cbmNsYXNzIE1vZGFsaXplckR1bW15TWFuYWdlciBleHRlbmRzIER1bW15SW5wdXRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFic3Rlciwgc3lzKSB7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgRHVtbXlJbnB1dE1hbmFnZXJQcmlvcml0aWVzLk1vZGFsaXplciwgc3lzKTtcbiAgICB0aGlzLl9zZXRIYW5kbGVycygoZHVtbXlJbnB1dCwgaXNCYWNrd2FyZCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGVsID0gZWxlbWVudC5nZXQoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGVsICYmICgoX2EgPSBSb290QVBJLmdldFJvb3QodGFic3RlciwgZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudCgpKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZHVtbXlJbnB1dC5pbnB1dDtcbiAgICAgIGxldCB0b0ZvY3VzO1xuICAgICAgaWYgKGNvbnRhaW5lciAmJiBpbnB1dCkge1xuICAgICAgICBjb25zdCBkdW1teUNvbnRhaW5lciA9IGdldER1bW15SW5wdXRDb250YWluZXIoaW5wdXQpO1xuICAgICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIGR1bW15Q29udGFpbmVyIHx8IGlucHV0KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIHRvRm9jdXMgPSAoX2IgPSBGb2N1c2VkRWxlbWVudFN0YXRlLmZpbmROZXh0VGFiYmFibGUodGFic3RlciwgY3R4LCBjb250YWluZXIsIGlucHV0LCB1bmRlZmluZWQsIGlzQmFja3dhcmQsIHRydWUpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9Gb2N1cykge1xuICAgICAgICAgIG5hdGl2ZUZvY3VzKHRvRm9jdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE1vZGFsaXplciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgb25EaXNwb3NlLCBwcm9wcywgc3lzLCBhY3RpdmVFbGVtZW50cykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICB0aGlzLl93YXNGb2N1c2VkID0gMDtcbiAgICB0aGlzLnVzZXJJZCA9IHByb3BzLmlkO1xuICAgIHRoaXMuX29uRGlzcG9zZSA9IG9uRGlzcG9zZTtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50cyA9IGFjdGl2ZUVsZW1lbnRzO1xuICAgIGlmICghdGFic3Rlci5jb250cm9sVGFiKSB7XG4gICAgICB0aGlzLmR1bW15TWFuYWdlciA9IG5ldyBNb2RhbGl6ZXJEdW1teU1hbmFnZXIodGhpcy5fZWxlbWVudCwgdGFic3Rlciwgc3lzKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSh0aGlzLl9lbGVtZW50LCBmYWxzZSwgdGhpcy5pZCwgdGhpcy51c2VySWQsIHRoaXMuX2lzQWN0aXZlLCB0aGlzLl93YXNGb2N1c2VkKTtcbiAgICB9XG4gIH1cbiAgbWFrZUFjdGl2ZShpc0FjdGl2ZSkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSAhPT0gaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IHRoaXMuX2FjdGl2ZUVsZW1lbnRzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFjdGl2ZUVsZW1lbnRzLm1hcChlID0+IGUuZ2V0KCkpLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRzLnB1c2gobmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl90YWJzdGVyLmdldFdpbmRvdywgZWxlbWVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSh0aGlzLl9lbGVtZW50LCBmYWxzZSwgdGhpcy5pZCwgdGhpcy51c2VySWQsIHRoaXMuX2lzQWN0aXZlLCB0aGlzLl93YXNGb2N1c2VkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoaXNBY3RpdmUpO1xuICAgIH1cbiAgfVxuICBmb2N1c2VkKG5vSW5jcmVtZW50KSB7XG4gICAgaWYgKCFub0luY3JlbWVudCkge1xuICAgICAgdGhpcy5fd2FzRm9jdXNlZCA9ICsrX3dhc0ZvY3VzZWRDb3VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FzRm9jdXNlZDtcbiAgfVxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIGlmIChwcm9wcy5pZCkge1xuICAgICAgdGhpcy51c2VySWQgPSBwcm9wcy5pZDtcbiAgICB9XG4gICAgdGhpcy5fcHJvcHMgPSB7XG4gICAgICAuLi5wcm9wc1xuICAgIH07XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5tYWtlQWN0aXZlKGZhbHNlKTtcbiAgICB0aGlzLl9vbkRpc3Bvc2UodGhpcyk7XG4gICAgKF9hID0gdGhpcy5kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuZHVtbXlNYW5hZ2VyO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5fcmVtb3ZlKCk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNBY3RpdmU7XG4gIH1cbiAgY29udGFpbnMoZWxlbWVudCkge1xuICAgIHJldHVybiBkb20ubm9kZUNvbnRhaW5zKHRoaXMuZ2V0RWxlbWVudCgpLCBlbGVtZW50KTtcbiAgfVxuICBmaW5kTmV4dFRhYmJhYmxlKGN1cnJlbnRFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50LCBpc0JhY2t3YXJkLCBpZ25vcmVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBtb2RhbGl6ZXJFbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgaWYgKCFtb2RhbGl6ZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgbGV0IG5leHQgPSBudWxsO1xuICAgIGxldCBvdXRPZkRPTU9yZGVyID0gZmFsc2U7XG4gICAgbGV0IHVuY29udHJvbGxlZDtcbiAgICBjb25zdCBjb250YWluZXIgPSBjdXJyZW50RWxlbWVudCAmJiAoKF9hID0gUm9vdEFQSS5nZXRSb290KHRhYnN0ZXIsIGN1cnJlbnRFbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnQoKSk7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29uc3QgZmluZFByb3BzID0ge1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50LFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50LFxuICAgICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5LFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kUHJvcHNPdXQgPSB7fTtcbiAgICAgIG5leHQgPSB0YWJzdGVyLmZvY3VzYWJsZVtpc0JhY2t3YXJkID8gXCJmaW5kUHJldlwiIDogXCJmaW5kTmV4dFwiXShmaW5kUHJvcHMsIGZpbmRQcm9wc091dCk7XG4gICAgICBpZiAoIW5leHQgJiYgdGhpcy5fcHJvcHMuaXNUcmFwcGVkICYmICgoX2IgPSB0YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdGl2ZUlkKSkge1xuICAgICAgICBuZXh0ID0gdGFic3Rlci5mb2N1c2FibGVbaXNCYWNrd2FyZCA/IFwiZmluZExhc3RcIiA6IFwiZmluZEZpcnN0XCJdKHtcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgaWdub3JlQWNjZXNzaWJpbGl0eSxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgICAgfSwgZmluZFByb3BzT3V0KTtcbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0T2ZET01PcmRlciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRPZkRPTU9yZGVyID0gISFmaW5kUHJvcHNPdXQub3V0T2ZET01PcmRlcjtcbiAgICAgIH1cbiAgICAgIHVuY29udHJvbGxlZCA9IGZpbmRQcm9wc091dC51bmNvbnRyb2xsZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBuZXh0LFxuICAgICAgdW5jb250cm9sbGVkLFxuICAgICAgb3V0T2ZET01PcmRlclxuICAgIH07XG4gIH1cbiAgX2Rpc3BhdGNoRXZlbnQoaXNBY3RpdmUsIGFsbEVsZW1lbnRzKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gYWxsRWxlbWVudHMgPyB0aGlzLl9hY3RpdmVFbGVtZW50cy5tYXAoZSA9PiBlLmdldCgpKSA6IFtlbGVtZW50XTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnREZXRhaWwgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy51c2VySWQsXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGlzQWN0aXZlID8gbmV3IE1vZGFsaXplckFjdGl2ZUV2ZW50KGV2ZW50RGV0YWlsKSA6IG5ldyBNb2RhbGl6ZXJJbmFjdGl2ZUV2ZW50KGV2ZW50RGV0YWlsKTtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UHJldmVudGVkO1xuICB9XG4gIF9yZW1vdmUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSh0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIE1vZGFsaXplckFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsXG4gIC8vIEBkZXByZWNhdGVkIHVzZSBhY2Nlc3NpYmxlQ2hlY2suXG4gIGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvciwgYWNjZXNzaWJsZUNoZWNrKSB7XG4gICAgdGhpcy5fb25Nb2RhbGl6ZXJEaXNwb3NlID0gbW9kYWxpemVyID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbW9kYWxpemVyLmlkO1xuICAgICAgY29uc3QgdXNlcklkID0gbW9kYWxpemVyLnVzZXJJZDtcbiAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1t1c2VySWRdO1xuICAgICAgZGVsZXRlIHRoaXMuX21vZGFsaXplcnNbaWRdO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgZGVsZXRlIHBhcnRbaWRdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFydCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcnRzW3VzZXJJZF07XG4gICAgICAgICAgY29uc3QgYWN0aXZhdGlvbkhpc3RvcnkgPSB0aGlzLl9hY3RpdmF0aW9uSGlzdG9yeTtcbiAgICAgICAgICBjb25zdCBjbGVhbkFjdGl2YXRpb25IaXN0b3J5ID0gW107XG4gICAgICAgICAgbGV0IHByZXZIaXN0b3J5SXRlbTtcbiAgICAgICAgICAvLyBUaGUgaGlzdG9yeSBvcmRlciBpcyBmcm9tIG1vc3QgcmVjZW50IHRvIG9sZGVzdC5cbiAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZhdGlvbkhpc3RvcnkubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmF0aW9uIGhpc3RvcnksIG1ha2luZyBzdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAvLyBmb3IgY2FzZXMgbGlrZSBbbW9kYWwyLCBtb2RhbDEsIG1vZGFsMiwgbW9kYWwxXToganVzdCByZW1vdmluZyBtb2RhbDJcbiAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIFttb2RhbDEsIG1vZGFsMV0gYW5kIHdlIHdhbnQganVzdCBbbW9kYWwxXS4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuY2UgZm9yIHRoaXMgYXJyYXkgdG8gZ3JvdyBmb3JldmVyIGluIGEgbmFycm93IGNhc2Ugb2ZcbiAgICAgICAgICAgIC8vIGEgbW9kYWxpemVyIHRoYXQgc3RheXMgaW4gRE9NIGZvcmV2ZXIgYW5kIGlzIGJlaW5nIGFjdGl2YXRlZC9kZWFjdGl2YXRlZFxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gb3RoZXIgbW9kYWxpemVycyB0aGF0IGNvbWUgYW5kIGdvLlxuICAgICAgICAgICAgY29uc3QgbW9kYWxpemVyVXNlcklkRnJvbUhpc3RvcnkgPSBhY3RpdmF0aW9uSGlzdG9yeVtpXTtcbiAgICAgICAgICAgIGlmIChtb2RhbGl6ZXJVc2VySWRGcm9tSGlzdG9yeSA9PT0gdXNlcklkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGFsaXplclVzZXJJZEZyb21IaXN0b3J5ICE9PSBwcmV2SGlzdG9yeUl0ZW0pIHtcbiAgICAgICAgICAgICAgcHJldkhpc3RvcnlJdGVtID0gbW9kYWxpemVyVXNlcklkRnJvbUhpc3Rvcnk7XG4gICAgICAgICAgICAgIGlmIChtb2RhbGl6ZXJVc2VySWRGcm9tSGlzdG9yeSB8fCBjbGVhbkFjdGl2YXRpb25IaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhbkFjdGl2YXRpb25IaXN0b3J5LnVuc2hpZnQobW9kYWxpemVyVXNlcklkRnJvbUhpc3RvcnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2FjdGl2YXRpb25IaXN0b3J5ID0gY2xlYW5BY3RpdmF0aW9uSGlzdG9yeTtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmVJZCA9PT0gdXNlcklkKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2QWN0aXZlSWQgPSBjbGVhbkFjdGl2YXRpb25IaXN0b3J5WzBdO1xuICAgICAgICAgICAgY29uc3QgcHJldkFjdGl2ZSA9IHByZXZBY3RpdmVJZCA/IE9iamVjdC52YWx1ZXModGhpcy5fcGFydHNbcHJldkFjdGl2ZUlkXSlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZShwcmV2QWN0aXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEtleXMuRXNjYXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG1vZGFsaXplciA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5tb2RhbGl6ZXI7XG4gICAgICAgIGlmIChjdHggJiYgIWN0eC5ncm91cHBlciAmJiAobW9kYWxpemVyID09PSBudWxsIHx8IG1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxpemVyLmlzQWN0aXZlKCkpICYmICFjdHguaWdub3JlS2V5ZG93bihldmVudCkpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVJZCA9IG1vZGFsaXplci51c2VySWQ7XG4gICAgICAgICAgaWYgKGFjdGl2ZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5fcGFydHNbYWN0aXZlSWRdO1xuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgZm9jdXNlZFNpbmNlID0gT2JqZWN0LmtleXMocGFydCkubWFwKGlkID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHBhcnRbaWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gbS5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwcGVyO1xuICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgZ3JvdXBwZXIgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyb3VwcGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbSAmJiBlbCAmJiBncm91cHBlciA/IHtcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgZm9jdXNlZFNpbmNlOiBtLmZvY3VzZWQodHJ1ZSlcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgZm9jdXNlZFNpbmNlOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSkuZmlsdGVyKGYgPT4gZi5mb2N1c2VkU2luY2UgPiAwKS5zb3J0KChhLCBiKSA9PiBhLmZvY3VzZWRTaW5jZSA+IGIuZm9jdXNlZFNpbmNlID8gLTEgOiBhLmZvY3VzZWRTaW5jZSA8IGIuZm9jdXNlZFNpbmNlID8gMSA6IDApO1xuICAgICAgICAgICAgICBpZiAoZm9jdXNlZFNpbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IGZvY3VzZWRTaW5jZVswXS5lbDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAoX2EgPSB0YWJzdGVyLmdyb3VwcGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlS2V5UHJlc3MoZ3JvdXBwZXJFbGVtZW50LCBldmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBmb2N1cyBzdGF0ZSBhbmQgaGFuZGxlcyBtb2RhbGl6ZXIgcmVsYXRlZCBmb2N1cyBldmVudHNcbiAgICAgKiBAcGFyYW0gZm9jdXNlZEVsZW1lbnQgLSBFbGVtZW50IHRoYXQgaXMgZm9jdXNlZFxuICAgICAqIEBwYXJhbSBkZXRhaWwgLSBBZGRpdGlvbmFsIGRhdGEgYWJvdXQgdGhlIGZvY3VzIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5fb25Gb2N1cyA9IChmb2N1c2VkRWxlbWVudCwgZGV0YWlsKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICAgIGNvbnN0IGN0eCA9IGZvY3VzZWRFbGVtZW50ICYmIFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZm9jdXNlZEVsZW1lbnQpO1xuICAgICAgLy8gTW9kYWxpemVyIGJlaGF2aW91ciBpcyBvcHQgaW4sIG9ubHkgYXBwbHkgdG8gZWxlbWVudHMgdGhhdCBoYXZlIGEgdGFic3RlciBjb250ZXh0XG4gICAgICBpZiAoIWN0eCB8fCAhZm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVnbWVudGVkTWFwID0gdGhpcy5fYXVnTWFwO1xuICAgICAgZm9yIChsZXQgZSA9IGZvY3VzZWRFbGVtZW50OyBlOyBlID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZSkpIHtcbiAgICAgICAgLy8gSWYgdGhlIG5ld2x5IGZvY3VzZWQgZWxlbWVudCBpcyBpbnNpZGUgc29tZSBvZiB0aGUgaGlkZGVuIGNvbnRhaW5lcnMsXG4gICAgICAgIC8vIHJlbW92ZSBhcmlhLWhpZGRlbiBmcm9tIHRob3NlIHN5bmNocm9ub3VzbHkgZm9yIHRoZSBzY3JlZW4gcmVhZGVyc1xuICAgICAgICAvLyB0byBiZSBhYmxlIHRvIHJlYWQgdGhlIGVsZW1lbnQuIFRoZSByZXN0IG9mIGFyaWEtaGlkZGVucywgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgIC8vIGFjeW5jaHJvbm91c2x5IGZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZS5cbiAgICAgICAgaWYgKGF1Z21lbnRlZE1hcC5oYXMoZSkpIHtcbiAgICAgICAgICBhdWdtZW50ZWRNYXAuZGVsZXRlKGUpO1xuICAgICAgICAgIGF1Z21lbnRBdHRyaWJ1dGUodGFic3RlciwgZSwgX2FyaWFIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbW9kYWxpemVyID0gY3R4Lm1vZGFsaXplcjtcbiAgICAgIGNvbnN0IHRhYnN0ZXJPbkZvY3VzZWRFbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBmb2N1c2VkRWxlbWVudCk7XG4gICAgICBjb25zdCBtb2RhbGl6ZXJPbkZvY3VzZWRFbGVtZW50ID0gdGFic3Rlck9uRm9jdXNlZEVsZW1lbnQgPT09IG51bGwgfHwgdGFic3Rlck9uRm9jdXNlZEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYnN0ZXJPbkZvY3VzZWRFbGVtZW50Lm1vZGFsaXplcjtcbiAgICAgIGlmIChtb2RhbGl6ZXJPbkZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIG1vZGFsaXplck9uRm9jdXNlZEVsZW1lbnQuZm9jdXNlZCgpO1xuICAgICAgICBpZiAobW9kYWxpemVyT25Gb2N1c2VkRWxlbWVudC51c2VySWQgPT09IHRoaXMuYWN0aXZlSWQgJiYgdGFic3Rlck9uRm9jdXNlZEVsZW1lbnQuZ3JvdXBwZXIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gdGFic3Rlci5nZXRQYXJlbnQoZm9jdXNlZEVsZW1lbnQpO1xuICAgICAgICAgIGNvbnN0IHBhcmVudE1vZGFsaXplciA9IHBhcmVudEVsZW1lbnQgJiYgKChfYSA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgcGFyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RhbGl6ZXIpO1xuICAgICAgICAgIGlmIChwYXJlbnRNb2RhbGl6ZXIpIHtcbiAgICAgICAgICAgIG1vZGFsaXplciA9IHBhcmVudE1vZGFsaXplcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuIGluYWN0aXZlIGdyb3VwcGVyIHdpdGggdGhlIG1vZGFsaXplciBvbiB0aGUgc2FtZSBub2RlIHdpbGwgbm90IGdpdmUgdGhlIG1vZGFsaXplclxuICAgICAgLy8gaW4gdGhlIGNvbnRleHQsIHlldCB3ZSBzdGlsbCB3YW50IHRvIHRyYWNrIHRoYXQgdGhlIG1vZGFsaXplcidzIGNvbnRhaW5lciB3YXMgZm9jdXNlZC5cbiAgICAgIG1vZGFsaXplciA9PT0gbnVsbCB8fCBtb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGFsaXplci5mb2N1c2VkKCk7XG4gICAgICBpZiAoKG1vZGFsaXplciA9PT0gbnVsbCB8fCBtb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGFsaXplci51c2VySWQpID09PSB0aGlzLmFjdGl2ZUlkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudElzT3RoZXJzQWNjZXNzaWJsZSA9IG1vZGFsaXplciA9PT0gbnVsbCB8fCBtb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGFsaXplci5nZXRQcm9wcygpLmlzT3RoZXJzQWNjZXNzaWJsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gRGV2ZWxvcGVycyBjYWxsaW5nIGBlbGVtZW50LmZvY3VzKClgIHNob3VsZCBjaGFuZ2UvZGVhY3RpdmF0ZSBhY3RpdmUgbW9kYWxpemVyXG4gICAgICBpZiAoZGV0YWlsLmlzRm9jdXNlZFByb2dyYW1tYXRpY2FsbHkgfHwgdGhpcy5jdXJyZW50SXNPdGhlcnNBY2Nlc3NpYmxlIHx8IChtb2RhbGl6ZXIgPT09IG51bGwgfHwgbW9kYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbGl6ZXIuZ2V0UHJvcHMoKS5pc0Fsd2F5c0FjY2Vzc2libGUpKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKG1vZGFsaXplcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb2N1c2VkIG91dHNpZGUgb2YgdGhlIGFjdGl2ZSBtb2RhbGl6ZXIsIHRyeSBwdWxsIGZvY3VzIGJhY2sgdG8gY3VycmVudCBtb2RhbGl6ZXJcbiAgICAgICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5fcmVzdG9yZU1vZGFsaXplckZvY3VzVGltZXIpO1xuICAgICAgICAvLyBUT0RPIHNvbWUgcmVuZGVyaW5nIGZyYW1ld29ya3MgKGkuZS4gUmVhY3QpIG1pZ2h0IGFzeW5jIHJlcmVuZGVyIHRoZSBET00gc28gd2UgbmVlZCB0byB3YWl0IGZvciBhIGR1cmF0aW9uXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXMgcmF0aGVyIHRoYW4gYSAxMDBtcyB0aW1lb3V0XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVNb2RhbGl6ZXJGb2N1c1RpbWVyID0gd2luLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcmVzdG9yZU1vZGFsaXplckZvY3VzKGZvY3VzZWRFbGVtZW50KSwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3dpbiA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMuX21vZGFsaXplcnMgPSB7fTtcbiAgICB0aGlzLl9wYXJ0cyA9IHt9O1xuICAgIHRoaXMuX2F1Z01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fYXVnID0gW107XG4gICAgdGhpcy5fYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yID0gYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yO1xuICAgIHRoaXMuX2FjY2Vzc2libGVDaGVjayA9IGFjY2Vzc2libGVDaGVjaztcbiAgICB0aGlzLl9hY3RpdmF0aW9uSGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICBpZiAoIXRhYnN0ZXIuY29udHJvbFRhYikge1xuICAgICAgdGFic3Rlci5yb290LmFkZER1bW15SW5wdXRzKCk7XG4gICAgfVxuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIHRydWUpO1xuICAgIHRhYnN0ZXIucXVldWVJbml0KCgpID0+IHtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgLy8gRGlzcG9zZSBhbGwgbW9kYWxpemVycyBtYW5hZ2VkIGJ5IHRoZSBBUElcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9tb2RhbGl6ZXJzKS5mb3JFYWNoKG1vZGFsaXplcklkID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbGl6ZXJzW21vZGFsaXplcklkXSkge1xuICAgICAgICB0aGlzLl9tb2RhbGl6ZXJzW21vZGFsaXplcklkXS5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RhbGl6ZXJzW21vZGFsaXplcklkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3RvcmVNb2RhbGl6ZXJGb2N1c1RpbWVyKTtcbiAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGRlblVwZGF0ZVRpbWVyKTtcbiAgICB0aGlzLl9wYXJ0cyA9IHt9O1xuICAgIGRlbGV0ZSB0aGlzLmFjdGl2ZUlkO1xuICAgIHRoaXMuYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9hdWdNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX2F1ZyA9IFtdO1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gIH1cbiAgY3JlYXRlTW9kYWxpemVyKGVsZW1lbnQsIHByb3BzLCBzeXMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSA7XG4gICAgY29uc3QgbW9kYWxpemVyID0gbmV3IE1vZGFsaXplcih0aGlzLl90YWJzdGVyLCBlbGVtZW50LCB0aGlzLl9vbk1vZGFsaXplckRpc3Bvc2UsIHByb3BzLCBzeXMsIHRoaXMuYWN0aXZlRWxlbWVudHMpO1xuICAgIGNvbnN0IGlkID0gbW9kYWxpemVyLmlkO1xuICAgIGNvbnN0IHVzZXJJZCA9IHByb3BzLmlkO1xuICAgIHRoaXMuX21vZGFsaXplcnNbaWRdID0gbW9kYWxpemVyO1xuICAgIGxldCBwYXJ0ID0gdGhpcy5fcGFydHNbdXNlcklkXTtcbiAgICBpZiAoIXBhcnQpIHtcbiAgICAgIHBhcnQgPSB0aGlzLl9wYXJ0c1t1c2VySWRdID0ge307XG4gICAgfVxuICAgIHBhcnRbaWRdID0gbW9kYWxpemVyO1xuICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gKF9hID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIC8vIEFkZGluZyBhIG1vZGFsaXplciB3aGljaCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFjdGl2YXRlIGl0XG4gICAgaWYgKGVsZW1lbnQgIT09IGZvY3VzZWRFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZm9jdXNlZEVsZW1lbnQpKSB7XG4gICAgICBpZiAodXNlcklkICE9PSB0aGlzLmFjdGl2ZUlkKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKG1vZGFsaXplcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RhbGl6ZXIubWFrZUFjdGl2ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vZGFsaXplcjtcbiAgfVxuICBpc0F1Z21lbnRlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1Z01hcC5oYXMoZWxlbWVudCk7XG4gIH1cbiAgaGlkZGVuVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9oaWRkZW5VcGRhdGVUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9oaWRkZW5VcGRhdGVUaW1lciA9IHRoaXMuX3dpbigpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX2hpZGRlblVwZGF0ZVRpbWVyO1xuICAgICAgdGhpcy5faGlkZGVuVXBkYXRlKCk7XG4gICAgfSwgMjUwKTtcbiAgfVxuICBzZXRBY3RpdmUobW9kYWxpemVyKSB7XG4gICAgY29uc3QgdXNlcklkID0gbW9kYWxpemVyID09PSBudWxsIHx8IG1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxpemVyLnVzZXJJZDtcbiAgICBjb25zdCBhY3RpdmVJZCA9IHRoaXMuYWN0aXZlSWQ7XG4gICAgaWYgKGFjdGl2ZUlkID09PSB1c2VySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVJZCA9IHVzZXJJZDtcbiAgICBpZiAoYWN0aXZlSWQpIHtcbiAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1thY3RpdmVJZF07XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHBhcnQpKSB7XG4gICAgICAgICAgcGFydFtpZF0ubWFrZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgY29uc3QgcGFydCA9IHRoaXMuX3BhcnRzW3VzZXJJZF07XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHBhcnQpKSB7XG4gICAgICAgICAgcGFydFtpZF0ubWFrZUFjdGl2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRJc090aGVyc0FjY2Vzc2libGUgPSBtb2RhbGl6ZXIgPT09IG51bGwgfHwgbW9kYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbGl6ZXIuZ2V0UHJvcHMoKS5pc090aGVyc0FjY2Vzc2libGU7XG4gICAgdGhpcy5oaWRkZW5VcGRhdGUoKTtcbiAgICBjb25zdCBhY3RpdmF0aW9uSGlzdG9yeSA9IHRoaXMuX2FjdGl2YXRpb25IaXN0b3J5O1xuICAgIGlmIChhY3RpdmF0aW9uSGlzdG9yeVswXSAhPT0gdXNlcklkICYmICh1c2VySWQgIT09IHVuZGVmaW5lZCB8fCBhY3RpdmF0aW9uSGlzdG9yeS5sZW5ndGggPiAwKSkge1xuICAgICAgYWN0aXZhdGlvbkhpc3RvcnkudW5zaGlmdCh1c2VySWQpO1xuICAgIH1cbiAgfVxuICBmb2N1cyhlbGVtZW50RnJvbU1vZGFsaXplciwgbm9Gb2N1c0ZpcnN0LCBub0ZvY3VzRGVmYXVsdCkge1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudEZyb21Nb2RhbGl6ZXIpO1xuICAgIGNvbnN0IG1vZGFsaXplciA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5tb2RhbGl6ZXI7XG4gICAgaWYgKG1vZGFsaXplcikge1xuICAgICAgdGhpcy5zZXRBY3RpdmUobW9kYWxpemVyKTtcbiAgICAgIGNvbnN0IHByb3BzID0gbW9kYWxpemVyLmdldFByb3BzKCk7XG4gICAgICBjb25zdCBtb2RhbGl6ZXJSb290ID0gbW9kYWxpemVyLmdldEVsZW1lbnQoKTtcbiAgICAgIGlmIChtb2RhbGl6ZXJSb290KSB7XG4gICAgICAgIGlmIChub0ZvY3VzRmlyc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vRm9jdXNGaXJzdCA9IHByb3BzLmlzTm9Gb2N1c0ZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9Gb2N1c0ZpcnN0ICYmIHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpICYmIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZm9jdXNGaXJzdCh7XG4gICAgICAgICAgY29udGFpbmVyOiBtb2RhbGl6ZXJSb290XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vRm9jdXNEZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub0ZvY3VzRGVmYXVsdCA9IHByb3BzLmlzTm9Gb2N1c0RlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub0ZvY3VzRGVmYXVsdCAmJiB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzRGVmYXVsdChtb2RhbGl6ZXJSb290KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQucmVzZXRGb2N1cyhtb2RhbGl6ZXJSb290KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRWxlbWVudCBpcyBub3QgaW4gTW9kYWxpemVyLlwiLCBlbGVtZW50RnJvbU1vZGFsaXplcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhY3RpdmF0ZShtb2RhbGl6ZXJFbGVtZW50T3JDb250YWluZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbW9kYWxpemVyVG9BY3RpdmF0ZSA9IG1vZGFsaXplckVsZW1lbnRPckNvbnRhaW5lciA/IChfYSA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgbW9kYWxpemVyRWxlbWVudE9yQ29udGFpbmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGFsaXplciA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW1vZGFsaXplckVsZW1lbnRPckNvbnRhaW5lciB8fCBtb2RhbGl6ZXJUb0FjdGl2YXRlKSB7XG4gICAgICB0aGlzLnNldEFjdGl2ZShtb2RhbGl6ZXJUb0FjdGl2YXRlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWNjZXB0RWxlbWVudChlbGVtZW50LCBzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtb2RhbGl6ZXJVc2VySWQgPSBzdGF0ZS5tb2RhbGl6ZXJVc2VySWQ7XG4gICAgY29uc3QgY3VycmVudE1vZGFsaXplciA9IChfYSA9IHN0YXRlLmN1cnJlbnRDdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RhbGl6ZXI7XG4gICAgaWYgKG1vZGFsaXplclVzZXJJZCkge1xuICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuYWN0aXZlRWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgZWwgPSBlLmdldCgpO1xuICAgICAgICBpZiAoZWwgJiYgKGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZWwpIHx8IGVsID09PSBlbGVtZW50KSkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgYSBwYXJ0IG9mIGN1cnJlbnRseSBhY3RpdmUgbW9kYWxpemVyIHNvbWV3aGVyZSBkZWVwZXIgaW4gdGhlIERPTSxcbiAgICAgICAgICAvLyBza2lwcGluZyBhbGwgb3RoZXIgY2hlY2tzLlxuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IG1vZGFsaXplclVzZXJJZCA9PT0gKGN1cnJlbnRNb2RhbGl6ZXIgPT09IG51bGwgfHwgY3VycmVudE1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE1vZGFsaXplci51c2VySWQpIHx8ICFtb2RhbGl6ZXJVc2VySWQgJiYgKGN1cnJlbnRNb2RhbGl6ZXIgPT09IG51bGwgfHwgY3VycmVudE1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE1vZGFsaXplci5nZXRQcm9wcygpLmlzQWx3YXlzQWNjZXNzaWJsZSkgPyB1bmRlZmluZWQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgX2hpZGRlblVwZGF0ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgYm9keSA9IHRhYnN0ZXIuZ2V0V2luZG93KCkuZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBhY3RpdmVJZCA9IHRoaXMuYWN0aXZlSWQ7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLl9wYXJ0cztcbiAgICBjb25zdCB2aXNpYmxlRWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvciA9IHRoaXMuX2Fsd2F5c0FjY2Vzc2libGVTZWxlY3RvcjtcbiAgICBjb25zdCBhbHdheXNBY2Nlc3NpYmxlRWxlbWVudHMgPSBhbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3IgPyBBcnJheS5mcm9tKGRvbS5xdWVyeVNlbGVjdG9yQWxsKGJvZHksIGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvcikpIDogW107XG4gICAgY29uc3QgYWN0aXZlTW9kYWxpemVyRWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHVzZXJJZCBvZiBPYmplY3Qua2V5cyhwYXJ0cykpIHtcbiAgICAgIGNvbnN0IG1vZGFsaXplclBhcnRzID0gcGFydHNbdXNlcklkXTtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMobW9kYWxpemVyUGFydHMpKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsaXplciA9IG1vZGFsaXplclBhcnRzW2lkXTtcbiAgICAgICAgY29uc3QgZWwgPSBtb2RhbGl6ZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IG1vZGFsaXplci5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCBpc0Fsd2F5c0FjY2Vzc2libGUgPSBwcm9wcy5pc0Fsd2F5c0FjY2Vzc2libGU7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGlmICh1c2VySWQgPT09IGFjdGl2ZUlkKSB7XG4gICAgICAgICAgICBhY3RpdmVNb2RhbGl6ZXJFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50SXNPdGhlcnNBY2Nlc3NpYmxlKSB7XG4gICAgICAgICAgICAgIHZpc2libGVFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQWx3YXlzQWNjZXNzaWJsZSkge1xuICAgICAgICAgICAgYWx3YXlzQWNjZXNzaWJsZUVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWRkZW5FbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXVnbWVudGVkTWFwID0gdGhpcy5fYXVnTWFwO1xuICAgIGNvbnN0IGFsbFZpc2libGVFbGVtZW50cyA9IHZpc2libGVFbGVtZW50cy5sZW5ndGggPiAwID8gWy4uLnZpc2libGVFbGVtZW50cywgLi4uYWx3YXlzQWNjZXNzaWJsZUVsZW1lbnRzXSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdBdWdtZW50ZWQgPSBbXTtcbiAgICBjb25zdCBuZXdBdWdtZW50ZWRNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHRvZ2dsZSA9IChlbGVtZW50LCBoaWRlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lO1xuICAgICAgaWYgKHRhZ05hbWUgPT09IFwiU0NSSVBUXCIgfHwgdGFnTmFtZSA9PT0gXCJTVFlMRVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBpc0F1Z21lbnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGF1Z21lbnRlZE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICBpc0F1Z21lbnRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXVnbWVudGVkTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICBhdWdtZW50QXR0cmlidXRlKHRhYnN0ZXIsIGVsZW1lbnQsIF9hcmlhSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoaWRlICYmICEoKF9hID0gdGhpcy5fYWNjZXNzaWJsZUNoZWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlbGVtZW50LCBhY3RpdmVNb2RhbGl6ZXJFbGVtZW50cykpICYmIGF1Z21lbnRBdHRyaWJ1dGUodGFic3RlciwgZWxlbWVudCwgX2FyaWFIaWRkZW4sIFwidHJ1ZVwiKSkge1xuICAgICAgICBhdWdtZW50ZWRNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpc0F1Z21lbnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBdWdtZW50ZWQpIHtcbiAgICAgICAgbmV3QXVnbWVudGVkLnB1c2gobmV3IFdlYWtIVE1MRWxlbWVudCh0YWJzdGVyLmdldFdpbmRvdywgZWxlbWVudCkpO1xuICAgICAgICBuZXdBdWdtZW50ZWRNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2FsayA9IGVsZW1lbnQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgZm9yIChsZXQgZWwgPSBkb20uZ2V0Rmlyc3RFbGVtZW50Q2hpbGQoZWxlbWVudCk7IGVsOyBlbCA9IGRvbS5nZXROZXh0RWxlbWVudFNpYmxpbmcoZWwpKSB7XG4gICAgICAgIGxldCBza2lwID0gZmFsc2U7XG4gICAgICAgIGxldCBjb250YWluc01vZGFsaXplciA9IGZhbHNlO1xuICAgICAgICBsZXQgY29udGFpbmVkQnlNb2RhbGl6ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFsbFZpc2libGVFbGVtZW50cykge1xuICAgICAgICAgIGNvbnN0IGVsUGFyZW50ID0gdGFic3Rlci5nZXRQYXJlbnQoZWwpO1xuICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBhbGxWaXNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gYykge1xuICAgICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVDb250YWlucyhlbCwgYykpIHtcbiAgICAgICAgICAgICAgY29udGFpbnNNb2RhbGl6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLm5vZGVDb250YWlucyhjLCBlbFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgLy8gdGFic3Rlci5nZXRQYXJlbnQoKSBjb3VsZCBiZSBwcm92aWRlZCBieSB0aGUgYXBwbGljYXRpb24gdG9cbiAgICAgICAgICAgICAgLy8gaGFuZGxlLCBmb3IgZXhhbXBsZSwgdmlydHVhbCBwYXJlbnRzLiBNYWtpbmcgc3VyZSwgd2UgYXJlXG4gICAgICAgICAgICAgIC8vIG5vdCBzZXR0aW5nIGFyaWEtaGlkZGVuIG9uIGVsZW1lbnRzIHdoaWNoIGFyZSB2aXJ0dWFsbHlcbiAgICAgICAgICAgICAgLy8gaW5zaWRlIG1vZGFsaXplci5cbiAgICAgICAgICAgICAgY29udGFpbmVkQnlNb2RhbGl6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbnNNb2RhbGl6ZXIgfHwgKChfYSA9IGVsLl9fdGFic3RlckVsZW1lbnRGbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vRGlyZWN0QXJpYUhpZGRlbikpIHtcbiAgICAgICAgICAgIHdhbGsoZWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNraXAgJiYgIWNvbnRhaW5lZEJ5TW9kYWxpemVyKSB7XG4gICAgICAgICAgICB0b2dnbGUoZWwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2dnbGUoZWwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhbGxWaXNpYmxlRWxlbWVudHMpIHtcbiAgICAgIGFsd2F5c0FjY2Vzc2libGVFbGVtZW50cy5mb3JFYWNoKGUgPT4gdG9nZ2xlKGUsIGZhbHNlKSk7XG4gICAgfVxuICAgIGhpZGRlbkVsZW1lbnRzLmZvckVhY2goZSA9PiB0b2dnbGUoZSwgdHJ1ZSkpO1xuICAgIGlmIChib2R5KSB7XG4gICAgICB3YWxrKGJvZHkpO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLl9hdWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZSA9PiBlLmdldCgpKS5mb3JFYWNoKGUgPT4ge1xuICAgICAgaWYgKGUgJiYgIW5ld0F1Z21lbnRlZE1hcC5nZXQoZSkpIHtcbiAgICAgICAgdG9nZ2xlKGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9hdWcgPSBuZXdBdWdtZW50ZWQ7XG4gICAgdGhpcy5fYXVnTWFwID0gbmV3QXVnbWVudGVkTWFwO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBlbGVtZW50IGlzIGZvY3VzZWQgb3V0c2lkZSBvZiBhbiBhY3RpdmUgbW9kYWxpemVyLlxuICAgKiBBdHRlbXB0cyB0byBwdWxsIGZvY3VzIGJhY2sgaW50byB0aGUgYWN0aXZlIG1vZGFsaXplclxuICAgKiBAcGFyYW0gb3V0c2lkZUVsZW1lbnQgLSBBbiBlbGVtZW50IGJlaW5nIGZvY3VzZWQgb3V0c2lkZSBvZiB0aGUgbW9kYWxpemVyXG4gICAqL1xuICBfcmVzdG9yZU1vZGFsaXplckZvY3VzKG91dHNpZGVFbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBvdXRzaWRlRWxlbWVudCA9PT0gbnVsbCB8fCBvdXRzaWRlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0c2lkZUVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBpZiAoIW91dHNpZGVFbGVtZW50IHx8ICFvd25lckRvY3VtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50TW9kYWxpemVyID0gZm9jdXNlZEVsZW1lbnQgJiYgKChfYSA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgZm9jdXNlZEVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kYWxpemVyKTtcbiAgICBpZiAoIWZvY3VzZWRFbGVtZW50IHx8IGZvY3VzZWRFbGVtZW50ICYmIChmb2N1c2VkRWxlbWVudE1vZGFsaXplciA9PT0gbnVsbCB8fCBmb2N1c2VkRWxlbWVudE1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9jdXNlZEVsZW1lbnRNb2RhbGl6ZXIudXNlcklkKSA9PT0gdGhpcy5hY3RpdmVJZCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgb3IgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIC8vIGlzIGluIHRoZSBhY3RpdmUgbW9kYWxpemVyLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIG91dHNpZGVFbGVtZW50KTtcbiAgICBjb25zdCBtb2RhbGl6ZXIgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgubW9kYWxpemVyO1xuICAgIGNvbnN0IGFjdGl2ZUlkID0gdGhpcy5hY3RpdmVJZDtcbiAgICBpZiAoIW1vZGFsaXplciAmJiAhYWN0aXZlSWQgfHwgbW9kYWxpemVyICYmIGFjdGl2ZUlkID09PSBtb2RhbGl6ZXIudXNlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5yb290LmdldEVsZW1lbnQoKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBsZXQgdG9Gb2N1cyA9IHRhYnN0ZXIuZm9jdXNhYmxlLmZpbmRGaXJzdCh7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmICh0b0ZvY3VzKSB7XG4gICAgICAgIGlmIChvdXRzaWRlRWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0b0ZvY3VzKSAmIGRvY3VtZW50LkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgICAgIHRvRm9jdXMgPSB0YWJzdGVyLmZvY3VzYWJsZS5maW5kTGFzdCh7XG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXRvRm9jdXMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb25seSBtaWdodCBtZWFuIHRoYXQgZmluZEZpcnN0L2ZpbmRMYXN0IGFyZSBidWdneSBhbmQgaW5jb25zaXN0ZW50LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKHRvRm9jdXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgTW9kYWxpemVyIGRvZXNuJ3Qgc2VlbSB0byBoYXZlIGZvY3VzYWJsZSBlbGVtZW50cy5cbiAgICAvLyBCbHVycmluZyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aGljaCBpcyBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IE1vZGFsaXplci5cbiAgICBvdXRzaWRlRWxlbWVudC5ibHVyKCk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgX2lucHV0U2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovW1wiaW5wdXRcIiwgXCJ0ZXh0YXJlYVwiLCBcIipbY29udGVudGVkaXRhYmxlXVwiXS5qb2luKFwiLCBcIik7XG5jbGFzcyBNb3ZlckR1bW15TWFuYWdlciBleHRlbmRzIER1bW15SW5wdXRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFic3RlciwgZ2V0TWVtb3JpemVkLCBzeXMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCBlbGVtZW50LCBEdW1teUlucHV0TWFuYWdlclByaW9yaXRpZXMuTW92ZXIsIHN5cyk7XG4gICAgdGhpcy5fb25Gb2N1c0R1bW15SW5wdXQgPSBkdW1teUlucHV0ID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50LmdldCgpO1xuICAgICAgY29uc3QgaW5wdXQgPSBkdW1teUlucHV0LmlucHV0O1xuICAgICAgaWYgKGNvbnRhaW5lciAmJiBpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGNvbnRhaW5lcik7XG4gICAgICAgIGxldCB0b0ZvY3VzO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgdG9Gb2N1cyA9IChfYSA9IEZvY3VzZWRFbGVtZW50U3RhdGUuZmluZE5leHRUYWJiYWJsZSh0aGlzLl90YWJzdGVyLCBjdHgsIHVuZGVmaW5lZCwgaW5wdXQsIHVuZGVmaW5lZCwgIWR1bW15SW5wdXQuaXNGaXJzdCwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbW9yaXplZCA9IChfYiA9IHRoaXMuX2dldE1lbW9yaXplZCgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KCk7XG4gICAgICAgIGlmIChtZW1vcml6ZWQgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUobWVtb3JpemVkKSkge1xuICAgICAgICAgIHRvRm9jdXMgPSBtZW1vcml6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICBuYXRpdmVGb2N1cyh0b0ZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fZ2V0TWVtb3JpemVkID0gZ2V0TWVtb3JpemVkO1xuICAgIHRoaXMuX3NldEhhbmRsZXJzKHRoaXMuX29uRm9jdXNEdW1teUlucHV0KTtcbiAgfVxufVxuLy8gVHlwZVNjcmlwdCBlbnVtcyBwcm9kdWNlIGRlcHJlc3NpbmcgSmF2YVNjcmlwdCBjb2RlLCBzbywgd2UncmUganVzdCB1c2luZ1xuLy8gYSBmZXcgb2xkIHN0eWxlIGNvbnN0YW50cyBoZXJlLlxuY29uc3QgX21vdmVyVXBkYXRlQWRkID0gMTtcbmNvbnN0IF9tb3ZlclVwZGF0ZUF0dHIgPSAyO1xuY29uc3QgX21vdmVyVXBkYXRlUmVtb3ZlID0gMztcbmNsYXNzIE1vdmVyIGV4dGVuZHMgVGFic3RlclBhcnQge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBvbkRpc3Bvc2UsIHByb3BzLCBzeXMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgcHJvcHMpO1xuICAgIHRoaXMuX3Zpc2libGUgPSB7fTtcbiAgICB0aGlzLl9vbkludGVyc2VjdGlvbiA9IGVudHJpZXMgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZW50cnkudGFyZ2V0O1xuICAgICAgICBjb25zdCBpZCA9IGdldEVsZW1lbnRVSWQodGhpcy5fd2luLCBlbCk7XG4gICAgICAgIGxldCBuZXdWaXNpYmlsaXR5O1xuICAgICAgICBsZXQgZnVsbHlWaXNpYmxlID0gdGhpcy5fZnVsbHlWaXNpYmxlO1xuICAgICAgICBpZiAoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPj0gMC4yNSkge1xuICAgICAgICAgIG5ld1Zpc2liaWxpdHkgPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSAwLjc1ID8gVmlzaWJpbGl0aWVzLlZpc2libGUgOiBWaXNpYmlsaXRpZXMuUGFydGlhbGx5VmlzaWJsZTtcbiAgICAgICAgICBpZiAobmV3VmlzaWJpbGl0eSA9PT0gVmlzaWJpbGl0aWVzLlZpc2libGUpIHtcbiAgICAgICAgICAgIGZ1bGx5VmlzaWJsZSA9IGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWaXNpYmlsaXR5ID0gVmlzaWJpbGl0aWVzLkludmlzaWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZVtpZF0gIT09IG5ld1Zpc2liaWxpdHkpIHtcbiAgICAgICAgICBpZiAobmV3VmlzaWJpbGl0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmlzaWJsZVtpZF07XG4gICAgICAgICAgICBpZiAoZnVsbHlWaXNpYmxlID09PSBpZCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZnVsbHlWaXNpYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlW2lkXSA9IG5ld1Zpc2liaWxpdHk7XG4gICAgICAgICAgICB0aGlzLl9mdWxseVZpc2libGUgPSBmdWxseVZpc2libGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShlbCk7XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3ZlclN0YXRlRXZlbnQoc3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3dpbiA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMudmlzaWJpbGl0eVRvbGVyYW5jZSA9IChfYSA9IHByb3BzLnZpc2liaWxpdHlUb2xlcmFuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAuODtcbiAgICBpZiAodGhpcy5fcHJvcHMudHJhY2tTdGF0ZSB8fCB0aGlzLl9wcm9wcy52aXNpYmlsaXR5QXdhcmUpIHtcbiAgICAgIHRoaXMuX2ludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKHRoaXMuX29uSW50ZXJzZWN0aW9uLCB7XG4gICAgICAgIHRocmVzaG9sZDogWzAsIDAuMjUsIDAuNSwgMC43NSwgMV1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JzZXJ2ZVN0YXRlKCk7XG4gICAgfVxuICAgIHRoaXMuX29uRGlzcG9zZSA9IG9uRGlzcG9zZTtcbiAgICBjb25zdCBnZXRNZW1vcml6ZWQgPSAoKSA9PiBwcm9wcy5tZW1vcml6ZUN1cnJlbnQgPyB0aGlzLl9jdXJyZW50IDogdW5kZWZpbmVkO1xuICAgIGlmICghdGFic3Rlci5jb250cm9sVGFiKSB7XG4gICAgICB0aGlzLmR1bW15TWFuYWdlciA9IG5ldyBNb3ZlckR1bW15TWFuYWdlcih0aGlzLl9lbGVtZW50LCB0YWJzdGVyLCBnZXRNZW1vcml6ZWQsIHN5cyk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX29uRGlzcG9zZSh0aGlzKTtcbiAgICBpZiAodGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX2ludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX2N1cnJlbnQ7XG4gICAgZGVsZXRlIHRoaXMuX2Z1bGx5VmlzaWJsZTtcbiAgICBkZWxldGUgdGhpcy5fYWxsRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIGlmICh0aGlzLl91bm9ic2VydmUpIHtcbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3Vub2JzZXJ2ZTtcbiAgICB9XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgaWYgKHRoaXMuX3NldEN1cnJlbnRUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9zZXRDdXJyZW50VGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX3NldEN1cnJlbnRUaW1lcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuZHVtbXlNYW5hZ2VyO1xuICB9XG4gIHNldEN1cnJlbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gbmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl93aW4sIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuX3Byb3BzLnRyYWNrU3RhdGUgfHwgdGhpcy5fcHJvcHMudmlzaWJpbGl0eUF3YXJlKSAmJiAhdGhpcy5fc2V0Q3VycmVudFRpbWVyKSB7XG4gICAgICB0aGlzLl9zZXRDdXJyZW50VGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWxldGUgdGhpcy5fc2V0Q3VycmVudFRpbWVyO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gW107XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50ICE9PSB0aGlzLl9wcmV2Q3VycmVudCkge1xuICAgICAgICAgIGNoYW5nZWQucHVzaCh0aGlzLl9jdXJyZW50KTtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2godGhpcy5fcHJldkN1cnJlbnQpO1xuICAgICAgICAgIHRoaXMuX3ByZXZDdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHdlYWsgb2YgY2hhbmdlZCkge1xuICAgICAgICAgIGNvbnN0IGVsID0gd2VhayA9PT0gbnVsbCB8fCB3ZWFrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWFrLmdldCgpO1xuICAgICAgICAgIGlmIChlbCAmJiAoKF9hID0gdGhpcy5fYWxsRWxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZWwpKSA9PT0gdGhpcykge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIGlmIChlbCAmJiAocHJvcHMudmlzaWJpbGl0eUF3YXJlICE9PSB1bmRlZmluZWQgfHwgcHJvcHMudHJhY2tTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGVsKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgTW92ZXJTdGF0ZUV2ZW50KHN0YXRlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRDdXJyZW50KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuX2N1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKSkgfHwgbnVsbDtcbiAgfVxuICBmaW5kTmV4dFRhYmJhYmxlKGN1cnJlbnRFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50LCBpc0JhY2t3YXJkLCBpZ25vcmVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgY29uc3QgY3VycmVudElzRHVtbXkgPSBjb250YWluZXIgJiYgZ2V0RHVtbXlJbnB1dENvbnRhaW5lcihjdXJyZW50RWxlbWVudCkgPT09IGNvbnRhaW5lcjtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gbnVsbDtcbiAgICBsZXQgb3V0T2ZET01PcmRlciA9IGZhbHNlO1xuICAgIGxldCB1bmNvbnRyb2xsZWQ7XG4gICAgaWYgKHRoaXMuX3Byb3BzLnRhYmJhYmxlIHx8IGN1cnJlbnRJc0R1bW15IHx8IGN1cnJlbnRFbGVtZW50ICYmICFkb20ubm9kZUNvbnRhaW5zKGNvbnRhaW5lciwgY3VycmVudEVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBmaW5kUHJvcHMgPSB7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50LFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRQcm9wc091dCA9IHt9O1xuICAgICAgbmV4dCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlW2lzQmFja3dhcmQgPyBcImZpbmRQcmV2XCIgOiBcImZpbmROZXh0XCJdKGZpbmRQcm9wcywgZmluZFByb3BzT3V0KTtcbiAgICAgIG91dE9mRE9NT3JkZXIgPSAhIWZpbmRQcm9wc091dC5vdXRPZkRPTU9yZGVyO1xuICAgICAgdW5jb250cm9sbGVkID0gZmluZFByb3BzT3V0LnVuY29udHJvbGxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IG5leHQsXG4gICAgICB1bmNvbnRyb2xsZWQsXG4gICAgICBvdXRPZkRPTU9yZGVyXG4gICAgfTtcbiAgfVxuICBhY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIUZvY3VzZWRFbGVtZW50U3RhdGUuaXNUYWJiaW5nKSB7XG4gICAgICByZXR1cm4gKChfYSA9IHN0YXRlLmN1cnJlbnRDdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGNsdWRlZEZyb21Nb3ZlcikgPyBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1lbW9yaXplQ3VycmVudCxcbiAgICAgIHZpc2liaWxpdHlBd2FyZSxcbiAgICAgIGhhc0RlZmF1bHQgPSB0cnVlXG4gICAgfSA9IHRoaXMuX3Byb3BzO1xuICAgIGNvbnN0IG1vdmVyRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGlmIChtb3ZlckVsZW1lbnQgJiYgKG1lbW9yaXplQ3VycmVudCB8fCB2aXNpYmlsaXR5QXdhcmUgfHwgaGFzRGVmYXVsdCkgJiYgKCFkb20ubm9kZUNvbnRhaW5zKG1vdmVyRWxlbWVudCwgc3RhdGUuZnJvbSkgfHwgZ2V0RHVtbXlJbnB1dENvbnRhaW5lcihzdGF0ZS5mcm9tKSA9PT0gbW92ZXJFbGVtZW50KSkge1xuICAgICAgbGV0IGZvdW5kO1xuICAgICAgaWYgKG1lbW9yaXplQ3VycmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gKF9iID0gdGhpcy5fY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCgpO1xuICAgICAgICBpZiAoY3VycmVudCAmJiBzdGF0ZS5hY2NlcHRDb25kaXRpb24oY3VycmVudCkpIHtcbiAgICAgICAgICBmb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQgJiYgaGFzRGVmYXVsdCkge1xuICAgICAgICBmb3VuZCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmZpbmREZWZhdWx0KHtcbiAgICAgICAgICBjb250YWluZXI6IG1vdmVyRWxlbWVudCxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kICYmIHZpc2liaWxpdHlBd2FyZSkge1xuICAgICAgICBmb3VuZCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmZpbmRFbGVtZW50KHtcbiAgICAgICAgICBjb250YWluZXI6IG1vdmVyRWxlbWVudCxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWUsXG4gICAgICAgICAgaXNCYWNrd2FyZDogc3RhdGUuaXNCYWNrd2FyZCxcbiAgICAgICAgICBhY2NlcHRDb25kaXRpb246IGVsID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0RWxlbWVudFVJZCh0aGlzLl93aW4sIGVsKTtcbiAgICAgICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmxlW2lkXTtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlckVsZW1lbnQgIT09IGVsICYmICEhKChfYSA9IHRoaXMuX2FsbEVsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGVsKSkgJiYgc3RhdGUuYWNjZXB0Q29uZGl0aW9uKGVsKSAmJiAodmlzaWJpbGl0eSA9PT0gVmlzaWJpbGl0aWVzLlZpc2libGUgfHwgdmlzaWJpbGl0eSA9PT0gVmlzaWJpbGl0aWVzLlBhcnRpYWxseVZpc2libGUgJiYgKHZpc2liaWxpdHlBd2FyZSA9PT0gVmlzaWJpbGl0aWVzLlBhcnRpYWxseVZpc2libGUgfHwgIXRoaXMuX2Z1bGx5VmlzaWJsZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgc3RhdGUuZm91bmQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5mb3VuZEVsZW1lbnQgPSBmb3VuZDtcbiAgICAgICAgc3RhdGUucmVqZWN0RWxlbWVudHNGcm9tID0gbW92ZXJFbGVtZW50O1xuICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBfb2JzZXJ2ZVN0YXRlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBpZiAodGhpcy5fdW5vYnNlcnZlIHx8ICFlbGVtZW50IHx8IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gdGhpcy5fYWxsRWxlbWVudHMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHRhYnN0ZXJGb2N1c2FibGUgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZTtcbiAgICBsZXQgdXBkYXRlUXVldWUgPSB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdO1xuICAgIGNvbnN0IG9ic2VydmVyID0gZG9tLmNyZWF0ZU11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcbiAgICAgICAgY29uc3QgYWRkZWQgPSBtdXRhdGlvbi5hZGRlZE5vZGVzO1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJ0YWJpbmRleFwiKSB7XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgICB0eXBlOiBfbW92ZXJVcGRhdGVBdHRyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogcmVtb3ZlZFtpXSxcbiAgICAgICAgICAgICAgdHlwZTogX21vdmVyVXBkYXRlUmVtb3ZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IGFkZGVkW2ldLFxuICAgICAgICAgICAgICB0eXBlOiBfbW92ZXJVcGRhdGVBZGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoZWxlbWVudCwgcmVtb3ZlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgY3VycmVudCA9IGFsbEVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgIGlmIChjdXJyZW50ICYmIHJlbW92ZSkge1xuICAgICAgICAoX2EgPSB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgYWxsRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50ICYmICFyZW1vdmUpIHtcbiAgICAgICAgYWxsRWxlbWVudHMuc2V0KGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAoX2IgPSB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVFbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBpc0ZvY3VzYWJsZSA9IHRhYnN0ZXJGb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBjdXJyZW50ID0gYWxsRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKCFpc0ZvY3VzYWJsZSkge1xuICAgICAgICAgIHNldEVsZW1lbnQoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0ZvY3VzYWJsZSkge1xuICAgICAgICAgIHNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFkZE5ld0VsZW1lbnRzID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1vdmVyXG4gICAgICB9ID0gZ2V0TW92ZXJHcm91cHBlcihlbGVtZW50KTtcbiAgICAgIGlmIChtb3ZlciAmJiBtb3ZlciAhPT0gdGhpcykge1xuICAgICAgICBpZiAobW92ZXIuZ2V0RWxlbWVudCgpID09PSBlbGVtZW50ICYmIHRhYnN0ZXJGb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2Fsa2VyID0gY3JlYXRlRWxlbWVudFRyZWVXYWxrZXIod2luLmRvY3VtZW50LCBlbGVtZW50LCBub2RlID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1vdmVyLFxuICAgICAgICAgIGdyb3VwcGVyXG4gICAgICAgIH0gPSBnZXRNb3Zlckdyb3VwcGVyKG5vZGUpO1xuICAgICAgICBpZiAobW92ZXIgJiYgbW92ZXIgIT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwcGVyRmlyc3RGb2N1c2FibGUgPSBncm91cHBlciA9PT0gbnVsbCB8fCBncm91cHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBwZXIuZ2V0Rmlyc3QodHJ1ZSk7XG4gICAgICAgIGlmIChncm91cHBlciAmJiBncm91cHBlci5nZXRFbGVtZW50KCkgIT09IG5vZGUgJiYgZ3JvdXBwZXJGaXJzdEZvY3VzYWJsZSAmJiBncm91cHBlckZpcnN0Rm9jdXNhYmxlICE9PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFic3RlckZvY3VzYWJsZS5pc0ZvY3VzYWJsZShub2RlKSkge1xuICAgICAgICAgIHNldEVsZW1lbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICB9KTtcbiAgICAgIGlmICh3YWxrZXIpIHtcbiAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgLyogSXRlcmF0aW5nIGZvciB0aGUgc2FrZSBvZiBjYWxsaW5nIHByb2Nlc3NOb2RlKCkgY2FsbGJhY2suICovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVdhbGsgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBhbGxFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnQsIHRydWUpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgZWwgPSBkb20uZ2V0Rmlyc3RFbGVtZW50Q2hpbGQoZWxlbWVudCk7IGVsOyBlbCA9IGRvbS5nZXROZXh0RWxlbWVudFNpYmxpbmcoZWwpKSB7XG4gICAgICAgIHJlbW92ZVdhbGsoZWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fdXBkYXRlVGltZXIgJiYgdXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gd2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSBvZiB1cGRhdGVRdWV1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgX21vdmVyVXBkYXRlQXR0cjpcbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9tb3ZlclVwZGF0ZUFkZDpcbiAgICAgICAgICAgICAgICBhZGROZXdFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfbW92ZXJVcGRhdGVSZW1vdmU6XG4gICAgICAgICAgICAgICAgcmVtb3ZlV2FsayhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldE1vdmVyR3JvdXBwZXIgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgZm9yIChsZXQgZWwgPSBlbGVtZW50OyBlbDsgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbCkpIHtcbiAgICAgICAgY29uc3QgdG9lID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlbCk7XG4gICAgICAgIGlmICh0b2UpIHtcbiAgICAgICAgICBpZiAodG9lLmdyb3VwcGVyICYmICFyZXQuZ3JvdXBwZXIpIHtcbiAgICAgICAgICAgIHJldC5ncm91cHBlciA9IHRvZS5ncm91cHBlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvZS5tb3Zlcikge1xuICAgICAgICAgICAgcmV0Lm1vdmVyID0gdG9lLm1vdmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgICBlbGVtZW50LFxuICAgICAgdHlwZTogX21vdmVyVXBkYXRlQWRkXG4gICAgfSk7XG4gICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcInRhYmluZGV4XCJdXG4gICAgfSk7XG4gICAgdGhpcy5fdW5vYnNlcnZlID0gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH1cbiAgZ2V0U3RhdGUoZWxlbWVudCkge1xuICAgIGNvbnN0IGlkID0gZ2V0RWxlbWVudFVJZCh0aGlzLl93aW4sIGVsZW1lbnQpO1xuICAgIGlmIChpZCBpbiB0aGlzLl92aXNpYmxlKSB7XG4gICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJsZVtpZF0gfHwgVmlzaWJpbGl0aWVzLkludmlzaWJsZTtcbiAgICAgIGNvbnN0IGlzQ3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPyB0aGlzLl9jdXJyZW50LmdldCgpID09PSBlbGVtZW50IDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNDdXJyZW50LFxuICAgICAgICB2aXNpYmlsaXR5XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgZGlzdGFuY2UgYmV0d2VlbiB0d28gcmVjdGFuZ2xlcy5cbiAqXG4gKiBAcGFyYW0gYXgxIGZpcnN0IHJlY3RhbmdsZSBsZWZ0XG4gKiBAcGFyYW0gYXkxIGZpcnN0IHJlY3RhbmdsZSB0b3BcbiAqIEBwYXJhbSBheDIgZmlyc3QgcmVjdGFuZ2xlIHJpZ2h0XG4gKiBAcGFyYW0gYXkyIGZpcnN0IHJlY3RhbmdsZSBib3R0b21cbiAqIEBwYXJhbSBieDEgc2Vjb25kIHJlY3RhbmdsZSBsZWZ0XG4gKiBAcGFyYW0gYnkxIHNlY29uZCByZWN0YW5nbGUgdG9wXG4gKiBAcGFyYW0gYngyIHNlY29uZCByZWN0YW5nbGUgcmlnaHRcbiAqIEBwYXJhbSBieTIgc2Vjb25kIHJlY3RhbmdsZSBib3R0b21cbiAqIEByZXR1cm5zIG51bWJlciwgc2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmVjdGFuZ2xlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UoYXgxLCBheTEsIGF4MiwgYXkyLCBieDEsIGJ5MSwgYngyLCBieTIpIHtcbiAgY29uc3QgeERpc3RhbmNlID0gYXgyIDwgYngxID8gYngxIC0gYXgyIDogYngyIDwgYXgxID8gYXgxIC0gYngyIDogMDtcbiAgY29uc3QgeURpc3RhbmNlID0gYXkyIDwgYnkxID8gYnkxIC0gYXkyIDogYnkyIDwgYXkxID8gYXkxIC0gYnkyIDogMDtcbiAgcmV0dXJuIHhEaXN0YW5jZSA9PT0gMCA/IHlEaXN0YW5jZSA6IHlEaXN0YW5jZSA9PT0gMCA/IHhEaXN0YW5jZSA6IE1hdGguc3FydCh4RGlzdGFuY2UgKiB4RGlzdGFuY2UgKyB5RGlzdGFuY2UgKiB5RGlzdGFuY2UpO1xufVxuY2xhc3MgTW92ZXJBUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBnZXRXaW5kb3cpIHtcbiAgICB0aGlzLl9pbml0ID0gKCkgPT4ge1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKE1vdmVyTW92ZUZvY3VzRXZlbnROYW1lLCB0aGlzLl9vbk1vdmVGb2N1cyk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudE5hbWUsIHRoaXMuX29uTWVtb3JpemVkRWxlbWVudCk7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTW92ZXJEaXNwb3NlID0gbW92ZXIgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX21vdmVyc1ttb3Zlci5pZF07XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBXaGVuIHNvbWV0aGluZyBpbiB0aGUgYXBwIGdldHMgZm9jdXNlZCwgd2UgYXJlIG1ha2luZyBzdXJlIHRoYXRcbiAgICAgIC8vIHRoZSByZWxldmFudCBjb250ZXh0IE1vdmVyIGlzIGF3YXJlIG9mIGl0LlxuICAgICAgLy8gTG9va2luZyBmb3IgdGhlIHJlbGV2YW50IGNvbnRleHQgTW92ZXIgZnJvbSB0aGUgY3VycmVudGx5XG4gICAgICAvLyBmb2N1c2VkIGVsZW1lbnQgcGFyZW50LCBub3QgZnJvbSB0aGUgZWxlbWVudCBpdHNlbGYsIGJlY2F1c2UgdGhlXG4gICAgICAvLyBNb3ZlciBlbGVtZW50IGl0c2VsZiBjYW5ub3QgYmUgaXRzIG93biBjdXJyZW50IChidXQgbWlnaHQgYmVcbiAgICAgIC8vIGN1cnJlbnQgZm9yIGl0cyBwYXJlbnQgTW92ZXIpLlxuICAgICAgbGV0IGN1cnJlbnRGb2N1c2FibGVFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIGxldCBkZWVwZXN0Rm9jdXNhYmxlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGxldCBlbCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpOyBlbDsgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbCkpIHtcbiAgICAgICAgLy8gV2UgZ28gdGhyb3VnaCBhbGwgTW92ZXJzIHVwIGZyb20gdGhlIGZvY3VzZWQgZWxlbWVudCBhbmRcbiAgICAgICAgLy8gc2V0IHRoZWlyIGN1cnJlbnQgZWxlbWVudCB0byB0aGUgZGVlcGVzdCBmb2N1c2FibGUgb2YgdGhhdFxuICAgICAgICAvLyBNb3Zlci5cbiAgICAgICAgY29uc3QgbW92ZXIgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVyO1xuICAgICAgICBpZiAobW92ZXIpIHtcbiAgICAgICAgICBtb3Zlci5zZXRDdXJyZW50KGRlZXBlc3RGb2N1c2FibGVFbGVtZW50KTtcbiAgICAgICAgICBjdXJyZW50Rm9jdXNhYmxlRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRGb2N1c2FibGVFbGVtZW50ICYmIHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICAgIGN1cnJlbnRGb2N1c2FibGVFbGVtZW50ID0gZGVlcGVzdEZvY3VzYWJsZUVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25LZXlEb3duID0gYXN5bmMgZXZlbnQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyKSB7XG4gICAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcjtcbiAgICAgIH1cbiAgICAgIChfYSA9IHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgIC8vIEdpdmUgYSBjaGFuY2UgdG8gb3RoZXIgbGlzdGVuZXJzIHRvIGhhbmRsZSB0aGUgZXZlbnQgKGZvciBleGFtcGxlLFxuICAgICAgLy8gdG8gc2Nyb2xsIGluc3RlYWQgb2YgbW92aW5nIGZvY3VzKS5cbiAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcbiAgICAgIGxldCBtb3ZlcktleTtcbiAgICAgIGlmIChrZXkgPT09IEtleXMuQXJyb3dEb3duKSB7XG4gICAgICAgIG1vdmVyS2V5ID0gTW92ZXJLZXlzLkFycm93RG93bjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLZXlzLkFycm93UmlnaHQpIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuQXJyb3dSaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLZXlzLkFycm93VXApIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuQXJyb3dVcDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLZXlzLkFycm93TGVmdCkge1xuICAgICAgICBtb3ZlcktleSA9IE1vdmVyS2V5cy5BcnJvd0xlZnQ7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5QYWdlRG93bikge1xuICAgICAgICBtb3ZlcktleSA9IE1vdmVyS2V5cy5QYWdlRG93bjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLZXlzLlBhZ2VVcCkge1xuICAgICAgICBtb3ZlcktleSA9IE1vdmVyS2V5cy5QYWdlVXA7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5Ib21lKSB7XG4gICAgICAgIG1vdmVyS2V5ID0gTW92ZXJLZXlzLkhvbWU7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5FbmQpIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuRW5kO1xuICAgICAgfVxuICAgICAgaWYgKCFtb3ZlcktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgaWYgKCFmb2N1c2VkIHx8IChhd2FpdCB0aGlzLl9pc0lnbm9yZWRJbnB1dChmb2N1c2VkLCBrZXkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3ZlRm9jdXMoZm9jdXNlZCwgbW92ZXJLZXksIGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMuX29uTW92ZUZvY3VzID0gZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgIGNvbnN0IGtleSA9IChfYSA9IGUuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eua2V5O1xuICAgICAgaWYgKGVsZW1lbnQgJiYga2V5ICE9PSB1bmRlZmluZWQgJiYgIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICB0aGlzLl9tb3ZlRm9jdXMoZWxlbWVudCwga2V5KTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uTWVtb3JpemVkRWxlbWVudCA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgIGxldCBtZW1vcml6ZWRFbGVtZW50ID0gKF9hID0gZS5kZXRhaWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1vcml6ZWRFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIHRhcmdldCk7XG4gICAgICAgIGNvbnN0IG1vdmVyID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vdmVyO1xuICAgICAgICBpZiAobW92ZXIpIHtcbiAgICAgICAgICBpZiAobWVtb3JpemVkRWxlbWVudCAmJiAhZG9tLm5vZGVDb250YWlucyhtb3Zlci5nZXRFbGVtZW50KCksIG1lbW9yaXplZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICBtZW1vcml6ZWRFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3Zlci5zZXRDdXJyZW50KG1lbW9yaXplZEVsZW1lbnQpO1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3dpbiA9IGdldFdpbmRvdztcbiAgICB0aGlzLl9tb3ZlcnMgPSB7fTtcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCh0aGlzLl9pbml0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnVuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgIChfYSA9IHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5faWdub3JlZElucHV0VGltZXIpIHtcbiAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5faWdub3JlZElucHV0VGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyO1xuICAgIH1cbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihNb3Zlck1vdmVGb2N1c0V2ZW50TmFtZSwgdGhpcy5fb25Nb3ZlRm9jdXMpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50TmFtZSwgdGhpcy5fb25NZW1vcml6ZWRFbGVtZW50KTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9tb3ZlcnMpLmZvckVhY2gobW92ZXJJZCA9PiB7XG4gICAgICBpZiAodGhpcy5fbW92ZXJzW21vdmVySWRdKSB7XG4gICAgICAgIHRoaXMuX21vdmVyc1ttb3ZlcklkXS5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb3ZlcnNbbW92ZXJJZF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlTW92ZXIoZWxlbWVudCwgcHJvcHMsIHN5cykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgO1xuICAgIGNvbnN0IG5ld01vdmVyID0gbmV3IE1vdmVyKHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQsIHRoaXMuX29uTW92ZXJEaXNwb3NlLCBwcm9wcywgc3lzKTtcbiAgICB0aGlzLl9tb3ZlcnNbbmV3TW92ZXIuaWRdID0gbmV3TW92ZXI7XG4gICAgcmV0dXJuIG5ld01vdmVyO1xuICB9XG4gIG1vdmVGb2N1cyhmcm9tRWxlbWVudCwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmVGb2N1cyhmcm9tRWxlbWVudCwga2V5KTtcbiAgfVxuICBfbW92ZUZvY3VzKGZyb21FbGVtZW50LCBrZXksIHJlbGF0ZWRFdmVudCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBmcm9tRWxlbWVudCwge1xuICAgICAgY2hlY2tSdGw6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWN0eCB8fCAhY3R4Lm1vdmVyIHx8IGN0eC5leGNsdWRlZEZyb21Nb3ZlciB8fCByZWxhdGVkRXZlbnQgJiYgY3R4Lmlnbm9yZUtleWRvd24ocmVsYXRlZEV2ZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1vdmVyID0gY3R4Lm1vdmVyO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG1vdmVyLmdldEVsZW1lbnQoKTtcbiAgICBpZiAoY3R4Lmdyb3VwcGVyQmVmb3JlTW92ZXIpIHtcbiAgICAgIGNvbnN0IGdyb3VwcGVyID0gY3R4Lmdyb3VwcGVyO1xuICAgICAgaWYgKGdyb3VwcGVyICYmICFncm91cHBlci5pc0FjdGl2ZSh0cnVlKSkge1xuICAgICAgICAvLyBGb3IgdGhlIGNhc2VzIHdoZW4gd2UgaGF2ZSBNb3Zlci9BY3RpdmUgR3JvdXBwZXIvSW5hY3RpdmUgR3JvdXBwZXIsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgLy8gdGhlIGdyb3VwcGVycyBiZXR3ZWVuIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIHRoZSBjdXJyZW50IG1vdmVyLlxuICAgICAgICBmb3IgKGxldCBlbCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGdyb3VwcGVyLmdldEVsZW1lbnQoKSk7IGVsICYmIGVsICE9PSBjb250YWluZXI7IGVsID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgaWYgKChfYiA9IChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JvdXBwZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0FjdGl2ZSh0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c2FibGUgPSB0YWJzdGVyLmZvY3VzYWJsZTtcbiAgICBjb25zdCBtb3ZlclByb3BzID0gbW92ZXIuZ2V0UHJvcHMoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBtb3ZlclByb3BzLmRpcmVjdGlvbiB8fCBNb3ZlckRpcmVjdGlvbnMuQm90aDtcbiAgICBjb25zdCBpc0JvdGggPSBkaXJlY3Rpb24gPT09IE1vdmVyRGlyZWN0aW9ucy5Cb3RoO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBpc0JvdGggfHwgZGlyZWN0aW9uID09PSBNb3ZlckRpcmVjdGlvbnMuVmVydGljYWw7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gaXNCb3RoIHx8IGRpcmVjdGlvbiA9PT0gTW92ZXJEaXJlY3Rpb25zLkhvcml6b250YWw7XG4gICAgY29uc3QgaXNHcmlkTGluZWFyID0gZGlyZWN0aW9uID09PSBNb3ZlckRpcmVjdGlvbnMuR3JpZExpbmVhcjtcbiAgICBjb25zdCBpc0dyaWQgPSBpc0dyaWRMaW5lYXIgfHwgZGlyZWN0aW9uID09PSBNb3ZlckRpcmVjdGlvbnMuR3JpZDtcbiAgICBjb25zdCBpc0N5Y2xpYyA9IG1vdmVyUHJvcHMuY3ljbGljO1xuICAgIGxldCBuZXh0O1xuICAgIGxldCBzY3JvbGxJbnRvVmlld0FyZztcbiAgICBsZXQgZm9jdXNlZEVsZW1lbnRSZWN0O1xuICAgIGxldCBmb2N1c2VkRWxlbWVudFgxID0gMDtcbiAgICBsZXQgZm9jdXNlZEVsZW1lbnRYMiA9IDA7XG4gICAgaWYgKGlzR3JpZCkge1xuICAgICAgZm9jdXNlZEVsZW1lbnRSZWN0ID0gZnJvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBmb2N1c2VkRWxlbWVudFgxID0gTWF0aC5jZWlsKGZvY3VzZWRFbGVtZW50UmVjdC5sZWZ0KTtcbiAgICAgIGZvY3VzZWRFbGVtZW50WDIgPSBNYXRoLmZsb29yKGZvY3VzZWRFbGVtZW50UmVjdC5yaWdodCk7XG4gICAgfVxuICAgIGlmIChjdHgucnRsKSB7XG4gICAgICBpZiAoa2V5ID09PSBNb3ZlcktleXMuQXJyb3dSaWdodCkge1xuICAgICAgICBrZXkgPSBNb3ZlcktleXMuQXJyb3dMZWZ0O1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IE1vdmVyS2V5cy5BcnJvd0xlZnQpIHtcbiAgICAgICAga2V5ID0gTW92ZXJLZXlzLkFycm93UmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXkgPT09IE1vdmVyS2V5cy5BcnJvd0Rvd24gJiYgaXNWZXJ0aWNhbCB8fCBrZXkgPT09IE1vdmVyS2V5cy5BcnJvd1JpZ2h0ICYmIChpc0hvcml6b250YWwgfHwgaXNHcmlkKSkge1xuICAgICAgbmV4dCA9IGZvY3VzYWJsZS5maW5kTmV4dCh7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50OiBmcm9tRWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG5leHQgJiYgaXNHcmlkKSB7XG4gICAgICAgIGNvbnN0IG5leHRFbGVtZW50WDEgPSBNYXRoLmNlaWwobmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgaWYgKCFpc0dyaWRMaW5lYXIgJiYgZm9jdXNlZEVsZW1lbnRYMiA+IG5leHRFbGVtZW50WDEpIHtcbiAgICAgICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGlzQ3ljbGljKSB7XG4gICAgICAgIG5leHQgPSBmb2N1c2FibGUuZmluZEZpcnN0KHtcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuQXJyb3dVcCAmJiBpc1ZlcnRpY2FsIHx8IGtleSA9PT0gTW92ZXJLZXlzLkFycm93TGVmdCAmJiAoaXNIb3Jpem9udGFsIHx8IGlzR3JpZCkpIHtcbiAgICAgIG5leHQgPSBmb2N1c2FibGUuZmluZFByZXYoe1xuICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChuZXh0ICYmIGlzR3JpZCkge1xuICAgICAgICBjb25zdCBuZXh0RWxlbWVudFgyID0gTWF0aC5mbG9vcihuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KTtcbiAgICAgICAgaWYgKCFpc0dyaWRMaW5lYXIgJiYgbmV4dEVsZW1lbnRYMiA+IGZvY3VzZWRFbGVtZW50WDEpIHtcbiAgICAgICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFuZXh0ICYmIGlzQ3ljbGljKSB7XG4gICAgICAgIG5leHQgPSBmb2N1c2FibGUuZmluZExhc3Qoe1xuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IE1vdmVyS2V5cy5Ib21lKSB7XG4gICAgICBpZiAoaXNHcmlkKSB7XG4gICAgICAgIGZvY3VzYWJsZS5maW5kRWxlbWVudCh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRFbGVtZW50OiBmcm9tRWxlbWVudCxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWUsXG4gICAgICAgICAgaXNCYWNrd2FyZDogdHJ1ZSxcbiAgICAgICAgICBhY2NlcHRDb25kaXRpb246IGVsID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0RWxlbWVudFgxID0gTWF0aC5jZWlsKChfYSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgICAgICAgICAgaWYgKGVsICE9PSBmcm9tRWxlbWVudCAmJiBmb2N1c2VkRWxlbWVudFgxIDw9IG5leHRFbGVtZW50WDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQgPSBmb2N1c2FibGUuZmluZEZpcnN0KHtcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuRW5kKSB7XG4gICAgICBpZiAoaXNHcmlkKSB7XG4gICAgICAgIGZvY3VzYWJsZS5maW5kRWxlbWVudCh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRFbGVtZW50OiBmcm9tRWxlbWVudCxcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWUsXG4gICAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRYMSA9IE1hdGguY2VpbCgoX2EgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZnJvbUVsZW1lbnQgJiYgZm9jdXNlZEVsZW1lbnRYMSA+PSBuZXh0RWxlbWVudFgxKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGVsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gZm9jdXNhYmxlLmZpbmRMYXN0KHtcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuUGFnZVVwKSB7XG4gICAgICBmb2N1c2FibGUuZmluZEVsZW1lbnQoe1xuICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICBpc0JhY2t3YXJkOiB0cnVlLFxuICAgICAgICBhY2NlcHRDb25kaXRpb246IGVsID0+IHtcbiAgICAgICAgICBpZiAoIWZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRWxlbWVudFZlcnRpY2FsbHlWaXNpYmxlSW5Db250YWluZXIodGhpcy5fd2luLCBlbCwgbW92ZXIudmlzaWJpbGl0eVRvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgIG5leHQgPSBlbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gd2lsbCBiZSBvbiB0aGUgZmlyc3QgY29sdW1uIG1vdmUgZm9yd2FyZCBhbmQgcHJlc2VydmUgcHJldmlvdXMgY29sdW1uXG4gICAgICBpZiAoaXNHcmlkICYmIG5leHQpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDb2x1bW5YMSA9IE1hdGguY2VpbChuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpO1xuICAgICAgICBmb2N1c2FibGUuZmluZEVsZW1lbnQoe1xuICAgICAgICAgIGN1cnJlbnRFbGVtZW50OiBuZXh0LFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWUsXG4gICAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRYMSA9IE1hdGguY2VpbChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkRWxlbWVudFgxIDwgbmV4dEVsZW1lbnRYMSB8fCBmaXJzdENvbHVtblgxID49IG5leHRFbGVtZW50WDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEludG9WaWV3QXJnID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IE1vdmVyS2V5cy5QYWdlRG93bikge1xuICAgICAgZm9jdXNhYmxlLmZpbmRFbGVtZW50KHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQ6IGZyb21FbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZSxcbiAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgaWYgKCFmb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VsZW1lbnRWZXJ0aWNhbGx5VmlzaWJsZUluQ29udGFpbmVyKHRoaXMuX3dpbiwgZWwsIG1vdmVyLnZpc2liaWxpdHlUb2xlcmFuY2UpKSB7XG4gICAgICAgICAgICBuZXh0ID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHdpbGwgYmUgb24gdGhlIGxhc3QgY29sdW1uIG1vdmUgYmFja3dhcmRzIGFuZCBwcmVzZXJ2ZSBwcmV2aW91cyBjb2x1bW5cbiAgICAgIGlmIChpc0dyaWQgJiYgbmV4dCkge1xuICAgICAgICBjb25zdCBsYXN0Q29sdW1uWDEgPSBNYXRoLmNlaWwobmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgZm9jdXNhYmxlLmZpbmRFbGVtZW50KHtcbiAgICAgICAgICBjdXJyZW50RWxlbWVudDogbmV4dCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICAgIGlzQmFja3dhcmQ6IHRydWUsXG4gICAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRYMSA9IE1hdGguY2VpbChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkRWxlbWVudFgxID4gbmV4dEVsZW1lbnRYMSB8fCBsYXN0Q29sdW1uWDEgPD0gbmV4dEVsZW1lbnRYMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBlbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2Nyb2xsSW50b1ZpZXdBcmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNHcmlkKSB7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0ga2V5ID09PSBNb3ZlcktleXMuQXJyb3dVcDtcbiAgICAgIGNvbnN0IGF4MSA9IGZvY3VzZWRFbGVtZW50WDE7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgY29uc3QgYXkxID0gTWF0aC5jZWlsKGZvY3VzZWRFbGVtZW50UmVjdC50b3ApO1xuICAgICAgY29uc3QgYXgyID0gZm9jdXNlZEVsZW1lbnRYMjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBheTIgPSBNYXRoLmZsb29yKGZvY3VzZWRFbGVtZW50UmVjdC5ib3R0b20pO1xuICAgICAgbGV0IHRhcmdldEVsZW1lbnQ7XG4gICAgICBsZXQgbGFzdERpc3RhbmNlO1xuICAgICAgbGV0IGxhc3RJbnRlcnNlY3Rpb24gPSAwO1xuICAgICAgZm9jdXNhYmxlLmZpbmRBbGwoe1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50OiBmcm9tRWxlbWVudCxcbiAgICAgICAgaXNCYWNrd2FyZCxcbiAgICAgICAgb25FbGVtZW50OiBlbCA9PiB7XG4gICAgICAgICAgLy8gRmluZCBlbGVtZW50IHdoaWNoIGhhcyBtYXhpbWFsIGludGVyc2VjdGlvbiB3aXRoIHRoZSBmb2N1c2VkIGVsZW1lbnQgaG9yaXpvbnRhbGx5LFxuICAgICAgICAgIC8vIG9yIHRoZSBjbG9zZXN0IG9uZS5cbiAgICAgICAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgY29uc3QgYngxID0gTWF0aC5jZWlsKHJlY3QubGVmdCk7XG4gICAgICAgICAgY29uc3QgYnkxID0gTWF0aC5jZWlsKHJlY3QudG9wKTtcbiAgICAgICAgICBjb25zdCBieDIgPSBNYXRoLmZsb29yKHJlY3QucmlnaHQpO1xuICAgICAgICAgIGNvbnN0IGJ5MiA9IE1hdGguZmxvb3IocmVjdC5ib3R0b20pO1xuICAgICAgICAgIGlmIChpc0JhY2t3YXJkICYmIGF5MSA8IGJ5MiB8fCAhaXNCYWNrd2FyZCAmJiBheTIgPiBieTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgZWxlbWVudHMgd2hpY2ggYXJlIGJlbG93L2Fib3ZlIGN1cnJldGx5IGZvY3VzZWQuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeEludGVyc2VjdGlvbldpZHRoID0gTWF0aC5jZWlsKE1hdGgubWluKGF4MiwgYngyKSkgLSBNYXRoLmZsb29yKE1hdGgubWF4KGF4MSwgYngxKSk7XG4gICAgICAgICAgY29uc3QgbWluV2lkdGggPSBNYXRoLmNlaWwoTWF0aC5taW4oYXgyIC0gYXgxLCBieDIgLSBieDEpKTtcbiAgICAgICAgICBpZiAoeEludGVyc2VjdGlvbldpZHRoID4gMCAmJiBtaW5XaWR0aCA+PSB4SW50ZXJzZWN0aW9uV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIEVsZW1lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBmb2N1c2VkIGVsZW1lbnQgb24gWCBheGlzLlxuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0geEludGVyc2VjdGlvbldpZHRoIC8gbWluV2lkdGg7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uID4gbGFzdEludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gZWw7XG4gICAgICAgICAgICAgIGxhc3RJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0SW50ZXJzZWN0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgaGF2ZSBpbnRlcnNlY3Rpb24sIHRyeSBqdXN0IHRoZSBjbG9zZXN0IG9uZS5cbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZ2V0RGlzdGFuY2UoYXgxLCBheTEsIGF4MiwgYXkyLCBieDEsIGJ5MSwgYngyLCBieTIpO1xuICAgICAgICAgICAgaWYgKGxhc3REaXN0YW5jZSA9PT0gdW5kZWZpbmVkIHx8IGRpc3RhbmNlIDwgbGFzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0SW50ZXJzZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgLy8gRWxlbWVudCBkb2Vzbid0IGludGVyc2VjdCwgYnV0IHdlIGhhZCBpbnRlcnNlY3Rpb24gYWxyZWFkeSwgc3RvcCBzZWFyY2guXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5leHQgPSB0YXJnZXRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAobmV4dCAmJiAoIXJlbGF0ZWRFdmVudCB8fCByZWxhdGVkRXZlbnQgJiYgY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IFRhYnN0ZXJNb3ZlRm9jdXNFdmVudCh7XG4gICAgICBieTogXCJtb3ZlclwiLFxuICAgICAgb3duZXI6IGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICByZWxhdGVkRXZlbnRcbiAgICB9KSkpKSB7XG4gICAgICBpZiAoc2Nyb2xsSW50b1ZpZXdBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLl93aW4sIG5leHQsIHNjcm9sbEludG9WaWV3QXJnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxhdGVkRXZlbnQpIHtcbiAgICAgICAgcmVsYXRlZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJlbGF0ZWRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvY3VzKG5leHQpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFzeW5jIF9pc0lnbm9yZWRJbnB1dChlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpID09PSBcInRydWVcIiAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKSkge1xuICAgICAgLy8gSXQgaXMgbGlrZWx5IGEgY29tYm9ib3ggd2l0aCBleHBhbmRlZCBvcHRpb25zIGFuZCBhcnJvdyBrZXlzIGFyZVxuICAgICAgLy8gY29udHJvbGxlZCBieSBpdC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIF9pbnB1dFNlbGVjdG9yKSkge1xuICAgICAgbGV0IHNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIGxldCBzZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgbGV0IHRleHRMZW5ndGggPSAwO1xuICAgICAgbGV0IGFzeW5jUmV0O1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJTlBVVFwiIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgdGV4dExlbmd0aCA9ICh2YWx1ZSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlID09PSBcImVtYWlsXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIC8vIEZvciB0aGVzZSB0eXBlcyBDaHJvbWl1bSBkb2Vzbid0IHByb3ZpZGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZC5cbiAgICAgICAgICAvLyBIZW5jZSB0aGUgdWdseSB3b3JrYXJvdW5kIHRvIGZpbmQgaWYgdGhlIGNhcmV0IHBvc2l0aW9uIGlzIGNoYW5nZWQgd2l0aFxuICAgICAgICAgIC8vIHRoZSBrZXlwcmVzcy5cbiAgICAgICAgICAvLyBUT0RPOiBIYXZlIGEgbG9vayBhdCByYW5nZSwgd2VlaywgdGltZSwgdGltZSwgZGF0ZSwgZGF0ZXRpbWUtbG9jYWwuXG4gICAgICAgICAgaWYgKHRleHRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvbS5nZXRTZWxlY3Rpb24oZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBrZXkgPT09IEtleXMuQXJyb3dMZWZ0IHx8IGtleSA9PT0gS2V5cy5BcnJvd1VwO1xuICAgICAgICAgICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIGlzQmFja3dhcmQgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsTGVuZ3RoICE9PSBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FyZXQgaXMgbW92ZWQsIHNvLCB3ZSdyZSBub3Qgb24gdGhlIGVkZ2Ugb2YgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgaXNCYWNrd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzZWxTdGFydCA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgaWYgKHNlbFN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgaWdub3JlIG5vdCB0ZXh0IGVkaXRhYmxlIGlucHV0cyBsaWtlIGNoZWNrYm94ZXMgYW5kIHJhZGlvcyAoYnV0IGlnbm9yZSBoaWRkZW4pLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsU3RhcnQgfHwgMDtcbiAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBlbGVtZW50LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIikge1xuICAgICAgICBhc3luY1JldCA9IG5ldyAoZ2V0UHJvbWlzZSh0aGlzLl93aW4pKShyZXNvbHZlID0+IHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmU7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgICAgIGlmICh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcikge1xuICAgICAgICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFuY2hvck5vZGU6IHByZXZBbmNob3JOb2RlLFxuICAgICAgICAgICAgZm9jdXNOb2RlOiBwcmV2Rm9jdXNOb2RlLFxuICAgICAgICAgICAgYW5jaG9yT2Zmc2V0OiBwcmV2QW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgZm9jdXNPZmZzZXQ6IHByZXZGb2N1c09mZnNldFxuICAgICAgICAgIH0gPSBkb20uZ2V0U2VsZWN0aW9uKGVsZW1lbnQpIHx8IHt9O1xuICAgICAgICAgIC8vIEdldCBzZWxlY3Rpb24gZ2l2ZXMgaW5jb3JyZWN0IHZhbHVlIGlmIHdlIGNhbGwgaXQgc3luY3Jvbm91c2x5IG9uS2V5RG93bi5cbiAgICAgICAgICB0aGlzLl9pZ25vcmVkSW5wdXRUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXRcbiAgICAgICAgICAgIH0gPSBkb20uZ2V0U2VsZWN0aW9uKGVsZW1lbnQpIHx8IHt9O1xuICAgICAgICAgICAgaWYgKGFuY2hvck5vZGUgIT09IHByZXZBbmNob3JOb2RlIHx8IGZvY3VzTm9kZSAhPT0gcHJldkZvY3VzTm9kZSB8fCBhbmNob3JPZmZzZXQgIT09IHByZXZBbmNob3JPZmZzZXQgfHwgZm9jdXNPZmZzZXQgIT09IHByZXZGb2N1c09mZnNldCkge1xuICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gYW5jaG9yT2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBmb2N1c09mZnNldCB8fCAwO1xuICAgICAgICAgICAgdGV4dExlbmd0aCA9ICgoX2IgPSBlbGVtZW50LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgaWYgKGFuY2hvck5vZGUgJiYgZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGFuY2hvck5vZGUpICYmIGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3JOb2RlICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgYW5jaG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9mZnNldHMgPSBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmNob3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRleHQgJiYgIWRvbS5nZXRGaXJzdENoaWxkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gbm9kZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmNob3JGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzTm9kZSAhPT0gYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgKz0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgKz0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gZG9tLmdldEZpcnN0Q2hpbGQobm9kZSk7IGUgJiYgIXN0b3A7IGUgPSBlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGFkZE9mZnNldHMoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3A7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYWRkT2Zmc2V0cyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhc3luY1JldCAmJiAhKGF3YWl0IGFzeW5jUmV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID4gMCAmJiAoa2V5ID09PSBLZXlzLkFycm93TGVmdCB8fCBrZXkgPT09IEtleXMuQXJyb3dVcCB8fCBrZXkgPT09IEtleXMuSG9tZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPCB0ZXh0TGVuZ3RoICYmIChrZXkgPT09IEtleXMuQXJyb3dSaWdodCB8fCBrZXkgPT09IEtleXMuQXJyb3dEb3duIHx8IGtleSA9PT0gS2V5cy5FbmQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU11dGF0aW9ucyhkb2MsIHRhYnN0ZXIsIHVwZGF0ZVRhYnN0ZXJCeUF0dHJpYnV0ZSwgc3luY1N0YXRlKSB7XG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvKiBOb29wICovXG4gICAgfTtcbiAgfVxuICBjb25zdCBnZXRXaW5kb3cgPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgbGV0IGVsZW1lbnRCeVVJZDtcbiAgY29uc3Qgb25NdXRhdGlvbiA9IG11dGF0aW9ucyA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZW1vdmVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXM7XG4gICAgICBjb25zdCBhZGRlZCA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFRBQlNURVJfQVRUUklCVVRFX05BTUUpIHtcbiAgICAgICAgICAvLyByZW1vdmVkTm9kZXMgaGVscHMgdG8gbWFrZSBzdXJlIHdlIGFyZSBub3QgcmVjcmVhdGluZyB0aGluZ3NcbiAgICAgICAgICAvLyBmb3IgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBpZiB3ZSBkbyByZW1vdmVDaGlsZCgpIGFuZCBzZXRBdHRyaWJ1dGUoKSBvbiB0aGVcbiAgICAgICAgICAvLyByZW1vdmVkIGNoaWxkIGluIHRoZSBzYW1lIHRpY2ssIGJvdGggdGhlIGNoaWxkIHJlbW92YWwgYW5kIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyBjaGFuZ2Ugd2lsbCBiZSBwcmVzZW50IGluIHRoZSBtdXRhdGlvbiByZWNvcmRzLiBBbmQgdGhlIGF0dHJpYnV0ZSBjaGFuZ2VcbiAgICAgICAgICAvLyB3aWxsIGZvbGxvdyB0aGUgY2hpbGQgcmVtb3ZhbC5cbiAgICAgICAgICAvLyBTbywgd2UgcmVtZW1iZXIgdGhlIHJlbW92ZWQgbm9kZXMgYW5kIGlnbm9yZSBhdHRyaWJ1dGUgY2hhbmdlcyBmb3IgdGhlbS5cbiAgICAgICAgICBpZiAoIXJlbW92ZWROb2Rlcy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgdXBkYXRlVGFic3RlckJ5QXR0cmlidXRlKHRhYnN0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkTm9kZSA9IHJlbW92ZWRbaV07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzLmFkZChyZW1vdmVkTm9kZSk7XG4gICAgICAgICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKHJlbW92ZWROb2RlLCB0cnVlKTtcbiAgICAgICAgICAoX2IgPSAoX2EgPSB0YWJzdGVyLl9kdW1teU9ic2VydmVyKS5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKGFkZGVkW2ldKTtcbiAgICAgICAgICAoX2QgPSAoX2MgPSB0YWJzdGVyLl9kdW1teU9ic2VydmVyKS5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVkTm9kZXMuY2xlYXIoKTtcbiAgICAoX2UgPSB0YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmhpZGRlblVwZGF0ZSgpO1xuICB9O1xuICBmdW5jdGlvbiB1cGRhdGVUYWJzdGVyRWxlbWVudHMobm9kZSwgcmVtb3ZlZCkge1xuICAgIGlmICghZWxlbWVudEJ5VUlkKSB7XG4gICAgICBlbGVtZW50QnlVSWQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KS5lbGVtZW50QnlVSWQ7XG4gICAgfVxuICAgIHByb2Nlc3NOb2RlKG5vZGUsIHJlbW92ZWQpO1xuICAgIGNvbnN0IHdhbGtlciA9IGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKGRvYywgbm9kZSwgZWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gcHJvY2Vzc05vZGUoZWxlbWVudCwgcmVtb3ZlZCk7XG4gICAgfSk7XG4gICAgaWYgKHdhbGtlcikge1xuICAgICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEl0ZXJhdGluZyBmb3IgdGhlIHNha2Ugb2YgY2FsbGluZyBwcm9jZXNzTm9kZSgpIGNhbGxiYWNrLiAqL1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTm9kZShlbGVtZW50LCByZW1vdmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIEl0IG1pZ2h0IGFjdHVhbGx5IGJlIGEgdGV4dCBub2RlLlxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICAgIGNvbnN0IHVpZCA9IGVsZW1lbnQuX190YWJzdGVyRWxlbWVudFVJRDtcbiAgICBpZiAodWlkICYmIGVsZW1lbnRCeVVJZCkge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRCeVVJZFt1aWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKF9hID0gZWxlbWVudEJ5VUlkW3VpZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVsZW1lbnRCeVVJZFt1aWRdID0gbmV3IFdlYWtIVE1MRWxlbWVudChnZXRXaW5kb3csIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbGVtZW50KSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgdXBkYXRlVGFic3RlckJ5QXR0cmlidXRlKHRhYnN0ZXIsIGVsZW1lbnQsIHJlbW92ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgfVxuICBjb25zdCBvYnNlcnZlciA9IGRvbS5jcmVhdGVNdXRhdGlvbk9ic2VydmVyKG9uTXV0YXRpb24pO1xuICBpZiAoc3luY1N0YXRlKSB7XG4gICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKGdldFdpbmRvdygpLmRvY3VtZW50LmJvZHkpO1xuICB9XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jLCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtUQUJTVEVSX0FUVFJJQlVURV9OQU1FXVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH07XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IF9jb25kaXRpb25DaGVja1RpbWVvdXQgPSAxMDA7XG5jbGFzcyBPYnNlcnZlZEVsZW1lbnRBUEkgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl93YWl0aW5nID0ge307XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RGb2N1c0lkID0gMDtcbiAgICB0aGlzLl9vYnNlcnZlZEJ5SWQgPSB7fTtcbiAgICB0aGlzLl9vYnNlcnZlZEJ5TmFtZSA9IHt9O1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0VGltZXN0YW1wID0gMDtcbiAgICB0aGlzLl9vbkZvY3VzID0gZSA9PiB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY29uc3QgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5fY3VycmVudFJlcXVlc3RUaW1lc3RhbXA7XG4gICAgICAgICAgY29uc3Qgc2V0dGxlVGltZSA9IDMwMDtcbiAgICAgICAgICBpZiAoZGVsdGEgPj0gc2V0dGxlVGltZSkge1xuICAgICAgICAgICAgLy8gR2l2aW5nIHNvbWUgdGltZSBmb3IgdGhlIGZvY3VzIHRvIHNldHRsZSBiZWZvcmVcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FuY2VsbGluZyB0aGUgY3VycmVudCByZXF1ZXN0IG9uIGZvY3VzIGNoYW5nZS5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcbiAgICAgICAgICAgIGN1cnJlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50VXBkYXRlID0gZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vYnNlcnZlZDtcbiAgICAgIGNvbnN0IHVpZCA9IGdldEVsZW1lbnRVSWQodGhpcy5fd2luLCBlbGVtZW50KTtcbiAgICAgIGxldCBpbmZvID0gdGhpcy5fb2JzZXJ2ZWRCeUlkW3VpZF07XG4gICAgICBpZiAob2JzZXJ2ZWQgJiYgZG9jdW1lbnRDb250YWlucyhlbGVtZW50Lm93bmVyRG9jdW1lbnQsIGVsZW1lbnQpKSB7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIGluZm8gPSB0aGlzLl9vYnNlcnZlZEJ5SWRbdWlkXSA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fd2luLCBlbGVtZW50KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZWQubmFtZXMuc29ydCgpO1xuICAgICAgICBjb25zdCBvYnNlcnZlZE5hbWVzID0gb2JzZXJ2ZWQubmFtZXM7XG4gICAgICAgIGNvbnN0IHByZXZOYW1lcyA9IGluZm8ucHJldk5hbWVzOyAvLyBwcmV2TmFtZXMgYXJlIGFscmVhZHkgc29ydGVkXG4gICAgICAgIGlmICh0aGlzLl9pc09ic2VydmVkTmFtZXNVcGRhdGVkKG9ic2VydmVkTmFtZXMsIHByZXZOYW1lcykpIHtcbiAgICAgICAgICBpZiAocHJldk5hbWVzKSB7XG4gICAgICAgICAgICBwcmV2TmFtZXMuZm9yRWFjaChwcmV2TmFtZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG9ibiA9IHRoaXMuX29ic2VydmVkQnlOYW1lW3ByZXZOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG9ibiAmJiBvYm5bdWlkXSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYm4pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYm5bdWlkXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29ic2VydmVkQnlOYW1lW3ByZXZOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmZvLnByZXZOYW1lcyA9IG9ic2VydmVkTmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZWROYW1lcy5mb3JFYWNoKG9ic2VydmVkTmFtZSA9PiB7XG4gICAgICAgICAgbGV0IG9ibiA9IHRoaXMuX29ic2VydmVkQnlOYW1lW29ic2VydmVkTmFtZV07XG4gICAgICAgICAgaWYgKCFvYm4pIHtcbiAgICAgICAgICAgIG9ibiA9IHRoaXMuX29ic2VydmVkQnlOYW1lW29ic2VydmVkTmFtZV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICBvYm5bdWlkXSA9IGluZm87XG4gICAgICAgICAgdGhpcy5fd2FpdENvbmRpdGlvbmFsKG9ic2VydmVkTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHByZXZOYW1lcyA9IGluZm8ucHJldk5hbWVzO1xuICAgICAgICBpZiAocHJldk5hbWVzKSB7XG4gICAgICAgICAgcHJldk5hbWVzLmZvckVhY2gocHJldk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JuID0gdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbcHJldk5hbWVdO1xuICAgICAgICAgICAgaWYgKG9ibiAmJiBvYm5bdWlkXSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JuKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9iblt1aWRdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vYnNlcnZlZEJ5TmFtZVtwcmV2TmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fb2JzZXJ2ZWRCeUlkW3VpZF07XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fd2FpdGluZykpIHtcbiAgICAgIHRoaXMuX3JlamVjdFdhaXRpbmcoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5fb2JzZXJ2ZWRCeUlkID0ge307XG4gICAgdGhpcy5fb2JzZXJ2ZWRCeU5hbWUgPSB7fTtcbiAgfVxuICBfcmVqZWN0V2FpdGluZyhrZXksIHNob3VsZFJlc29sdmUpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fd2FpdGluZ1trZXldO1xuICAgIGlmICh3KSB7XG4gICAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICAgIGlmICh3LnRpbWVyKSB7XG4gICAgICAgIHdpbi5jbGVhclRpbWVvdXQody50aW1lcik7XG4gICAgICB9XG4gICAgICBpZiAody5jb25kaXRpb25UaW1lcikge1xuICAgICAgICB3aW4uY2xlYXJUaW1lb3V0KHcuY29uZGl0aW9uVGltZXIpO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRSZXNvbHZlICYmIHcucmVqZWN0KSB7XG4gICAgICAgIHcucmVqZWN0KCk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFJlc29sdmUgJiYgdy5yZXNvbHZlKSB7XG4gICAgICAgIHcucmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl93YWl0aW5nW2tleV07XG4gICAgfVxuICB9XG4gIF9pc09ic2VydmVkTmFtZXNVcGRhdGVkKGN1ciwgcHJldikge1xuICAgIGlmICghcHJldiB8fCBjdXIubGVuZ3RoICE9PSBwcmV2Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoY3VyW2ldICE9PSBwcmV2W2ldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZXhpc3RpbmcgZWxlbWVudCBieSBvYnNlcnZlZCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBvYnNlcnZlZE5hbWUgQW4gb2JzZXJ2ZWQgbmFtZVxuICAgKiBAcGFyYW0gYWNjZXNzaWJpbGl0eSBPcHRpb25hbGx5LCByZXR1cm4gb25seSBpZiB0aGUgZWxlbWVudCBpcyBhY2Nlc3NpYmxlIG9yIGZvY3VzYWJsZVxuICAgKiBAcmV0dXJucyBIVE1MRWxlbWVudCB8IG51bGxcbiAgICovXG4gIGdldEVsZW1lbnQob2JzZXJ2ZWROYW1lLCBhY2Nlc3NpYmlsaXR5KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX29ic2VydmVkQnlOYW1lW29ic2VydmVkTmFtZV07XG4gICAgaWYgKG8pIHtcbiAgICAgIGZvciAoY29uc3QgdWlkIG9mIE9iamVjdC5rZXlzKG8pKSB7XG4gICAgICAgIGxldCBlbCA9IG9bdWlkXS5lbGVtZW50LmdldCgpIHx8IG51bGw7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGlmIChhY2Nlc3NpYmlsaXR5ID09PSBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMuQWNjZXNzaWJsZSAmJiAhdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNBY2Nlc3NpYmxlKGVsKSB8fCBhY2Nlc3NpYmlsaXR5ID09PSBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMuRm9jdXNhYmxlICYmICF0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9bdWlkXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fb2JzZXJ2ZWRCeUlkW3VpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBlbGVtZW50IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2ZWROYW1lIEFuIG9ic2VydmVkIG5hbWVcbiAgICogQHBhcmFtIHRpbWVvdXQgV2FpdCBubyBsb25nZXIgdGhhbiB0aGlzIHRpbWVvdXRcbiAgICogQHBhcmFtIGFjY2Vzc2liaWxpdHkgT3B0aW9uYWxseSwgd2FpdCBmb3IgdGhlIGVsZW1lbnQgdG8gYWxzbyBiZWNvbWUgYWNjZXNzaWJsZSBvciBmb2N1c2FibGUgYmVmb3JlIHJldHVybmluZyBpdFxuICAgKiBAcmV0dXJucyBQcm9taXNlPEhUTUxFbGVtZW50IHwgbnVsbD5cbiAgICovXG4gIHdhaXRFbGVtZW50KG9ic2VydmVkTmFtZSwgdGltZW91dCwgYWNjZXNzaWJpbGl0eSkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSwgYWNjZXNzaWJpbGl0eSk7XG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGdldFByb21pc2UodGhpcy5fd2luKS5yZXNvbHZlKGVsKSxcbiAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgLyoqL1xuICAgICAgICB9LFxuICAgICAgICBzdGF0dXM6IE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcy5TdWNjZWVkZWRcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBwcmVmaXg7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgPT09IE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5BY2Nlc3NpYmxlKSB7XG4gICAgICBwcmVmaXggPSBcImFcIjtcbiAgICB9IGVsc2UgaWYgKGFjY2Vzc2liaWxpdHkgPT09IE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5Gb2N1c2FibGUpIHtcbiAgICAgIHByZWZpeCA9IFwiZlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSBcIl9cIjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcHJlZml4ICsgb2JzZXJ2ZWROYW1lO1xuICAgIGxldCB3ID0gdGhpcy5fd2FpdGluZ1trZXldO1xuICAgIGlmICh3ICYmIHcucmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHcucmVxdWVzdDtcbiAgICB9XG4gICAgdyA9IHRoaXMuX3dhaXRpbmdba2V5XSA9IHtcbiAgICAgIHRpbWVyOiB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHcuY29uZGl0aW9uVGltZXIpIHtcbiAgICAgICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQody5jb25kaXRpb25UaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX3dhaXRpbmdba2V5XTtcbiAgICAgICAgaWYgKHcucmVxdWVzdCkge1xuICAgICAgICAgIHcucmVxdWVzdC5zdGF0dXMgPSBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuVGltZWRPdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcucmVzb2x2ZSkge1xuICAgICAgICAgIHcucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dClcbiAgICB9O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgKGdldFByb21pc2UodGhpcy5fd2luKSkoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHcucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIC8vIElnbm9yZSB0aGUgZXJyb3IsIGl0IGlzIGV4cGVjdGVkIHRvIGJlIHJlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgY2FuY2VsZWQuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgcmVzdWx0OiBwcm9taXNlLFxuICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gT2JzZXJ2ZWRFbGVtZW50UmVxdWVzdFN0YXR1c2VzLldhaXRpbmcpIHtcbiAgICAgICAgICAvLyBjYW5jZWwoKSBmdW5jdGlvbiBpcyBjYWxsYWJsZSBieSB1c2VyLCBzb21lb25lIG1pZ2h0IGNhbGwgaXQgYWZ0ZXIgcmVxdWVzdCBpcyBmaW5pc2hlZCxcbiAgICAgICAgICAvLyB3ZSBhcmUgbWFraW5nIHN1cmUgdGhhdCBzdGF0dXMgb2YgYSBmaW5pc2hlZCByZXF1ZXN0IGlzIG5vdCBvdmVycmlkZW4uXG4gICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuQ2FuY2VsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVqZWN0V2FpdGluZyhrZXksIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHN0YXR1czogT2JzZXJ2ZWRFbGVtZW50UmVxdWVzdFN0YXR1c2VzLldhaXRpbmdcbiAgICB9O1xuICAgIHcucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgJiYgdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSkpIHtcbiAgICAgIC8vIElmIHRoZSBvYnNlcnZlZCBlbGVtZW50IGlzIGFscmVhZCBpbiBET00sIGJ1dCBub3QgYWNjZXNzaWJsZSB5ZXQsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJ1biB0aGUgd2FpdCBsb2dpYy5cbiAgICAgIHRoaXMuX3dhaXRDb25kaXRpb25hbChvYnNlcnZlZE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICByZXF1ZXN0Rm9jdXMob2JzZXJ2ZWROYW1lLCB0aW1lb3V0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0SWQgPSArK3RoaXMuX2xhc3RSZXF1ZXN0Rm9jdXNJZDtcbiAgICBjb25zdCBjdXJyZW50UmVxdWVzdEZvY3VzID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgaWYgKGN1cnJlbnRSZXF1ZXN0Rm9jdXMpIHtcbiAgICAgIGN1cnJlbnRSZXF1ZXN0Rm9jdXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLndhaXRFbGVtZW50KG9ic2VydmVkTmFtZSwgdGltZW91dCwgT2JzZXJ2ZWRFbGVtZW50QWNjZXNzaWJpbGl0aWVzLkZvY3VzYWJsZSk7XG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICByZXN1bHQ6IHJlcXVlc3QucmVzdWx0LnRoZW4oZWxlbWVudCA9PiB0aGlzLl9sYXN0UmVxdWVzdEZvY3VzSWQgPT09IHJlcXVlc3RJZCAmJiBlbGVtZW50ID8gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1cyhlbGVtZW50LCB0cnVlLCB1bmRlZmluZWQsIG9wdGlvbnMucHJldmVudFNjcm9sbCkgOiBmYWxzZSksXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgcmVxdWVzdC5jYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzXG4gICAgfTtcbiAgICByZXF1ZXN0LnJlc3VsdC5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50UmVxdWVzdCA9PT0gcmVxdWVzdCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgICB9XG4gICAgICByZXQuc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBfd2FpdENvbmRpdGlvbmFsKG9ic2VydmVkTmFtZSkge1xuICAgIGNvbnN0IHdhaXRpbmdFbGVtZW50S2V5ID0gXCJfXCIgKyBvYnNlcnZlZE5hbWU7XG4gICAgY29uc3Qgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50S2V5ID0gXCJhXCIgKyBvYnNlcnZlZE5hbWU7XG4gICAgY29uc3Qgd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnRLZXkgPSBcImZcIiArIG9ic2VydmVkTmFtZTtcbiAgICBjb25zdCB3YWl0aW5nRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0VsZW1lbnRLZXldO1xuICAgIGNvbnN0IHdhaXRpbmdBY2Nlc3NpYmxlRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50S2V5XTtcbiAgICBjb25zdCB3YWl0aW5nRm9jdXNhYmxlRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnRLZXldO1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZWxlbWVudCwga2V5LCB3YWl0aW5nLCBhY2Nlc3NpYmlsaXR5KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vYnNlcnZlZDtcbiAgICAgIGlmICghb2JzZXJ2ZWQgfHwgIW9ic2VydmVkLm5hbWVzLmluY2x1ZGVzKG9ic2VydmVkTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHdhaXRpbmcudGltZXIpIHtcbiAgICAgICAgd2luLmNsZWFyVGltZW91dCh3YWl0aW5nLnRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl93YWl0aW5nW2tleV07XG4gICAgICBpZiAod2FpdGluZy5yZXF1ZXN0KSB7XG4gICAgICAgIHdhaXRpbmcucmVxdWVzdC5zdGF0dXMgPSBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuU3VjY2VlZGVkO1xuICAgICAgfVxuICAgICAgaWYgKHdhaXRpbmcucmVzb2x2ZSkge1xuICAgICAgICB3YWl0aW5nLnJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoZWxlbWVudCwge1xuICAgICAgICBuYW1lczogW29ic2VydmVkTmFtZV0sXG4gICAgICAgIGRldGFpbHM6IG9ic2VydmVkLmRldGFpbHMsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHdhaXRpbmdFbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSk7XG4gICAgICBpZiAoZWxlbWVudCAmJiBkb2N1bWVudENvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudCwgZWxlbWVudCkpIHtcbiAgICAgICAgcmVzb2x2ZShlbGVtZW50LCB3YWl0aW5nRWxlbWVudEtleSwgd2FpdGluZ0VsZW1lbnQsIE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5BbnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FpdGluZ0FjY2Vzc2libGVFbGVtZW50ICYmICF3YWl0aW5nQWNjZXNzaWJsZUVsZW1lbnQuY29uZGl0aW9uVGltZXIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVBY2Nlc3NpYmxlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGRvY3VtZW50Q29udGFpbnMoZWxlbWVudC5vd25lckRvY3VtZW50LCBlbGVtZW50KSAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0FjY2Vzc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgICByZXNvbHZlKGVsZW1lbnQsIHdhaXRpbmdBY2Nlc3NpYmxlRWxlbWVudEtleSwgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50LCBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMuQWNjZXNzaWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50LmNvbmRpdGlvblRpbWVyID0gd2luLnNldFRpbWVvdXQocmVzb2x2ZUFjY2Vzc2libGUsIF9jb25kaXRpb25DaGVja1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVzb2x2ZUFjY2Vzc2libGUoKTtcbiAgICB9XG4gICAgaWYgKHdhaXRpbmdGb2N1c2FibGVFbGVtZW50ICYmICF3YWl0aW5nRm9jdXNhYmxlRWxlbWVudC5jb25kaXRpb25UaW1lcikge1xuICAgICAgY29uc3QgcmVzb2x2ZUZvY3VzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBkb2N1bWVudENvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudCwgZWxlbWVudCkgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXNvbHZlKGVsZW1lbnQsIHdhaXRpbmdGb2N1c2FibGVFbGVtZW50S2V5LCB3YWl0aW5nRm9jdXNhYmxlRWxlbWVudCwgT2JzZXJ2ZWRFbGVtZW50QWNjZXNzaWJpbGl0aWVzLkZvY3VzYWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnQuY29uZGl0aW9uVGltZXIgPSB3aW4uc2V0VGltZW91dChyZXNvbHZlRm9jdXNhYmxlLCBfY29uZGl0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc29sdmVGb2N1c2FibGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBhcmVhQ2xhc3M6IFwidGFic3Rlci1mb2N1cy1vdXRsaW5lLWFyZWFcIixcbiAgb3V0bGluZUNsYXNzOiBcInRhYnN0ZXItZm9jdXMtb3V0bGluZVwiLFxuICBvdXRsaW5lQ29sb3I6IFwiI2ZmNDUwMFwiLFxuICBvdXRsaW5lV2lkdGg6IDIsXG4gIHpJbmRleDogMjE0NzQ4MzY0N1xufTtcbmxldCBfcHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5jbGFzcyBPdXRsaW5lUG9zaXRpb24ge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgfVxuICBlcXVhbHNUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT09IG90aGVyLmxlZnQgJiYgdGhpcy50b3AgPT09IG90aGVyLnRvcCAmJiB0aGlzLnJpZ2h0ID09PSBvdGhlci5yaWdodCAmJiB0aGlzLmJvdHRvbSA9PT0gb3RoZXIuYm90dG9tO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT3V0bGluZVBvc2l0aW9uKHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKTtcbiAgfVxufVxuY2xhc3MgT3V0bGluZUFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9hbGxPdXRsaW5lRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pbml0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uc3Vic2NyaWJlKHRoaXMuX29uS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9vblNjcm9sbCwgdHJ1ZSk7IC8vIENhcHR1cmUhXG4gICAgICBpZiAodGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSkge1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lLCB0aGlzLl9vbkZ1bGxTY3JlZW5DaGFuZ2VkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uRnVsbFNjcmVlbkNoYW5nZWQgPSBlID0+IHtcbiAgICAgIGlmICghdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnROYW1lIHx8ICFlLnRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldC5ib2R5IHx8IGUudGFyZ2V0O1xuICAgICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gdGhpcy5fZ2V0RE9NKHRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgb3V0bGluZUVsZW1lbnRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGZzRWxlbWVudCA9IHRhcmdldC5vd25lckRvY3VtZW50W3RoaXMuX2Z1bGxTY3JlZW5FbGVtZW50TmFtZV07XG4gICAgICAgIGlmIChmc0VsZW1lbnQpIHtcbiAgICAgICAgICBmc0VsZW1lbnQuYXBwZW5kQ2hpbGQob3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lcik7XG4gICAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnQgPSBmc0VsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyKTtcbiAgICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkZvY3VzKHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZUVsZW1lbnQoZSkgJiYgdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX3NldFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25TY3JvbGwgPSBlID0+IHtcbiAgICAgIGlmICghdGhpcy5fb3V0bGluZWRFbGVtZW50IHx8ICFPdXRsaW5lQVBJLl9pc1BhcmVudENoaWxkKGUudGFyZ2V0LCB0aGlzLl9vdXRsaW5lZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1clBvcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3NldE91dGxpbmVQb3NpdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGFic3Rlci5xdWV1ZUluaXQodGhpcy5faW5pdCk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKFwib25mdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwiZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcImZ1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib253ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib25tb3pmdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib25tc2Z1bGxzY3JlZW5jaGFuZ2VcIiBpbiBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lID0gXCJtc2Z1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnROYW1lID0gXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldHVwKHByb3BzKSB7XG4gICAgX3Byb3BzID0ge1xuICAgICAgLi4uX3Byb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGlmICghd2luLl9fdGFic3Rlck91dGxpbmUpIHtcbiAgICAgIHdpbi5fX3RhYnN0ZXJPdXRsaW5lID0ge307XG4gICAgfVxuICAgIGlmICghd2luLl9fdGFic3Rlck91dGxpbmUuc3R5bGUpIHtcbiAgICAgIHdpbi5fX3RhYnN0ZXJPdXRsaW5lLnN0eWxlID0gYXBwZW5kU3R5bGVzKHdpbi5kb2N1bWVudCwgX3Byb3BzKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wcyB8fCAhcHJvcHMuYXJlYUNsYXNzKSB7XG4gICAgICB3aW4uZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGRlZmF1bHRQcm9wcy5hcmVhQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW4uZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGRlZmF1bHRQcm9wcy5hcmVhQ2xhc3MpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICB0aGlzLl91cGRhdGVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24udW5zdWJzY3JpYmUodGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQpO1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5fb25TY3JvbGwsIHRydWUpO1xuICAgIGlmICh0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lKSB7XG4gICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lLCB0aGlzLl9vbkZ1bGxTY3JlZW5DaGFuZ2VkKTtcbiAgICB9XG4gICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzLmZvckVhY2gob3V0bGluZUVsZW1lbnRzID0+IHRoaXMuX3JlbW92ZURPTShvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyKSk7XG4gICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzID0gW107XG4gICAgZGVsZXRlIHRoaXMuX291dGxpbmVkRWxlbWVudDtcbiAgICBkZWxldGUgdGhpcy5fY3VyUG9zO1xuICAgIGRlbGV0ZSB0aGlzLl9jdXJPdXRsaW5lRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX2Z1bGxTY3JlZW5FbGVtZW50O1xuICB9XG4gIF9zaG91bGRTaG93Q3VzdG9tT3V0bGluZShlbGVtZW50KSB7XG4gICAgY29uc3QgdGFic3Rlck9uRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQgJiYgdGFic3Rlck9uRWxlbWVudC5vdXRsaW5lICYmIHRhYnN0ZXJPbkVsZW1lbnQub3V0bGluZS5pc0lnbm9yZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQ7IGk7IGkgPSBpLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmIChpLmNsYXNzTGlzdCAmJiBpLmNsYXNzTGlzdC5jb250YWlucyhfcHJvcHMuYXJlYUNsYXNzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIF91cGRhdGVFbGVtZW50KGUpIHtcbiAgICB0aGlzLl9vdXRsaW5lZEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlVGltZXIpO1xuICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX2N1clBvcyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuX3RhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICAvLyBUT0RPOiBJdCdzIGhhcmQgKGFuZCBub3QgbmVjZXNzYXJ5KSB0byBjb21lIHVwIHdpdGggZXZlcnkgcG9zc2libGVcbiAgICAgIC8vIGNvbmRpdGlvbiB3aGVuIHRoZXJlIHNob3VsZCBiZSBubyBvdXRsaW5lLCBpdCdzIGJldHRlciB0byBhZGQgYW5cbiAgICAgIC8vIEFQSSB0byBjdXN0b21pemUgdGhlIGlnbm9yZXMuXG4gICAgICBpZiAoZS50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gZS50eXBlO1xuICAgICAgICBjb25zdCBvdXRsaW5lZElucHV0VHlwZXMgPSB7XG4gICAgICAgICAgYnV0dG9uOiB0cnVlLFxuICAgICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICAgIGZpbGU6IHRydWUsXG4gICAgICAgICAgaW1hZ2U6IHRydWUsXG4gICAgICAgICAgcmFkaW86IHRydWUsXG4gICAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgICAgcmVzZXQ6IHRydWUsXG4gICAgICAgICAgc3VibWl0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghKGlucHV0VHlwZSBpbiBvdXRsaW5lZElucHV0VHlwZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiIHx8IGUuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIiB8fCBlLnRhZ05hbWUgPT09IFwiSUZSQU1FXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zaG91bGRTaG93Q3VzdG9tT3V0bGluZShlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkpIHtcbiAgICAgICAgdGhpcy5fb3V0bGluZWRFbGVtZW50ID0gZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3V0bGluZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfdXBkYXRlT3V0bGluZSgpIHtcbiAgICB0aGlzLl9zZXRPdXRsaW5lUG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5fdXBkYXRlVGltZXIpIHtcbiAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICB0aGlzLl91cGRhdGVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vdXRsaW5lZEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fdXBkYXRlT3V0bGluZSgpO1xuICAgIH0sIDMwKTtcbiAgfVxuICBfc2V0VmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgdGhpcy5faXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzKSB7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9jdXJPdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7X3Byb3BzLm91dGxpbmVDbGFzc31fdmlzaWJsZWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X3Zpc2libGVgKTtcbiAgICAgICAgdGhpcy5fY3VyUG9zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0T3V0bGluZVBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5fb3V0bGluZWRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBib3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGhpcy5fd2luLCB0aGlzLl9vdXRsaW5lZEVsZW1lbnQpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IE91dGxpbmVQb3NpdGlvbihib3VuZGluZ1JlY3QubGVmdCwgYm91bmRpbmdSZWN0LnRvcCwgYm91bmRpbmdSZWN0LnJpZ2h0LCBib3VuZGluZ1JlY3QuYm90dG9tKTtcbiAgICBpZiAodGhpcy5fY3VyUG9zICYmIHBvc2l0aW9uLmVxdWFsc1RvKHRoaXMuX2N1clBvcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gdGhpcy5fZ2V0RE9NKHRoaXMuX291dGxpbmVkRWxlbWVudCk7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fb3V0bGluZWRFbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgdGhpcy5fb3V0bGluZWRFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFvdXRsaW5lRWxlbWVudHMgfHwgIXdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzICE9PSBvdXRsaW5lRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX3NldFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgdGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzID0gb3V0bGluZUVsZW1lbnRzO1xuICAgIH1cbiAgICB0aGlzLl9jdXJQb3MgPSBwb3NpdGlvbjtcbiAgICBjb25zdCBwID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBsZXQgaGFzQWJzb2x1dGVQb3NpdGlvbmVkUGFyZW50ID0gZmFsc2U7XG4gICAgbGV0IGhhc0ZpeGVkUG9zaXRpb25lZFBhcmVudCA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dGxpbmVFbGVtZW50cy5jb250YWluZXI7XG4gICAgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IGNvbnRhaW5lciAmJiBjb250YWluZXIub3duZXJEb2N1bWVudCAmJiBjb250YWluZXIub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLl9vdXRsaW5lZEVsZW1lbnQucGFyZW50RWxlbWVudDsgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBtaWdodCBiZSBwYXJ0aWFsbHkgdmlzaWJsZSB3aXRoaW4gaXRzIHNjcm9sbGFibGUgcGFyZW50LFxuICAgICAgLy8gcmVkdWNlIHRoZSBib3VuZGluZyByZWN0IGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0aGlzLl93aW4sIHBhcmVudCk7XG4gICAgICBjb25zdCB3aW4gPSBwYXJlbnQub3duZXJEb2N1bWVudCAmJiBwYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgaGFzQWJzb2x1dGVQb3NpdGlvbmVkUGFyZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCBwb3NpdGlvbiA9PT0gXCJzdGlja3lcIikge1xuICAgICAgICBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNBYnNvbHV0ZVBvc2l0aW9uZWRQYXJlbnQgJiYgIWhhc0ZpeGVkUG9zaXRpb25lZFBhcmVudCB8fCBjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QubGVmdCA+IHAubGVmdCkge1xuICAgICAgICAgIHAubGVmdCA9IGJvdW5kaW5nUmVjdC5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QudG9wID4gcC50b3ApIHtcbiAgICAgICAgICBwLnRvcCA9IGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kaW5nUmVjdC5yaWdodCA8IHAucmlnaHQpIHtcbiAgICAgICAgICBwLnJpZ2h0ID0gYm91bmRpbmdSZWN0LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QuYm90dG9tIDwgcC5ib3R0b20pIHtcbiAgICAgICAgICBwLmJvdHRvbSA9IGJvdW5kaW5nUmVjdC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWxsUmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0aGlzLl93aW4sIHNjcm9sbGluZ0VsZW1lbnQpO1xuICAgIGNvbnN0IGFsbFdpZHRoID0gYWxsUmVjdC5sZWZ0ICsgYWxsUmVjdC5yaWdodDtcbiAgICBjb25zdCBhbGxIZWlnaHQgPSBhbGxSZWN0LnRvcCArIGFsbFJlY3QuYm90dG9tO1xuICAgIGNvbnN0IG93ID0gX3Byb3BzLm91dGxpbmVXaWR0aDtcbiAgICBwLmxlZnQgPSBwLmxlZnQgPiBvdyA/IHAubGVmdCAtIG93IDogMDtcbiAgICBwLnRvcCA9IHAudG9wID4gb3cgPyBwLnRvcCAtIG93IDogMDtcbiAgICBwLnJpZ2h0ID0gcC5yaWdodCA8IGFsbFdpZHRoIC0gb3cgPyBwLnJpZ2h0ICsgb3cgOiBhbGxXaWR0aDtcbiAgICBwLmJvdHRvbSA9IHAuYm90dG9tIDwgYWxsSGVpZ2h0IC0gb3cgPyBwLmJvdHRvbSArIG93IDogYWxsSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gcC5yaWdodCAtIHAubGVmdDtcbiAgICBjb25zdCBoZWlnaHQgPSBwLmJvdHRvbSAtIHAudG9wO1xuICAgIGlmICh3aWR0aCA+IG93ICogMiAmJiBoZWlnaHQgPiBvdyAqIDIpIHtcbiAgICAgIGNvbnN0IGxlZnRCb3JkZXJOb2RlID0gb3V0bGluZUVsZW1lbnRzLmxlZnQ7XG4gICAgICBjb25zdCB0b3BCb3JkZXJOb2RlID0gb3V0bGluZUVsZW1lbnRzLnRvcDtcbiAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyTm9kZSA9IG91dGxpbmVFbGVtZW50cy5yaWdodDtcbiAgICAgIGNvbnN0IGJvdHRvbUJvcmRlck5vZGUgPSBvdXRsaW5lRWxlbWVudHMuYm90dG9tO1xuICAgICAgY29uc3Qgc3ggPSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCB8fCBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPyAwIDogd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgY29uc3Qgc3kgPSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCB8fCBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPyAwIDogd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gaGFzRml4ZWRQb3NpdGlvbmVkUGFyZW50ID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBfcHJvcHMub3V0bGluZUNvbG9yO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSByaWdodEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSB0b3BCb3JkZXJOb2RlLnN0eWxlLmhlaWdodCA9IGJvdHRvbUJvcmRlck5vZGUuc3R5bGUuaGVpZ2h0ID0gX3Byb3BzLm91dGxpbmVXaWR0aCArIFwicHhcIjtcbiAgICAgIGxlZnRCb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSB0b3BCb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSBib3R0b21Cb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSBwLmxlZnQgKyBzeCArIFwicHhcIjtcbiAgICAgIHJpZ2h0Qm9yZGVyTm9kZS5zdHlsZS5sZWZ0ID0gcC5sZWZ0ICsgc3ggKyB3aWR0aCAtIG93ICsgXCJweFwiO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUudG9wID0gcmlnaHRCb3JkZXJOb2RlLnN0eWxlLnRvcCA9IHRvcEJvcmRlck5vZGUuc3R5bGUudG9wID0gcC50b3AgKyBzeSArIFwicHhcIjtcbiAgICAgIGJvdHRvbUJvcmRlck5vZGUuc3R5bGUudG9wID0gcC50b3AgKyBzeSArIGhlaWdodCAtIG93ICsgXCJweFwiO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUuaGVpZ2h0ID0gcmlnaHRCb3JkZXJOb2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIHRvcEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSBib3R0b21Cb3JkZXJOb2RlLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgX2dldERPTShjb250ZXh0RWxlbWVudCkge1xuICAgIGNvbnN0IGRvYyA9IGNvbnRleHRFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgY29uc3Qgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWRvYyB8fCAhd2luIHx8ICF3aW4uX190YWJzdGVyT3V0bGluZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF3aW4uX190YWJzdGVyT3V0bGluZS5zdHlsZSkge1xuICAgICAgd2luLl9fdGFic3Rlck91dGxpbmUuc3R5bGUgPSBhcHBlbmRTdHlsZXMoZG9jLCBfcHJvcHMpO1xuICAgIH1cbiAgICBpZiAoIXdpbi5fX3RhYnN0ZXJPdXRsaW5lLmVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBvdXRsaW5lRWxlbWVudHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGxlZnQ6IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICB0b3A6IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICByaWdodDogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGJvdHRvbTogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIH07XG4gICAgICBvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmNsYXNzTmFtZSA9IF9wcm9wcy5vdXRsaW5lQ2xhc3M7XG4gICAgICBvdXRsaW5lRWxlbWVudHMubGVmdC5jbGFzc05hbWUgPSBgJHtfcHJvcHMub3V0bGluZUNsYXNzfV9fbGVmdGA7XG4gICAgICBvdXRsaW5lRWxlbWVudHMudG9wLmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X190b3BgO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLnJpZ2h0LmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X19yaWdodGA7XG4gICAgICBvdXRsaW5lRWxlbWVudHMuYm90dG9tLmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X19ib3R0b21gO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMubGVmdCk7XG4gICAgICBvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmFwcGVuZENoaWxkKG91dGxpbmVFbGVtZW50cy50b3ApO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMucmlnaHQpO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMuYm90dG9tKTtcbiAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKG91dGxpbmVFbGVtZW50cy5jb250YWluZXIpO1xuICAgICAgd2luLl9fdGFic3Rlck91dGxpbmUuZWxlbWVudHMgPSBvdXRsaW5lRWxlbWVudHM7XG4gICAgICAvLyBUT0RPOiBNYWtlIGEgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byB0aGUgb3V0bGluZXMgd2hpY2ggYXJlIG5vd2hlcmUgaW4gdGhlIERPTSBhbnltb3JlLlxuICAgICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzLnB1c2gob3V0bGluZUVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbi5fX3RhYnN0ZXJPdXRsaW5lLmVsZW1lbnRzO1xuICB9XG4gIF9yZW1vdmVET00oY29udGV4dEVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBjb250ZXh0RWxlbWVudC5vd25lckRvY3VtZW50ICYmIGNvbnRleHRFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3Qgb3V0bGluZSA9IHdpbiAmJiB3aW4uX190YWJzdGVyT3V0bGluZTtcbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG91dGxpbmUuc3R5bGUgJiYgb3V0bGluZS5zdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICBvdXRsaW5lLnN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0bGluZS5zdHlsZSk7XG4gICAgICBkZWxldGUgb3V0bGluZS5zdHlsZTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gb3V0bGluZSAmJiBvdXRsaW5lLmVsZW1lbnRzO1xuICAgIGlmIChvdXRsaW5lRWxlbWVudHMpIHtcbiAgICAgIGlmIChvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG91dGxpbmVFbGVtZW50cy5jb250YWluZXIpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG91dGxpbmUuZWxlbWVudHM7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaXNQYXJlbnRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkID09PSBwYXJlbnQgfHxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgICEhKHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihjaGlsZCkgJiBkb2N1bWVudC5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdHlsZXMoZG9jdW1lbnQsIHByb3BzKSB7XG4gIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShnZXRPdXRsaW5lU3R5bGVzKHByb3BzKSkpO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0T3V0bGluZVN0eWxlcyhwcm9wcykge1xuICByZXR1cm4gYFxuLiR7cHJvcHMuYXJlYUNsYXNzfSAqLCAuJHtwcm9wcy5hcmVhQ2xhc3N9ICo6Zm9jdXMge1xub3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xufVxuXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9IHtcbmRpc3BsYXk6IG5vbmU7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG53aWR0aDogMDtcbmhlaWdodDogMDtcbmxlZnQ6IDA7XG50b3A6IDA7XG56LWluZGV4OiAke3Byb3BzLnpJbmRleH07XG59XG5cbi4ke3Byb3BzLm91dGxpbmVDbGFzc30uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X3Zpc2libGUge1xuZGlzcGxheTogYmxvY2s7XG59XG5cbi4ke3Byb3BzLm91dGxpbmVDbGFzc31fX2xlZnQsXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X190b3AsXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X19yaWdodCxcbi4ke3Byb3BzLm91dGxpbmVDbGFzc31fX2JvdHRvbSB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG5iYWNrZ3JvdW5kOiBpbmhlcml0O1xufWA7XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQWxsb3dzIGRlZmF1bHQgb3IgdXNlciBmb2N1cyBiZWhhdmlvdXIgb24gdGhlIERPTSBzdWJ0cmVlXG4gKiBpLmUuIFRhYnN0ZXIgd2lsbCBub3QgY29udHJvbCBmb2N1cyBldmVudHMgd2l0aGluIGFuIHVuY29udHJvbGxlZCBhcmVhXG4gKi9cbmNsYXNzIFVuY29udHJvbGxlZEFQSSB7XG4gIGNvbnN0cnVjdG9yKGlzVW5jb250cm9sbGVkQ29tcGxldGVseSkge1xuICAgIHRoaXMuX2lzVW5jb250cm9sbGVkQ29tcGxldGVseSA9IGlzVW5jb250cm9sbGVkQ29tcGxldGVseTtcbiAgfVxuICBpc1VuY29udHJvbGxlZENvbXBsZXRlbHkoZWxlbWVudCwgY29tcGxldGVseSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpc1VuY29udHJvbGxlZENvbXBsZXRlbHkgPSAoX2EgPSB0aGlzLl9pc1VuY29udHJvbGxlZENvbXBsZXRlbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVsZW1lbnQsIGNvbXBsZXRlbHkpO1xuICAgIC8vIElmIGlzVW5jb250cm9sbGVkQ29tcGxldGVseSBjYWxsYmFjayBpcyBub3QgZGVmaW5lZCBvciByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgZGVmYXVsdFxuICAgIC8vIGJlaGF2aW91ciBpcyB0byByZXR1cm4gdGhlIHVuY29udHJvbGxlZC5jb21wbGV0ZWx5IHZhbHVlIGZyb20gdGhlIGVsZW1lbnQuXG4gICAgcmV0dXJuIGlzVW5jb250cm9sbGVkQ29tcGxldGVseSA9PT0gdW5kZWZpbmVkID8gY29tcGxldGVseSA6IGlzVW5jb250cm9sbGVkQ29tcGxldGVseTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBSZXN0b3JlciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgcHJvcHMpO1xuICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5fb25Gb2N1c091dCA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IChfYSA9IHRoaXMuX2VsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICAgIGlmIChlbGVtZW50ICYmIGUucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFJlc3RvcmVyUmVzdG9yZUZvY3VzRXZlbnQoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCAmJiAhZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzSW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9oYXNGb2N1cyA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAodGhpcy5fcHJvcHMudHlwZSA9PT0gUmVzdG9yZXJUeXBlcy5Tb3VyY2UpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQpO1xuICAgICAgZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX29uRm9jdXNJbik7XG4gICAgICAvLyBzZXQgaGFzRm9jdXMgd2hlbiB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCwgaW4gY2FzZSBmb2N1cyBoYXMgYWxyZWFkeSBtb3ZlZCB3aXRoaW4gaXRcbiAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlbGVtZW50ICYmIGRvbS5nZXRBY3RpdmVFbGVtZW50KGVsZW1lbnQub3duZXJEb2N1bWVudCkpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5fcHJvcHMudHlwZSA9PT0gUmVzdG9yZXJUeXBlcy5Tb3VyY2UpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQpO1xuICAgICAgZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX29uRm9jdXNJbik7XG4gICAgICBpZiAodGhpcy5faGFzRm9jdXMpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5fdGFic3Rlci5nZXRXaW5kb3coKS5kb2N1bWVudDtcbiAgICAgICAgZG9jLmJvZHkuZGlzcGF0Y2hFdmVudChuZXcgUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIEhpc3Rvcnkge1xuICBjb25zdHJ1Y3RvcihnZXRXaW5kb3cpIHtcbiAgICB0aGlzLl9zdGFjayA9IFtdO1xuICAgIHRoaXMuX2dldFdpbmRvdyA9IGdldFdpbmRvdztcbiAgfVxuICAvKipcbiAgICogUHVzaCBhIHdlYWsgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKiBJZiB0aGUgc3RhY2sgaXMgZnVsbCwgdGhlIGJvdHRvbSB3ZWFrIGVsZW1lbnQgaXMgcmVtb3ZlZC5cbiAgICogSWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjaywgaXQgaXMgbm90IGR1cGxpY2F0ZWQuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gRG9uJ3QgZHVwbGljYXRlIHRoZSB0b3Agb2YgaGlzdG9yeVxuICAgIGlmICgoKF9hID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKSkgPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA+IEhpc3RvcnkuREVQVEgpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl9nZXRXaW5kb3csIGVsZW1lbnQpKTtcbiAgfVxuICAvKipcbiAgICogUG9wIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGhpc3RvcnkgdGhhdCBzYXRpc2ZpZXMgdGhlIGNhbGxiYWNrLlxuICAgKiBUaGUgaGlzdG9yeSBpcyBzZWFyY2hlZCBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbSAoZnJvbSB0aGUgbW9zdCByZWNlbnQgdG8gdGhlIGxlYXN0IHJlY2VudCkuXG4gICAqXG4gICAqIElmIGEgd2VhayByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgaXMgYnJva2VuLFxuICAgKiBvciB0aGUgZWxlbWVudCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSxcbiAgICogdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHdoaWxlIHBvcHBpbmcuXG4gICAqXG4gICAqIElmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICogSWYgdGhlIHN0YWNrIGlzIGVtcHR5LCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBwb3AoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmaWx0ZXIgPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZG9jID0gdGhpcy5fZ2V0V2luZG93KCkuZG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLl9zdGFjay5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBtYXliZUVsZW1lbnQgPSAoX2EgPSB0aGlzLl9zdGFjay5wb3AoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpO1xuICAgICAgaWYgKG1heWJlRWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGRvYy5ib2R5LCBkb20uZ2V0UGFyZW50RWxlbWVudChtYXliZUVsZW1lbnQpKSAmJiBmaWx0ZXIobWF5YmVFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gbWF5YmVFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5IaXN0b3J5LkRFUFRIID0gMTA7XG5jbGFzcyBSZXN0b3JlckFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLl9vblJlc3RvcmVGb2N1cyA9IGUgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50U3RhdGUuY2FuY2VsQXN5bmNGb2N1cyhBc3luY0ZvY3VzU291cmNlcy5SZXN0b3Jlcik7XG4gICAgICAvLyBTaGFkb3dET00gd2lsbCBoYXZlIHNoYWRvd1Jvb3QgYXMgZS50YXJnZXQuXG4gICAgICBjb25zdCBzb3VyY2UgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAvLyBzb3VyY2UgaWQgbXVzdCBiZSByZWNvdmVyZWQgYmVmb3JlIHNvdXJjZSBpcyByZW1vdmVkIGZyb20gRE9NXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdsbCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICAvLyAoYXMgdGFic3RlciBvbiBlbGVtZW50IHdpbGwgbm90IGJlIGF2YWlsYWJsZSB0aHJvdWdoIGdldFRhYnN0ZXJPbkVsZW1lbnQpXG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gKF9iID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBzb3VyY2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdG9yZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQcm9wcygpLmlkO1xuICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudFN0YXRlLnJlcXVlc3RBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLlJlc3RvcmVyLCAoKSA9PiB0aGlzLl9yZXN0b3JlRm9jdXMoc291cmNlLCBzb3VyY2VJZCksIDApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c0luID0gZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFic3RlckF0dHJpYnV0ZSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgICBpZiAoKChfYSA9IHRhYnN0ZXJBdHRyaWJ1dGUgPT09IG51bGwgfHwgdGFic3RlckF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFic3RlckF0dHJpYnV0ZS5yZXN0b3JlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHlwZSkgIT09IFJlc3RvcmVyVHlwZXMuVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChlbGVtZW50KTtcbiAgICB9O1xuICAgIHRoaXMuX3Jlc3RvcmVGb2N1cyA9IChzb3VyY2UsIHNvdXJjZUlkKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBkb24ndCByZXN0b3JlIGZvY3VzIGlmIGZvY3VzIGlzbid0IGxvc3QgdG8gYm9keVxuICAgICAgY29uc3QgZG9jID0gdGhpcy5fZ2V0V2luZG93KCkuZG9jdW1lbnQ7XG4gICAgICBpZiAoZG9tLmdldEFjdGl2ZUVsZW1lbnQoZG9jKSAhPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgLy8gY2xpY2tpbmcgb24gYW55IGVtcHR5IHNwYWNlIGZvY3VzZXMgYm9keSAtIHRoaXMgaXMgY2FuIGJlIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICF0aGlzLl9rZXlib2FyZE5hdlN0YXRlLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpICYmXG4gICAgICAvLyBTb3VyY2Ugbm8gbG9uZ2VyIGV4aXN0cyBvbiBET00gLSBhbHdheXMgcmVzdG9yZSBmb2N1c1xuICAgICAgZG9tLm5vZGVDb250YWlucyhkb2MuYm9keSwgc291cmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBnZXRJZCA9IGVsZW1lbnQgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCByZXN0b3JlclByb3BzID0gKF9iID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3RvcmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0UHJvcHMoKTtcbiAgICAgICAgLy8gV2UgcmV0dXJuIGlkIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBhY3R1YWwgcmVzdG9yZXIgb24gdGhlIGVsZW1lbnQsXG4gICAgICAgIC8vIGFuZCBudWxsIG90aGVyd2lzZS4gVG8gZmlsdGVyIG91dCBlbGVtZW50cyB0aGF0IGhhZCByZXN0b3JlcnMgaW4gdGhlaXIgbGlmZXRpbWVcbiAgICAgICAgLy8gYnV0IGRvbid0IGhhdmUgdGhlbSBhbnltb3JlLlxuICAgICAgICByZXR1cm4gcmVzdG9yZXJQcm9wcyA/IHJlc3RvcmVyUHJvcHMuaWQgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIC8vIHNvdXJjZUlkIGlzIHVuZGVmaW5lZCBvciBzdHJpbmcsIGlmIHRoZXJlIGlzIG5vIFJlc3RvcmVyIG9uIHRoZSB0YXJnZXQsIHRoZSBlbGVtZW50IHdpbGxcbiAgICAgIC8vIGJlIGZpbHRlcmVkIG91dCBiZWNhdXNlIGdldElkKCkgd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgIChfYSA9IHRoaXMuX2hpc3RvcnkucG9wKHRhcmdldCA9PiBzb3VyY2VJZCA9PT0gZ2V0SWQodGFyZ2V0KSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fZ2V0V2luZG93ID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGhpcy5fZ2V0V2luZG93KCkuYWRkRXZlbnRMaXN0ZW5lcihSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSwgdGhpcy5fb25SZXN0b3JlRm9jdXMpO1xuICAgIHRoaXMuX2hpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLl9nZXRXaW5kb3cpO1xuICAgIHRoaXMuX2tleWJvYXJkTmF2U3RhdGUgPSB0YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbjtcbiAgICB0aGlzLl9mb2N1c2VkRWxlbWVudFN0YXRlID0gdGFic3Rlci5mb2N1c2VkRWxlbWVudDtcbiAgICB0aGlzLl9mb2N1c2VkRWxlbWVudFN0YXRlLnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzSW4pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRTdGF0ZS51bnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzSW4pO1xuICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50U3RhdGUuY2FuY2VsQXN5bmNGb2N1cyhBc3luY0ZvY3VzU291cmNlcy5SZXN0b3Jlcik7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uUmVzdG9yZUZvY3VzKTtcbiAgfVxuICBjcmVhdGVSZXN0b3JlcihlbGVtZW50LCBwcm9wcykge1xuICAgIGNvbnN0IHJlc3RvcmVyID0gbmV3IFJlc3RvcmVyKHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICAvLyBGb2N1cyBtaWdodCBhbHJlYWR5IGJlIG9uIGEgcmVzdG9yZXIgdGFyZ2V0IHdoZW4gaXQgZ2V0cyBjcmVhdGVkIHNvIHRoZSBmb2N1c2luIHdpbGwgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHByb3BzLnR5cGUgPT09IFJlc3RvcmVyVHlwZXMuVGFyZ2V0ICYmIGRvbS5nZXRBY3RpdmVFbGVtZW50KGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT09IGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3RvcmVyO1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIHZhciBfYTtcbiAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKChfYSA9IGFjdGl2ZUVsZW1lbnQgPT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlRWxlbWVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5vZGVDb250YWlucyhub2RlLCBvdGhlck5vZGUpIHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKCFub2RlIHx8ICFvdGhlck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnROb2RlID0gb3RoZXJOb2RlO1xuICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnJlbnROb2RlLmFzc2lnbmVkRWxlbWVudHMgIT09IFwiZnVuY3Rpb25cIiAmJiAoKF9hID0gY3VycmVudE5vZGUuYXNzaWduZWRTbG90KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50Tm9kZSkpIHtcbiAgICAgIC8vIEVsZW1lbnQgaXMgc2xvdHRlZFxuICAgICAgY3VycmVudE5vZGUgPSAoX2IgPSBjdXJyZW50Tm9kZS5hc3NpZ25lZFNsb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IGRvY3VtZW50LkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIC8vIEVsZW1lbnQgaXMgaW4gc2hhZG93IHJvb3RcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBub2RlLmhvc3QpIHtcbiAgICByZXR1cm4gbm9kZS5ob3N0O1xuICB9XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgZm9yIChsZXQgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7IHBhcmVudE5vZGU7IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgIGNvbnN0IGNoaWxkID0gZ2V0Rmlyc3RDaGlsZChub2RlLnNoYWRvd1Jvb3QpO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgYXR0YWNoZWQgc2hhZG93Um9vdCBoYXMgbm8gY2hpbGRyZW4sIGp1c3QgdHJ5IG9yZGluYXJ5IGNoaWxkcmVuLFxuICAgIC8vIHRoYXQgbWlnaHQgY29tZSBhZnRlci5cbiAgfVxuICByZXR1cm4gbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gZ2V0TGFzdENoaWxkJDEobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIW5vZGUubGFzdENoaWxkICYmIG5vZGUuc2hhZG93Um9vdCkge1xuICAgIHJldHVybiBnZXRMYXN0Q2hpbGQkMShub2RlLnNoYWRvd1Jvb3QpO1xuICB9XG4gIHJldHVybiBub2RlLmxhc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubmV4dFNpYmxpbmcpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1NpYmxpbmcobm9kZSkge1xuICB2YXIgX2E7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIGlmICghc2libGluZyAmJiAoKF9hID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hhZG93Um9vdCkpIHtcbiAgICBzaWJsaW5nID0gZ2V0TGFzdENoaWxkJDEobm9kZS5wYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QpO1xuICB9XG4gIHJldHVybiBzaWJsaW5nO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RFbGVtZW50Q2hpbGQoZWxlbWVudCkge1xuICBsZXQgY2hpbGQgPSBnZXRGaXJzdENoaWxkKGVsZW1lbnQpO1xuICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgY2hpbGQgPSBnZXROZXh0U2libGluZyhjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEVsZW1lbnRDaGlsZChlbGVtZW50KSB7XG4gIGxldCBjaGlsZCA9IGdldExhc3RDaGlsZCQxKGVsZW1lbnQpO1xuICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgY2hpbGQgPSBnZXRQcmV2aW91c1NpYmxpbmcoY2hpbGQpO1xuICB9XG4gIHJldHVybiBjaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE5leHRFbGVtZW50U2libGluZyhlbGVtZW50KSB7XG4gIGxldCBzaWJsaW5nID0gZ2V0TmV4dFNpYmxpbmcoZWxlbWVudCk7XG4gIHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgc2libGluZyA9IGdldE5leHRTaWJsaW5nKHNpYmxpbmcpO1xuICB9XG4gIHJldHVybiBzaWJsaW5nO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbGVtZW50KSB7XG4gIGxldCBzaWJsaW5nID0gZ2V0UHJldmlvdXNTaWJsaW5nKGVsZW1lbnQpO1xuICB3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHNpYmxpbmcgPSBnZXRQcmV2aW91c1NpYmxpbmcoc2libGluZyk7XG4gIH1cbiAgcmV0dXJuIHNpYmxpbmc7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGNvbnN0IHNoYWRvd1Jvb3QgPSBwYXJlbnQuc2hhZG93Um9vdDtcbiAgcmV0dXJuIHNoYWRvd1Jvb3QgPyBzaGFkb3dSb290LmFwcGVuZENoaWxkKGNoaWxkKSA6IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50LCBjaGlsZCwgcmVmZXJlbmNlQ2hpbGQpIHtcbiAgY29uc3Qgc2hhZG93Um9vdCA9IHBhcmVudC5zaGFkb3dSb290O1xuICByZXR1cm4gc2hhZG93Um9vdCA/IHNoYWRvd1Jvb3QuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2VDaGlsZCkgOiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2VDaGlsZCk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocmVmKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgd2luID0gKF9hID0gcmVmLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGxldCBlbCA9IHJlZjsgZWw7IGVsID0gZWwucGFyZW50Tm9kZSkge1xuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICBjb25zdCB0bXAgPSBlbDtcbiAgICAgIC8vIFNoYWRvd1Jvb3QuZ2V0U2VsZWN0aW9uKCkgZXhpc3RzIG9ubHkgaW4gQ2hyb21lLlxuICAgICAgaWYgKHRtcC5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRtcC5nZXRTZWxlY3Rpb24oKSB8fCBudWxsO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB3aW4uZ2V0U2VsZWN0aW9uKCkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzQnlOYW1lKHJlZmVyZW5jZUVsZW1lbnQsIG5hbWUpIHtcbiAgZm9yIChsZXQgZWwgPSByZWZlcmVuY2VFbGVtZW50OyBlbDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIC8vIFNoYWRvdyByb290IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50c0J5TmFtZSgpLi4uXG4gICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChgW25hbWU9JHtuYW1lfV1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZUVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKTtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdENoaWxkKGNvbnRhaW5lcikge1xuICBsZXQgbGFzdENoaWxkID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IGdldExhc3RFbGVtZW50Q2hpbGQoY29udGFpbmVyKTsgaTsgaSA9IGdldExhc3RFbGVtZW50Q2hpbGQoaSkpIHtcbiAgICBsYXN0Q2hpbGQgPSBpO1xuICB9XG4gIHJldHVybiBsYXN0Q2hpbGQgfHwgdW5kZWZpbmVkO1xufVxuY2xhc3MgU2hhZG93VHJlZVdhbGtlciB7XG4gIGNvbnN0cnVjdG9yKGRvYywgcm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSB7XG4gICAgdGhpcy5fd2Fsa2VyU3RhY2sgPSBbXTtcbiAgICB0aGlzLl9jdXJyZW50U2V0Rm9yID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2FjY2VwdE5vZGUgPSBub2RlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbm9kZS5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbnN0IHdhbGtlciA9IHRoaXMuX2RvYy5jcmVhdGVUcmVlV2Fsa2VyKHNoYWRvd1Jvb3QsIHRoaXMud2hhdFRvU2hvdywge1xuICAgICAgICAgICAgYWNjZXB0Tm9kZTogdGhpcy5fYWNjZXB0Tm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3dhbGtlclN0YWNrLnVuc2hpZnQod2Fsa2VyKTtcbiAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5maWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKF9hID0gdGhpcy5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NlcHROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfTtcbiAgICB0aGlzLl9kb2MgPSBkb2M7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IG51bGw7XG4gICAgdGhpcy53aGF0VG9TaG93ID0gd2hhdFRvU2hvdyAhPT0gbnVsbCAmJiB3aGF0VG9TaG93ICE9PSB2b2lkIDAgPyB3aGF0VG9TaG93IDogTm9kZUZpbHRlci5TSE9XX0FMTDtcbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IHJvb3Q7XG4gICAgdGhpcy5fd2Fsa2VyU3RhY2sudW5zaGlmdChkb2MuY3JlYXRlVHJlZVdhbGtlcihyb290LCB3aGF0VG9TaG93LCB0aGlzLl9hY2NlcHROb2RlKSk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IHJvb3Quc2hhZG93Um9vdDtcbiAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gdGhpcy5fZG9jLmNyZWF0ZVRyZWVXYWxrZXIoc2hhZG93Um9vdCwgdGhpcy53aGF0VG9TaG93LCB7XG4gICAgICAgIGFjY2VwdE5vZGU6IHRoaXMuX2FjY2VwdE5vZGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fd2Fsa2VyU3RhY2sudW5zaGlmdCh3YWxrZXIpO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnROb2RlO1xuICB9XG4gIHNldCBjdXJyZW50Tm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlQ29udGFpbnModGhpcy5yb290LCBub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBjdXJyZW50Tm9kZSB0byBhIG5vZGUgdGhhdCBpcyBub3QgY29udGFpbmVkIGJ5IHRoZSByb290IG5vZGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCB3YWxrZXJzID0gW107XG4gICAgbGV0IGN1ck5vZGUgPSBub2RlO1xuICAgIGxldCBjdXJyZW50V2Fsa2VyQ3VycmVudE5vZGUgPSBub2RlO1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAoY3VyTm9kZSAmJiBjdXJOb2RlICE9PSB0aGlzLnJvb3QpIHtcbiAgICAgIGlmIChjdXJOb2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGN1ck5vZGU7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IHRoaXMuX2RvYy5jcmVhdGVUcmVlV2Fsa2VyKHNoYWRvd1Jvb3QsIHRoaXMud2hhdFRvU2hvdywge1xuICAgICAgICAgIGFjY2VwdE5vZGU6IHRoaXMuX2FjY2VwdE5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHdhbGtlcnMucHVzaCh3YWxrZXIpO1xuICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBjdXJyZW50V2Fsa2VyQ3VycmVudE5vZGU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTZXRGb3IuYWRkKHdhbGtlcik7XG4gICAgICAgIGN1ck5vZGUgPSBjdXJyZW50V2Fsa2VyQ3VycmVudE5vZGUgPSBzaGFkb3dSb290Lmhvc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YWxrZXIgPSB0aGlzLl9kb2MuY3JlYXRlVHJlZVdhbGtlcih0aGlzLnJvb3QsIHRoaXMud2hhdFRvU2hvdywge1xuICAgICAgYWNjZXB0Tm9kZTogdGhpcy5fYWNjZXB0Tm9kZVxuICAgIH0pO1xuICAgIHdhbGtlcnMucHVzaCh3YWxrZXIpO1xuICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGN1cnJlbnRXYWxrZXJDdXJyZW50Tm9kZTtcbiAgICB0aGlzLl9jdXJyZW50U2V0Rm9yLmFkZCh3YWxrZXIpO1xuICAgIHRoaXMuX3dhbGtlclN0YWNrID0gd2Fsa2VycztcbiAgfVxuICBmaXJzdENoaWxkKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxhc3RDaGlsZCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBuZXh0Tm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbmV4dE5vZGUgPSB0aGlzLl93YWxrZXJTdGFja1swXS5uZXh0Tm9kZSgpO1xuICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG5leHROb2RlLnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBsZXQgbm9kZVJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbm9kZVJlc3VsdCA9IHRoaXMuZmlsdGVyKG5leHROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2EgPSB0aGlzLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2VwdE5vZGUpIHtcbiAgICAgICAgICBub2RlUmVzdWx0ID0gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShuZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVSZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBfYWNjZXB0Tm9kZSBzaG91bGQgaGF2ZSBhZGRlZCBuZXcgd2Fsa2VyIGZvciB0aGlzIHNoYWRvdyxcbiAgICAgICAgLy8gZ28gaW4gcmVjdXJzaXZlbHkuXG4gICAgICAgIHJldHVybiB0aGlzLm5leHROb2RlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl93YWxrZXJTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX3dhbGtlclN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHROb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJldmlvdXNOb2RlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY3VycmVudFdhbGtlciA9IHRoaXMuX3dhbGtlclN0YWNrWzBdO1xuICAgIGlmIChjdXJyZW50V2Fsa2VyLmN1cnJlbnROb2RlID09PSBjdXJyZW50V2Fsa2VyLnJvb3QpIHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50U2V0Rm9yLmhhcyhjdXJyZW50V2Fsa2VyKSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50U2V0Rm9yLmRlbGV0ZShjdXJyZW50V2Fsa2VyKTtcbiAgICAgICAgaWYgKHRoaXMuX3dhbGtlclN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl93YWxrZXJTdGFjay5zaGlmdCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzTm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBnZXRMYXN0Q2hpbGQoY3VycmVudFdhbGtlci5yb290KTtcbiAgICAgIGlmIChsYXN0Q2hpbGQpIHtcbiAgICAgICAgY3VycmVudFdhbGtlci5jdXJyZW50Tm9kZSA9IGxhc3RDaGlsZDtcbiAgICAgICAgbGV0IG5vZGVSZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5maWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG5vZGVSZXN1bHQgPSB0aGlzLmZpbHRlcihsYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKChfYSA9IHRoaXMuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXB0Tm9kZSkge1xuICAgICAgICAgIG5vZGVSZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKGxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVSZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gY3VycmVudFdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICBpZiAocHJldmlvdXNOb2RlKSB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gcHJldmlvdXNOb2RlLnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBsZXQgbm9kZVJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbm9kZVJlc3VsdCA9IHRoaXMuZmlsdGVyKHByZXZpb3VzTm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKF9iID0gdGhpcy5maWx0ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2NlcHROb2RlKSB7XG4gICAgICAgICAgbm9kZVJlc3VsdCA9IHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUocHJldmlvdXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZpb3VzTm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBfYWNjZXB0Tm9kZSBzaG91bGQgaGF2ZSBhZGRlZCBuZXcgd2Fsa2VyIGZvciB0aGlzIHNoYWRvdyxcbiAgICAgICAgLy8gZ28gaW4gcmVjdXJzaXZlbHkuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzTm9kZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3dhbGtlclN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fd2Fsa2VyU3RhY2suc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNOb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV4dFNpYmxpbmcoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcHJldmlvdXNTaWJsaW5nKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHBhcmVudE5vZGUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRvd1RyZWVXYWxrZXIoZG9jLCByb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgcmV0dXJuIG5ldyBTaGFkb3dUcmVlV2Fsa2VyKGRvYywgcm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKTtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY2xhc3MgU2hhZG93TXV0YXRpb25PYnNlcnZlciB7XG4gIHN0YXRpYyBfb3ZlcnJpZGVBdHRhY2hTaGFkb3cod2luKSB7XG4gICAgY29uc3Qgb3JpZ0F0dGFjaFNoYWRvdyA9IHdpbi5FbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3c7XG4gICAgaWYgKG9yaWdBdHRhY2hTaGFkb3cuX19vcmlnQXR0YWNoU2hhZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gb3JpZ0F0dGFjaFNoYWRvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgZm9yIChjb25zdCBzaGFkb3dPYnNlcnZlciBvZiBTaGFkb3dNdXRhdGlvbk9ic2VydmVyLl9zaGFkb3dPYnNlcnZlcnMpIHtcbiAgICAgICAgc2hhZG93T2JzZXJ2ZXIuX2FkZFN1Yk9ic2VydmVyKHNoYWRvd1Jvb3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYWRvd1Jvb3Q7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cuX19vcmlnQXR0YWNoU2hhZG93ID0gb3JpZ0F0dGFjaFNoYWRvdztcbiAgfVxuICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgIHRoaXMuX2lzT2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY2FsbGJhY2tXcmFwcGVyID0gKG11dGF0aW9ucywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcbiAgICAgICAgICBjb25zdCBhZGRlZCA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl93YWxrU2hhZG93cyhyZW1vdmVkW2ldLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fd2Fsa1NoYWRvd3MoYWRkZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FsbGJhY2sobXV0YXRpb25zLCBvYnNlcnZlcik7XG4gICAgfTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fY2FsbGJhY2tXcmFwcGVyKTtcbiAgICB0aGlzLl9zdWJPYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgX2FkZFN1Yk9ic2VydmVyKHNoYWRvd1Jvb3QpIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMgfHwgIXRoaXMuX2NhbGxiYWNrIHx8IHRoaXMuX3N1Yk9ic2VydmVycy5oYXMoc2hhZG93Um9vdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc3VidHJlZSAmJiBub2RlQ29udGFpbnModGhpcy5fcm9vdCwgc2hhZG93Um9vdCkpIHtcbiAgICAgIGNvbnN0IHN1Yk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fY2FsbGJhY2tXcmFwcGVyKTtcbiAgICAgIHRoaXMuX3N1Yk9ic2VydmVycy5zZXQoc2hhZG93Um9vdCwgc3ViT2JzZXJ2ZXIpO1xuICAgICAgaWYgKHRoaXMuX2lzT2JzZXJ2aW5nKSB7XG4gICAgICAgIHN1Yk9ic2VydmVyLm9ic2VydmUoc2hhZG93Um9vdCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLl93YWxrU2hhZG93cyhzaGFkb3dSb290KTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9pc09ic2VydmluZyA9IGZhbHNlO1xuICAgIGRlbGV0ZSB0aGlzLl9vcHRpb25zO1xuICAgIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIuX3NoYWRvd09ic2VydmVycy5kZWxldGUodGhpcyk7XG4gICAgZm9yIChjb25zdCBzdWJPYnNlcnZlciBvZiB0aGlzLl9zdWJPYnNlcnZlcnMudmFsdWVzKCkpIHtcbiAgICAgIHN1Yk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5fc3ViT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIG9ic2VydmUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZG9jID0gdGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUgPyB0YXJnZXQgOiB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICBjb25zdCB3aW4gPSBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFkb2MgfHwgIXdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBTaGFkb3dNdXRhdGlvbk9ic2VydmVyLl9vdmVycmlkZUF0dGFjaFNoYWRvdyh3aW4pO1xuICAgIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIuX3NoYWRvd09ic2VydmVycy5hZGQodGhpcyk7XG4gICAgdGhpcy5fcm9vdCA9IHRhcmdldDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9pc09ic2VydmluZyA9IHRydWU7XG4gICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX3dhbGtTaGFkb3dzKHRhcmdldCk7XG4gIH1cbiAgX3dhbGtTaGFkb3dzKHRhcmdldCwgcmVtb3ZlKSB7XG4gICAgY29uc3QgZG9jID0gdGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUgPyB0YXJnZXQgOiB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSBkb2MpIHtcbiAgICAgIHRhcmdldCA9IGRvYy5ib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gdGFyZ2V0LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLl9hZGRTdWJPYnNlcnZlcihzaGFkb3dSb290KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YWxrZXIgPSBkb2MuY3JlYXRlVHJlZVdhbGtlcih0YXJnZXQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICBhY2NlcHROb2RlOiBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViT2JzZXJ2ZXIgPSB0aGlzLl9zdWJPYnNlcnZlcnMuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKHN1Yk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgIHN1Yk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fc3ViT2JzZXJ2ZXJzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG5vZGUuc2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFN1Yk9ic2VydmVyKHNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3YWxrZXIubmV4dE5vZGUoKTtcbiAgfVxuICB0YWtlUmVjb3JkcygpIHtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5fb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICBmb3IgKGNvbnN0IHN1Yk9ic2VydmVyIG9mIHRoaXMuX3N1Yk9ic2VydmVycy52YWx1ZXMoKSkge1xuICAgICAgcmVjb3Jkcy5wdXNoKC4uLnN1Yk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3JkcztcbiAgfVxufVxuU2hhZG93TXV0YXRpb25PYnNlcnZlci5fc2hhZG93T2JzZXJ2ZXJzID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbmZ1bmN0aW9uIGNyZWF0ZVNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBTaGFkb3dNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gc2hhZG93UXVlcnlTZWxlY3Rvcihub2RlLCBzZWxlY3RvciwgYWxsKSB7XG4gIC8vIFRPRE86IFRoaXMgaXMgcHJvYmFibHkgc2xvdy4gT3B0aW1pemUgdG8gdXNlIGVhY2ggc2hhZG93Um9vdCdzIHF1ZXJ5U2VsZWN0b3IvcXVlcnlTZWxlY3RvckFsbFxuICAvLyAgICAgICBpbnN0ZWFkIG9mIHdhbGtpbmcgdGhlIHRyZWUuXG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIHdhbGsobm9kZSwgc2VsZWN0b3IpO1xuICByZXR1cm4gZWxlbWVudHM7XG4gIGZ1bmN0aW9uIHdhbGsoZnJvbSwgc2VsZWN0b3IpIHtcbiAgICBsZXQgZWwgPSBudWxsO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZnJvbSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHtcbiAgICAgIGFjY2VwdE5vZGU6IG4gPT4ge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAobi5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgZWwgPSBuO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsID8gTm9kZUZpbHRlci5GSUxURVJfU0tJUCA6IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG4uc2hhZG93Um9vdDtcbiAgICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgd2FsayhzaGFkb3dSb290LCBzZWxlY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gIWFsbCAmJiBlbGVtZW50cy5sZW5ndGggPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3YWxrZXIubmV4dE5vZGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChub2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gc2hhZG93UXVlcnlTZWxlY3Rvcihub2RlLCBzZWxlY3RvciwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBzaGFkb3dRdWVyeVNlbGVjdG9yKG5vZGUsIHNlbGVjdG9yLCBmYWxzZSlbMF0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGRvYywgaWQpIHtcbiAgcmV0dXJuIHF1ZXJ5U2VsZWN0b3IoZG9jLCBcIiNcIiArIGlkKTtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLy8gVE9ETzogVGhlIGZ1bmN0aW9ucyBiZWxvdyBkbyBub3QgY29uc2lkZXIgU2hhZG93IERPTSBzbG90cyB5ZXQuIFdlIHdpbGwgYmUgYWRkaW5nXG4vLyBzdXBwb3J0IGZvciBzbG90cyBhcyB0aGUgbmVlZCBhcmlzZXMuXG5cbnZhciBzaGFkb3dET01BUEkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBjcmVhdGVNdXRhdGlvbk9ic2VydmVyOiBjcmVhdGVTaGFkb3dNdXRhdGlvbk9ic2VydmVyLFxuICAgIGNyZWF0ZVRyZWVXYWxrZXI6IGNyZWF0ZVNoYWRvd1RyZWVXYWxrZXIsXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogZ2V0QWN0aXZlRWxlbWVudCxcbiAgICBnZXRFbGVtZW50QnlJZDogZ2V0RWxlbWVudEJ5SWQsXG4gICAgZ2V0RWxlbWVudHNCeU5hbWU6IGdldEVsZW1lbnRzQnlOYW1lLFxuICAgIGdldEZpcnN0Q2hpbGQ6IGdldEZpcnN0Q2hpbGQsXG4gICAgZ2V0Rmlyc3RFbGVtZW50Q2hpbGQ6IGdldEZpcnN0RWxlbWVudENoaWxkLFxuICAgIGdldExhc3RDaGlsZDogZ2V0TGFzdENoaWxkJDEsXG4gICAgZ2V0TGFzdEVsZW1lbnRDaGlsZDogZ2V0TGFzdEVsZW1lbnRDaGlsZCxcbiAgICBnZXROZXh0RWxlbWVudFNpYmxpbmc6IGdldE5leHRFbGVtZW50U2libGluZyxcbiAgICBnZXROZXh0U2libGluZzogZ2V0TmV4dFNpYmxpbmcsXG4gICAgZ2V0UGFyZW50RWxlbWVudDogZ2V0UGFyZW50RWxlbWVudCxcbiAgICBnZXRQYXJlbnROb2RlOiBnZXRQYXJlbnROb2RlLFxuICAgIGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmc6IGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcsXG4gICAgZ2V0UHJldmlvdXNTaWJsaW5nOiBnZXRQcmV2aW91c1NpYmxpbmcsXG4gICAgZ2V0U2VsZWN0aW9uOiBnZXRTZWxlY3Rpb24sXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgbm9kZUNvbnRhaW5zOiBub2RlQ29udGFpbnMsXG4gICAgcXVlcnlTZWxlY3RvcjogcXVlcnlTZWxlY3RvcixcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBxdWVyeVNlbGVjdG9yQWxsXG59KTtcblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY2xhc3MgVGFic3RlciB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLmtleWJvYXJkTmF2aWdhdGlvbiA9IHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uO1xuICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50O1xuICAgIHRoaXMuZm9jdXNhYmxlID0gdGFic3Rlci5mb2N1c2FibGU7XG4gICAgdGhpcy5yb290ID0gdGFic3Rlci5yb290O1xuICAgIHRoaXMudW5jb250cm9sbGVkID0gdGFic3Rlci51bmNvbnRyb2xsZWQ7XG4gICAgdGhpcy5jb3JlID0gdGFic3RlcjtcbiAgfVxufVxuLyoqXG4gKiBFeHRlbmRzIFdpbmRvdyB0byBpbmNsdWRlIGFuIGludGVybmFsIFRhYnN0ZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIFRhYnN0ZXJDb3JlIHtcbiAgY29uc3RydWN0b3Iod2luLCBwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdGhpcy5fZm9yZ2V0TWVtb3JpemVkRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl93cmFwcGVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9pbml0UXVldWUgPSBbXTtcbiAgICB0aGlzLl92ZXJzaW9uID0gXCI4LjUuNlwiO1xuICAgIHRoaXMuX25vb3AgPSBmYWxzZTtcbiAgICB0aGlzLmdldFdpbmRvdyA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzaW5nIGRpc3Bvc2VkIFRhYnN0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3dpbjtcbiAgICB9O1xuICAgIHRoaXMuX3N0b3JhZ2UgPSBjcmVhdGVXZWFrTWFwKHdpbik7XG4gICAgdGhpcy5fd2luID0gd2luO1xuICAgIGNvbnN0IGdldFdpbmRvdyA9IHRoaXMuZ2V0V2luZG93O1xuICAgIGlmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuRE9NQVBJKSB7XG4gICAgICBzZXRET01BUEkoe1xuICAgICAgICAuLi5wcm9wcy5ET01BUElcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmtleWJvYXJkTmF2aWdhdGlvbiA9IG5ldyBLZXlib2FyZE5hdmlnYXRpb25TdGF0ZShnZXRXaW5kb3cpO1xuICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQgPSBuZXcgRm9jdXNlZEVsZW1lbnRTdGF0ZSh0aGlzLCBnZXRXaW5kb3cpO1xuICAgIHRoaXMuZm9jdXNhYmxlID0gbmV3IEZvY3VzYWJsZUFQSSh0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdEFQSSh0aGlzLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuYXV0b1Jvb3QpO1xuICAgIHRoaXMudW5jb250cm9sbGVkID0gbmV3IFVuY29udHJvbGxlZEFQSShcbiAgICAvLyBUT0RPOiBSZW1vdmUgY2hlY2tVbmNvbnRyb2xsZWRUcmFwcGluZ0ZvY3VzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jaGVja1VuY29udHJvbGxlZENvbXBsZXRlbHkpIHx8IChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2hlY2tVbmNvbnRyb2xsZWRUcmFwcGluZ0ZvY3VzKSk7XG4gICAgdGhpcy5jb250cm9sVGFiID0gKF9hID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNvbnRyb2xUYWIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgdGhpcy5yb290RHVtbXlJbnB1dHMgPSAhIShwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucm9vdER1bW15SW5wdXRzKTtcbiAgICB0aGlzLl9kdW1teU9ic2VydmVyID0gbmV3IER1bW15SW5wdXRPYnNlcnZlcihnZXRXaW5kb3cpO1xuICAgIHRoaXMuZ2V0UGFyZW50ID0gKF9iID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmdldFBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZG9tLmdldFBhcmVudE5vZGU7XG4gICAgdGhpcy5pbnRlcm5hbCA9IHtcbiAgICAgIHN0b3BPYnNlcnZlcjogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fdW5vYnNlcnZlKSB7XG4gICAgICAgICAgdGhpcy5fdW5vYnNlcnZlKCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3Vub2JzZXJ2ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3VtZU9ic2VydmVyOiBzeW5jU3RhdGUgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3Vub2JzZXJ2ZSkge1xuICAgICAgICAgIGNvbnN0IGRvYyA9IGdldFdpbmRvdygpLmRvY3VtZW50O1xuICAgICAgICAgIHRoaXMuX3Vub2JzZXJ2ZSA9IG9ic2VydmVNdXRhdGlvbnMoZG9jLCB0aGlzLCB1cGRhdGVUYWJzdGVyQnlBdHRyaWJ1dGUsIHN5bmNTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YXJ0RmFrZVdlYWtSZWZzQ2xlYW51cChnZXRXaW5kb3cpO1xuICAgIC8vIEdpdmVzIGEgdGljayB0byB0aGUgaG9zdCBhcHAgdG8gaW5pdGlhbGl6ZSBvdGhlciB0YWJzdGVyXG4gICAgLy8gQVBJcyBiZWZvcmUgdGFic3RlciBzdGFydHMgb2JzZXJ2aW5nIGF0dHJpYnV0ZXMuXG4gICAgdGhpcy5xdWV1ZUluaXQoKCkgPT4ge1xuICAgICAgdGhpcy5pbnRlcm5hbC5yZXN1bWVPYnNlcnZlcih0cnVlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2VzIGV4dGVybmFsIHByb3BzIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMuIE5vdCBhbGxcbiAgICogcHJvcHMgY2FuL3Nob3VsZCBiZSBtZXJnZWFibGUsIHNvIGxldCdzIGFkZCBtb3JlIGFzIHdlIG1vdmUgb24uXG4gICAqIEBwYXJhbSBwcm9wcyBUYWJzdGVyIHByb3BzXG4gICAqL1xuICBfbWVyZ2VQcm9wcyhwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2V0UGFyZW50ID0gKF9hID0gcHJvcHMuZ2V0UGFyZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmdldFBhcmVudDtcbiAgfVxuICBjcmVhdGVUYWJzdGVyKG5vUmVmQ291bnQsIHByb3BzKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBUYWJzdGVyKHRoaXMpO1xuICAgIGlmICghbm9SZWZDb3VudCkge1xuICAgICAgdGhpcy5fd3JhcHBlcnMuYWRkKHdyYXBwZXIpO1xuICAgIH1cbiAgICB0aGlzLl9tZXJnZVByb3BzKHByb3BzKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuICBkaXNwb3NlVGFic3Rlcih3cmFwcGVyLCBhbGxJbnN0YW5jZXMpIHtcbiAgICBpZiAoYWxsSW5zdGFuY2VzKSB7XG4gICAgICB0aGlzLl93cmFwcGVycy5jbGVhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93cmFwcGVycy5kZWxldGUod3JhcHBlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLl93cmFwcGVycy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIHRoaXMuaW50ZXJuYWwuc3RvcE9ic2VydmVyKCk7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luO1xuICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5jbGVhclRpbWVvdXQodGhpcy5faW5pdFRpbWVyKTtcbiAgICBkZWxldGUgdGhpcy5faW5pdFRpbWVyO1xuICAgIHRoaXMuX2luaXRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2ZvcmdldE1lbW9yaXplZEVsZW1lbnRzID0gW107XG4gICAgaWYgKHdpbiAmJiB0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5fZm9yZ2V0TWVtb3JpemVkVGltZXI7XG4gICAgfVxuICAgIChfYSA9IHRoaXMub3V0bGluZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICAoX2IgPSB0aGlzLmNyb3NzT3JpZ2luKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzcG9zZSgpO1xuICAgIChfYyA9IHRoaXMuZGVsb3NlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc3Bvc2UoKTtcbiAgICAoX2QgPSB0aGlzLmdyb3VwcGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGlzcG9zZSgpO1xuICAgIChfZSA9IHRoaXMubW92ZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kaXNwb3NlKCk7XG4gICAgKF9mID0gdGhpcy5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kaXNwb3NlKCk7XG4gICAgKF9nID0gdGhpcy5vYnNlcnZlZEVsZW1lbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5kaXNwb3NlKCk7XG4gICAgKF9oID0gdGhpcy5yZXN0b3JlcikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmtleWJvYXJkTmF2aWdhdGlvbi5kaXNwb3NlKCk7XG4gICAgdGhpcy5mb2N1c2FibGUuZGlzcG9zZSgpO1xuICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgIHRoaXMucm9vdC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZHVtbXlPYnNlcnZlci5kaXNwb3NlKCk7XG4gICAgc3RvcEZha2VXZWFrUmVmc0NsZWFudXBBbmRDbGVhclN0b3JhZ2UodGhpcy5nZXRXaW5kb3cpO1xuICAgIGNsZWFyRWxlbWVudENhY2hlKHRoaXMuZ2V0V2luZG93KTtcbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl93cmFwcGVycy5jbGVhcigpO1xuICAgIGlmICh3aW4pIHtcbiAgICAgIGRpc3Bvc2VJbnN0YW5jZUNvbnRleHQod2luKTtcbiAgICAgIGRlbGV0ZSB3aW4uX190YWJzdGVySW5zdGFuY2U7XG4gICAgICBkZWxldGUgdGhpcy5fd2luO1xuICAgIH1cbiAgfVxuICBzdG9yYWdlRW50cnkoZWxlbWVudCwgYWRkcmVtb3ZlKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gICAgbGV0IGVudHJ5ID0gc3RvcmFnZS5nZXQoZWxlbWVudCk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoYWRkcmVtb3ZlID09PSBmYWxzZSAmJiBPYmplY3Qua2V5cyhlbnRyeSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0b3JhZ2UuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWRkcmVtb3ZlID09PSB0cnVlKSB7XG4gICAgICBlbnRyeSA9IHt9O1xuICAgICAgc3RvcmFnZS5zZXQoZWxlbWVudCwgZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbiAgZm9yY2VDbGVhbnVwKCkge1xuICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZvcmdldE1lbW9yaXplZEVsZW1lbnRzLnB1c2godGhpcy5fd2luLmRvY3VtZW50LmJvZHkpO1xuICAgIGlmICh0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lciA9IHRoaXMuX3dpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lcjtcbiAgICAgIGZvciAobGV0IGVsID0gdGhpcy5fZm9yZ2V0TWVtb3JpemVkRWxlbWVudHMuc2hpZnQoKTsgZWw7IGVsID0gdGhpcy5fZm9yZ2V0TWVtb3JpemVkRWxlbWVudHMuc2hpZnQoKSkge1xuICAgICAgICBjbGVhckVsZW1lbnRDYWNoZSh0aGlzLmdldFdpbmRvdywgZWwpO1xuICAgICAgICBGb2N1c2VkRWxlbWVudFN0YXRlLmZvcmdldE1lbW9yaXplZCh0aGlzLmZvY3VzZWRFbGVtZW50LCBlbCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gICAgY2xlYW51cEZha2VXZWFrUmVmcyh0aGlzLmdldFdpbmRvdywgdHJ1ZSk7XG4gIH1cbiAgcXVldWVJbml0KGNhbGxiYWNrKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICBpZiAoIXRoaXMuX2luaXRUaW1lcikge1xuICAgICAgdGhpcy5faW5pdFRpbWVyID0gKF9hID0gdGhpcy5fd2luKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pbml0VGltZXI7XG4gICAgICAgIHRoaXMuZHJhaW5Jbml0UXVldWUoKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBkcmFpbkluaXRRdWV1ZSgpIHtcbiAgICBpZiAoIXRoaXMuX3dpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX2luaXRRdWV1ZTtcbiAgICAvLyBSZXNldHRpbmcgdGhlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFja3MgdG8gYXZvaWQgcmVjdXJzaW9uLlxuICAgIHRoaXMuX2luaXRRdWV1ZSA9IFtdO1xuICAgIHF1ZXVlLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcmNlQ2xlYW51cCh0YWJzdGVyKSB7XG4gIC8vIFRoZSBvbmx5IGxlZ2l0IGNhc2UgZm9yIGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgd2hlbiB5b3UndmUgY29tcGxldGVseSByZW1vdmVkXG4gIC8vIHRoZSBhcHBsaWNhdGlvbiBET00gYW5kIG5vdCBnb2luZyB0byBhZGQgdGhlIG5ldyBvbmUgZm9yIGEgd2hpbGUuXG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICB0YWJzdGVyQ29yZS5mb3JjZUNsZWFudXAoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUYWJzdGVyLCByZXR1cm5zIHRoZSBjdXJyZW50IHdpbmRvdyBpbnN0YW5jZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGFic3Rlcih3aW4sIHByb3BzKSB7XG4gIGxldCB0YWJzdGVyID0gZ2V0Q3VycmVudFRhYnN0ZXIod2luKTtcbiAgaWYgKHRhYnN0ZXIpIHtcbiAgICByZXR1cm4gdGFic3Rlci5jcmVhdGVUYWJzdGVyKGZhbHNlLCBwcm9wcyk7XG4gIH1cbiAgdGFic3RlciA9IG5ldyBUYWJzdGVyQ29yZSh3aW4sIHByb3BzKTtcbiAgd2luLl9fdGFic3Rlckluc3RhbmNlID0gdGFic3RlcjtcbiAgcmV0dXJuIHRhYnN0ZXIuY3JlYXRlVGFic3RlcigpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFRhYnN0ZXIgaWYgaXQgd2FzIGNyZWF0ZWQgYmVmb3JlIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFRhYnN0ZXIod2luKSB7XG4gIGNvbnN0IHRhYnN0ZXIgPSBnZXRDdXJyZW50VGFic3Rlcih3aW4pO1xuICByZXR1cm4gdGFic3RlciA/IHRhYnN0ZXIuY3JlYXRlVGFic3Rlcih0cnVlKSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dET01BUEkoKSB7XG4gIHJldHVybiBzaGFkb3dET01BUEk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZ3JvdXBwZXIgaW5zdGFuY2Ugb3IgcmV0dXJucyBhbiBleGlzdGluZyBvbmVcbiAqIEBwYXJhbSB0YWJzdGVyIFRhYnN0ZXIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0R3JvdXBwZXIodGFic3Rlcikge1xuICBjb25zdCB0YWJzdGVyQ29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgaWYgKCF0YWJzdGVyQ29yZS5ncm91cHBlcikge1xuICAgIHRhYnN0ZXJDb3JlLmdyb3VwcGVyID0gbmV3IEdyb3VwcGVyQVBJKHRhYnN0ZXJDb3JlLCB0YWJzdGVyQ29yZS5nZXRXaW5kb3cpO1xuICB9XG4gIHJldHVybiB0YWJzdGVyQ29yZS5ncm91cHBlcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtb3ZlciBpbnN0YW5jZSBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZVxuICogQHBhcmFtIHRhYnN0ZXIgVGFic3RlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXRNb3Zlcih0YWJzdGVyKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLm1vdmVyKSB7XG4gICAgdGFic3RlckNvcmUubW92ZXIgPSBuZXcgTW92ZXJBUEkodGFic3RlckNvcmUsIHRhYnN0ZXJDb3JlLmdldFdpbmRvdyk7XG4gIH1cbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLm1vdmVyO1xufVxuZnVuY3Rpb24gZ2V0T3V0bGluZSh0YWJzdGVyKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLm91dGxpbmUpIHtcbiAgICB0YWJzdGVyQ29yZS5vdXRsaW5lID0gbmV3IE91dGxpbmVBUEkodGFic3RlckNvcmUpO1xuICB9XG4gIHJldHVybiB0YWJzdGVyQ29yZS5vdXRsaW5lO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG5ldyBkZWxvc2VyIGluc3RhbmNlIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lXG4gKiBAcGFyYW0gdGFic3RlciBUYWJzdGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gcHJvcHMgRGVsb3NlciBwcm9wc1xuICovXG5mdW5jdGlvbiBnZXREZWxvc2VyKHRhYnN0ZXIsIHByb3BzKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLmRlbG9zZXIpIHtcbiAgICB0YWJzdGVyQ29yZS5kZWxvc2VyID0gbmV3IERlbG9zZXJBUEkodGFic3RlckNvcmUsIHByb3BzKTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUuZGVsb3Nlcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtb2RhbGl6ZXIgaW5zdGFuY2Ugb3IgcmV0dXJucyBhbiBleGlzdGluZyBvbmVcbiAqIEBwYXJhbSB0YWJzdGVyIFRhYnN0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBhbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3IgV2hlbiBNb2RhbGl6ZXIgaXMgYWN0aXZlLCB3ZSBwdXRcbiAqIGFyaWEtaGlkZGVuIHRvIGV2ZXJ5dGhpbmcgZWxzZSB0byBoaWRlIGl0IGZyb20gc2NyZWVuIHJlYWRlcnMuIFRoaXMgQ1NTXG4gKiBzZWxlY3RvciBhbGxvd3MgdG8gZXhjbHVkZSBzb21lIGVsZW1lbnRzIGZyb20gdGhpcyBiZWhhdmlvdXIuIEZvciBleGFtcGxlLFxuICogdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGV4Y2x1ZGUgYXJpYS1saXZlIHJlZ2lvbiB3aXRoIHRoZSBhcHBsaWNhdGlvbi13aWRlXG4gKiBzdGF0dXMgYW5ub3VuY2VtZW50cy5cbiAqIEBwYXJhbSBhY2Nlc3NpYmxlQ2hlY2sgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gKiBhY3RpdmUgTW9kYWxpemVyIHdhbnRzIHRvIGhpZGUgYW4gZWxlbWVudCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIGl0IGZyb21cbiAqIHRoZSBzY3JlZW4gcmVhZGVycyBieSBzZXR0aW5nIGFyaWEtaGlkZGVuLiBTaW1pbGFyIHRvIGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvclxuICogYnV0IGFsbG93cyB0byBhZGRyZXNzIHRoZSBlbGVtZW50cyBwcm9ncmFtbWF0aWNhbGx5IHJhdGhlciB0aGFuIHdpdGggYSBzZWxlY3Rvci5cbiAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHJlY2VpdmUgYXJpYS1oaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGFsaXplcih0YWJzdGVyLFxuLy8gQGRlcHJlY2F0ZWQgdXNlIGFjY2Vzc2libGVDaGVjay5cbmFsd2F5c0FjY2Vzc2libGVTZWxlY3RvciwgYWNjZXNzaWJsZUNoZWNrKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLm1vZGFsaXplcikge1xuICAgIHRhYnN0ZXJDb3JlLm1vZGFsaXplciA9IG5ldyBNb2RhbGl6ZXJBUEkodGFic3RlckNvcmUsIGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvciwgYWNjZXNzaWJsZUNoZWNrKTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUubW9kYWxpemVyO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZWRFbGVtZW50KHRhYnN0ZXIpIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUub2JzZXJ2ZWRFbGVtZW50KSB7XG4gICAgdGFic3RlckNvcmUub2JzZXJ2ZWRFbGVtZW50ID0gbmV3IE9ic2VydmVkRWxlbWVudEFQSSh0YWJzdGVyQ29yZSk7XG4gIH1cbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLm9ic2VydmVkRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldENyb3NzT3JpZ2luKHRhYnN0ZXIpIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUuY3Jvc3NPcmlnaW4pIHtcbiAgICBnZXREZWxvc2VyKHRhYnN0ZXIpO1xuICAgIGdldE1vZGFsaXplcih0YWJzdGVyKTtcbiAgICBnZXRNb3Zlcih0YWJzdGVyKTtcbiAgICBnZXRHcm91cHBlcih0YWJzdGVyKTtcbiAgICBnZXRPdXRsaW5lKHRhYnN0ZXIpO1xuICAgIGdldE9ic2VydmVkRWxlbWVudCh0YWJzdGVyKTtcbiAgICB0YWJzdGVyQ29yZS5jcm9zc09yaWdpbiA9IG5ldyBDcm9zc09yaWdpbkFQSSh0YWJzdGVyQ29yZSk7XG4gIH1cbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLmNyb3NzT3JpZ2luO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwodGFic3Rlcikge1xuICBjb25zdCB0YWJzdGVyQ29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLmludGVybmFsO1xufVxuZnVuY3Rpb24gZ2V0UmVzdG9yZXIodGFic3Rlcikge1xuICBjb25zdCB0YWJzdGVyQ29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgaWYgKCF0YWJzdGVyQ29yZS5yZXN0b3Jlcikge1xuICAgIHRhYnN0ZXJDb3JlLnJlc3RvcmVyID0gbmV3IFJlc3RvcmVyQVBJKHRhYnN0ZXJDb3JlKTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUucmVzdG9yZXI7XG59XG5mdW5jdGlvbiBkaXNwb3NlVGFic3Rlcih0YWJzdGVyLCBhbGxJbnN0YW5jZXMpIHtcbiAgdGFic3Rlci5jb3JlLmRpc3Bvc2VUYWJzdGVyKHRhYnN0ZXIsIGFsbEluc3RhbmNlcyk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFic3RlciBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgd2luZG93IC5cbiAqIEBwYXJhbSB3aW4gd2luZG93IGluc3RhbmNlIHRoYXQgY291bGQgY29udGFpbiBhbiBUYWJzdGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50VGFic3Rlcih3aW4pIHtcbiAgcmV0dXJuIHdpbi5fX3RhYnN0ZXJJbnN0YW5jZTtcbn1cbi8qKlxuICogQWxsb3dzIHRvIG1ha2UgVGFic3RlciBub24gb3BlcmF0aW9uYWwuIEludGVuZGVkIGZvciBwZXJmb3JtYW5jZSBkZWJ1Z2dpbmcgKGFuZCBvdGhlclxuICoga2luZHMgb2YgZGVidWdnaW5nKSwgeW91IGNhbiBzd2l0Y2ggVGFic3RlciBvZmYgd2l0aG91dCBjaGFuZ2luZyB0aGUgYXBwbGljYXRpb24gY29kZVxuICogdGhhdCBjb25zdW1lcyBpdC5cbiAqIEBwYXJhbSB0YWJzdGVyIGEgcmVmZXJlbmNlIGNyZWF0ZWQgYnkgY3JlYXRlVGFic3RlcigpLlxuICogQHBhcmFtIG5vb3AgdHJ1ZSBpZiB5b3Ugd2FudCB0byBtYWtlIFRhYnN0ZXIgbm9vcCwgZmFsc2UgaWYgeW91IHdhbnQgdG8gdHVybiBpdCBiYWNrLlxuICovXG5mdW5jdGlvbiBtYWtlTm9PcCh0YWJzdGVyLCBub29wKSB7XG4gIGNvbnN0IGNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmIChjb3JlLl9ub29wICE9PSBub29wKSB7XG4gICAgY29yZS5fbm9vcCA9IG5vb3A7XG4gICAgY29uc3QgcHJvY2Vzc05vZGUgPSBlbGVtZW50ID0+IHtcbiAgICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICB9XG4gICAgICBpZiAoZ2V0VGFic3Rlck9uRWxlbWVudChjb3JlLCBlbGVtZW50KSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICB1cGRhdGVUYWJzdGVyQnlBdHRyaWJ1dGUoY29yZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9O1xuICAgIGNvbnN0IGRvYyA9IGNvcmUuZ2V0V2luZG93KCkuZG9jdW1lbnQ7XG4gICAgY29uc3QgYm9keSA9IGRvYy5ib2R5O1xuICAgIHByb2Nlc3NOb2RlKGJvZHkpO1xuICAgIGNvbnN0IHdhbGtlciA9IGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKGRvYywgYm9keSwgcHJvY2Vzc05vZGUpO1xuICAgIGlmICh3YWxrZXIpIHtcbiAgICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAvKiBJdGVyYXRpbmcgZm9yIHRoZSBzYWtlIG9mIGNhbGxpbmcgcHJvY2Vzc05vZGUoKSBjYWxsYmFjay4gKi9cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTm9PcCh0YWJzdGVyKSB7XG4gIHJldHVybiB0YWJzdGVyLl9ub29wO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbnZhciBUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbnZhciBFdmVudHNUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBpcyBvYnNvbGV0ZSwgdXNlIG5hdGl2ZSBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwcGVyTW92ZUZvY3VzRXZlbnQoLi4uKSkuICovXG5mdW5jdGlvbiBkaXNwYXRjaEdyb3VwcGVyTW92ZUZvY3VzRXZlbnQodGFyZ2V0LCBhY3Rpb24pIHtcbiAgcmV0dXJuIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cHBlck1vdmVGb2N1c0V2ZW50KHtcbiAgICBhY3Rpb25cbiAgfSkpO1xufVxuLyoqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaXMgb2Jzb2xldGUsIHVzZSBuYXRpdmUgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBNb3Zlck1vdmVGb2N1c0V2ZW50KC4uLikpLiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hNb3Zlck1vdmVGb2N1c0V2ZW50KHRhcmdldCwga2V5KSB7XG4gIHJldHVybiB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgTW92ZXJNb3ZlRm9jdXNFdmVudCh7XG4gICAga2V5XG4gIH0pKTtcbn1cbi8qKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGlzIG9ic29sZXRlLCB1c2UgbmF0aXZlIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnQoLi4uKSkuICovXG5mdW5jdGlvbiBkaXNwYXRjaE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50KHRhcmdldCwgbWVtb3JpemVkRWxlbWVudCkge1xuICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50KHtcbiAgICBtZW1vcml6ZWRFbGVtZW50XG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgQXN5bmNGb2N1c1NvdXJjZXMsIERlbG9zZXJGb2N1c0xvc3RFdmVudCwgRGVsb3NlckZvY3VzTG9zdEV2ZW50TmFtZSwgRGVsb3NlclJlc3RvcmVGb2N1c0V2ZW50LCBEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnROYW1lLCBEZWxvc2VyU3RyYXRlZ2llcywgRXZlbnRzVHlwZXMsIEZPQ1VTQUJMRV9TRUxFQ1RPUiwgR3JvdXBwZXJNb3ZlRm9jdXNBY3Rpb25zLCBHcm91cHBlck1vdmVGb2N1c0V2ZW50LCBHcm91cHBlck1vdmVGb2N1c0V2ZW50TmFtZSwgR3JvdXBwZXJUYWJiYWJpbGl0aWVzLCBNb2RhbGl6ZXJBY3RpdmVFdmVudCwgTW9kYWxpemVyQWN0aXZlRXZlbnROYW1lLCBNb2RhbGl6ZXJGb2N1c0luRXZlbnROYW1lLCBNb2RhbGl6ZXJGb2N1c091dEV2ZW50TmFtZSwgTW9kYWxpemVySW5hY3RpdmVFdmVudCwgTW9kYWxpemVySW5hY3RpdmVFdmVudE5hbWUsIE1vdmVyRGlyZWN0aW9ucywgTW92ZXJLZXlzLCBNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudCwgTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnROYW1lLCBNb3Zlck1vdmVGb2N1c0V2ZW50LCBNb3Zlck1vdmVGb2N1c0V2ZW50TmFtZSwgTW92ZXJTdGF0ZUV2ZW50LCBNb3ZlclN0YXRlRXZlbnROYW1lLCBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMsIE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcywgUmVzdG9yZUZvY3VzT3JkZXJzLCBSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50LCBSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSwgUmVzdG9yZXJUeXBlcywgUm9vdEJsdXJFdmVudCwgUm9vdEJsdXJFdmVudE5hbWUsIFJvb3RGb2N1c0V2ZW50LCBSb290Rm9jdXNFdmVudE5hbWUsIFN5c0R1bW15SW5wdXRzUG9zaXRpb25zLCBUQUJTVEVSX0FUVFJJQlVURV9OQU1FLCBUQUJTVEVSX0RVTU1ZX0lOUFVUX0FUVFJJQlVURV9OQU1FLCBUYWJzdGVyQ3VzdG9tRXZlbnQsIFRhYnN0ZXJGb2N1c0luRXZlbnQsIFRhYnN0ZXJGb2N1c0luRXZlbnROYW1lLCBUYWJzdGVyRm9jdXNPdXRFdmVudCwgVGFic3RlckZvY3VzT3V0RXZlbnROYW1lLCBUYWJzdGVyTW92ZUZvY3VzRXZlbnQsIFRhYnN0ZXJNb3ZlRm9jdXNFdmVudE5hbWUsIFR5cGVzLCBWaXNpYmlsaXRpZXMsIGNyZWF0ZVRhYnN0ZXIsIGRpc3BhdGNoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudCwgZGlzcGF0Y2hNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudCwgZGlzcGF0Y2hNb3Zlck1vdmVGb2N1c0V2ZW50LCBkaXNwb3NlVGFic3RlciwgZm9yY2VDbGVhbnVwLCBnZXRDcm9zc09yaWdpbiwgZ2V0RGVsb3NlciwgZ2V0RHVtbXlJbnB1dENvbnRhaW5lciwgZ2V0R3JvdXBwZXIsIGdldEludGVybmFsLCBnZXRNb2RhbGl6ZXIsIGdldE1vdmVyLCBnZXRPYnNlcnZlZEVsZW1lbnQsIGdldE91dGxpbmUsIGdldFJlc3RvcmVyLCBnZXRTaGFkb3dET01BUEksIGdldFRhYnN0ZXIsIGdldFRhYnN0ZXJBdHRyaWJ1dGUsIGlzTm9PcCwgbWFrZU5vT3AsIG1lcmdlVGFic3RlclByb3BzLCBzZXRUYWJzdGVyQXR0cmlidXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzdGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tabster/dist/tabster.esm.js\n");

/***/ })

};
;