"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel-fade";
exports.ids = ["vendor-chunks/embla-carousel-fade"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nfunction clampNumber(number, min, max) {\n  return Math.min(Math.max(number, min), max);\n}\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction Fade(userOptions = {}) {\n  const fullOpacity = 1;\n  const noOpacity = 0;\n  const fadeFriction = 0.68;\n  let emblaApi;\n  let opacities = [];\n  let fadeToNextDistance;\n  let distanceFromPointerDown = 0;\n  let fadeVelocity = 0;\n  let progress = 0;\n  let shouldFadePair = false;\n  let defaultSettledBehaviour;\n  let defaultProgressBehaviour;\n  function init(emblaApiInstance) {\n    emblaApi = emblaApiInstance;\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    const {\n      scrollBody,\n      containerRect,\n      axis\n    } = emblaApi.internalEngine();\n    const containerSize = axis.measureSize(containerRect);\n    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);\n    shouldFadePair = false;\n    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);\n    defaultSettledBehaviour = scrollBody.settled;\n    defaultProgressBehaviour = emblaApi.scrollProgress;\n    scrollBody.settled = settled;\n    emblaApi.scrollProgress = scrollProgress;\n    emblaApi.on('select', select).on('slideFocus', fadeToSelectedSnapInstantly).on('pointerDown', pointerDown).on('pointerUp', pointerUp);\n    disableScroll();\n    fadeToSelectedSnapInstantly();\n  }\n  function destroy() {\n    const {\n      scrollBody\n    } = emblaApi.internalEngine();\n    scrollBody.settled = defaultSettledBehaviour;\n    emblaApi.scrollProgress = defaultProgressBehaviour;\n    emblaApi.off('select', select).off('slideFocus', fadeToSelectedSnapInstantly).off('pointerDown', pointerDown).off('pointerUp', pointerUp);\n    emblaApi.slideNodes().forEach(slideNode => {\n      const slideStyle = slideNode.style;\n      slideStyle.opacity = '';\n      slideStyle.transform = '';\n      slideStyle.pointerEvents = '';\n      if (!slideNode.getAttribute('style')) slideNode.removeAttribute('style');\n    });\n  }\n  function fadeToSelectedSnapInstantly() {\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    setOpacities(selectedSnap, fullOpacity);\n  }\n  function pointerUp() {\n    shouldFadePair = false;\n  }\n  function pointerDown() {\n    shouldFadePair = false;\n    distanceFromPointerDown = 0;\n    fadeVelocity = 0;\n  }\n  function select() {\n    const duration = emblaApi.internalEngine().scrollBody.duration();\n    fadeVelocity = duration ? 0 : fullOpacity;\n    shouldFadePair = true;\n    if (!duration) fadeToSelectedSnapInstantly();\n  }\n  function getSlideTransform(position) {\n    const {\n      axis\n    } = emblaApi.internalEngine();\n    const translateAxis = axis.scroll.toUpperCase();\n    return `translate${translateAxis}(${axis.direction(position)}px)`;\n  }\n  function disableScroll() {\n    const {\n      translate,\n      slideLooper\n    } = emblaApi.internalEngine();\n    translate.clear();\n    translate.toggleActive(false);\n    slideLooper.loopPoints.forEach(({\n      translate\n    }) => {\n      translate.clear();\n      translate.toggleActive(false);\n    });\n  }\n  function lockExcessiveScroll(fadeIndex) {\n    const {\n      scrollSnaps,\n      location,\n      target\n    } = emblaApi.internalEngine();\n    if (!isNumber(fadeIndex) || opacities[fadeIndex] < 0.5) return;\n    location.set(scrollSnaps[fadeIndex]);\n    target.set(location);\n  }\n  function setOpacities(fadeIndex, velocity) {\n    const scrollSnaps = emblaApi.scrollSnapList();\n    scrollSnaps.forEach((_, indexA) => {\n      const absVelocity = Math.abs(velocity);\n      const currentOpacity = opacities[indexA];\n      const isFadeIndex = indexA === fadeIndex;\n      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;\n      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);\n      opacities[indexA] = clampedOpacity;\n      const fadePair = isFadeIndex && shouldFadePair;\n      const indexB = emblaApi.previousScrollSnap();\n      if (fadePair) opacities[indexB] = 1 - clampedOpacity;\n      if (isFadeIndex) setProgress(fadeIndex, clampedOpacity);\n      setOpacity(indexA);\n    });\n  }\n  function setOpacity(index) {\n    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];\n    const {\n      scrollSnaps,\n      containerRect\n    } = emblaApi.internalEngine();\n    const opacity = opacities[index];\n    slidesInSnap.forEach(slideIndex => {\n      const slideStyle = emblaApi.slideNodes()[slideIndex].style;\n      const roundedOpacity = parseFloat(opacity.toFixed(2));\n      const hasOpacity = roundedOpacity > noOpacity;\n      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;\n      const transform = getSlideTransform(position);\n      if (hasOpacity) slideStyle.transform = transform;\n      slideStyle.opacity = roundedOpacity.toString();\n      slideStyle.pointerEvents = opacity > 0.5 ? 'auto' : 'none';\n      if (!hasOpacity) slideStyle.transform = transform;\n    });\n  }\n  function setProgress(fadeIndex, opacity) {\n    const {\n      index,\n      dragHandler,\n      scrollSnaps\n    } = emblaApi.internalEngine();\n    const pointerDown = dragHandler.pointerDown();\n    const snapFraction = 1 / (scrollSnaps.length - 1);\n    let indexA = fadeIndex;\n    let indexB = pointerDown ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();\n    if (pointerDown && indexA === indexB) {\n      const reverseSign = Math.sign(distanceFromPointerDown) * -1;\n      indexA = indexB;\n      indexB = index.clone().set(indexB).add(reverseSign).get();\n    }\n    const currentPosition = indexB * snapFraction;\n    const diffPosition = (indexA - indexB) * snapFraction;\n    progress = currentPosition + diffPosition * opacity;\n  }\n  function getFadeIndex() {\n    const {\n      dragHandler,\n      index,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    if (!dragHandler.pointerDown()) return selectedSnap;\n    const directionSign = Math.sign(scrollBody.velocity());\n    const distanceSign = Math.sign(distanceFromPointerDown);\n    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();\n    if (!directionSign || !distanceSign) return null;\n    return distanceSign === directionSign ? nextSnap : selectedSnap;\n  }\n  function fade(emblaApi) {\n    const {\n      dragHandler,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const pointerDown = dragHandler.pointerDown();\n    const velocity = scrollBody.velocity();\n    const duration = scrollBody.duration();\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    if (pointerDown) {\n      if (!velocity) return;\n      distanceFromPointerDown += velocity;\n      fadeVelocity = Math.abs(velocity / fadeToNextDistance);\n      lockExcessiveScroll(fadeIndex);\n    }\n    if (!pointerDown) {\n      if (!duration || noFadeIndex) return;\n      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;\n      fadeVelocity *= fadeFriction;\n    }\n    if (noFadeIndex) return;\n    setOpacities(fadeIndex, fadeVelocity);\n  }\n  function settled() {\n    const {\n      target,\n      location\n    } = emblaApi.internalEngine();\n    const diffToTarget = target.get() - location.get();\n    const notReachedTarget = Math.abs(diffToTarget) >= 1;\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    fade(emblaApi);\n    if (noFadeIndex || notReachedTarget) return false;\n    return opacities[fadeIndex] > 0.999;\n  }\n  function scrollProgress() {\n    return progress;\n  }\n  const self = {\n    name: 'fade',\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nFade.globalOptions = undefined;\n\nmodule.exports = Fade;\n//# sourceMappingURL=embla-carousel-fade.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtZmFkZS9janMvZW1ibGEtY2Fyb3VzZWwtZmFkZS5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLGNBQWMsR0FBRyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtZmFkZS9janMvZW1ibGEtY2Fyb3VzZWwtZmFkZS5janMuanM/MDllYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNsYW1wTnVtYmVyKG51bWJlciwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bWJlciwgbWluKSwgbWF4KTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIEZhZGUodXNlck9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmdWxsT3BhY2l0eSA9IDE7XG4gIGNvbnN0IG5vT3BhY2l0eSA9IDA7XG4gIGNvbnN0IGZhZGVGcmljdGlvbiA9IDAuNjg7XG4gIGxldCBlbWJsYUFwaTtcbiAgbGV0IG9wYWNpdGllcyA9IFtdO1xuICBsZXQgZmFkZVRvTmV4dERpc3RhbmNlO1xuICBsZXQgZGlzdGFuY2VGcm9tUG9pbnRlckRvd24gPSAwO1xuICBsZXQgZmFkZVZlbG9jaXR5ID0gMDtcbiAgbGV0IHByb2dyZXNzID0gMDtcbiAgbGV0IHNob3VsZEZhZGVQYWlyID0gZmFsc2U7XG4gIGxldCBkZWZhdWx0U2V0dGxlZEJlaGF2aW91cjtcbiAgbGV0IGRlZmF1bHRQcm9ncmVzc0JlaGF2aW91cjtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaUluc3RhbmNlKSB7XG4gICAgZW1ibGFBcGkgPSBlbWJsYUFwaUluc3RhbmNlO1xuICAgIGNvbnN0IHNlbGVjdGVkU25hcCA9IGVtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbEJvZHksXG4gICAgICBjb250YWluZXJSZWN0LFxuICAgICAgYXhpc1xuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBheGlzLm1lYXN1cmVTaXplKGNvbnRhaW5lclJlY3QpO1xuICAgIGZhZGVUb05leHREaXN0YW5jZSA9IGNsYW1wTnVtYmVyKGNvbnRhaW5lclNpemUgKiAwLjc1LCAyMDAsIDUwMCk7XG4gICAgc2hvdWxkRmFkZVBhaXIgPSBmYWxzZTtcbiAgICBvcGFjaXRpZXMgPSBlbWJsYUFwaS5zY3JvbGxTbmFwTGlzdCgpLm1hcCgoXywgaW5kZXgpID0+IGluZGV4ID09PSBzZWxlY3RlZFNuYXAgPyBmdWxsT3BhY2l0eSA6IG5vT3BhY2l0eSk7XG4gICAgZGVmYXVsdFNldHRsZWRCZWhhdmlvdXIgPSBzY3JvbGxCb2R5LnNldHRsZWQ7XG4gICAgZGVmYXVsdFByb2dyZXNzQmVoYXZpb3VyID0gZW1ibGFBcGkuc2Nyb2xsUHJvZ3Jlc3M7XG4gICAgc2Nyb2xsQm9keS5zZXR0bGVkID0gc2V0dGxlZDtcbiAgICBlbWJsYUFwaS5zY3JvbGxQcm9ncmVzcyA9IHNjcm9sbFByb2dyZXNzO1xuICAgIGVtYmxhQXBpLm9uKCdzZWxlY3QnLCBzZWxlY3QpLm9uKCdzbGlkZUZvY3VzJywgZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KS5vbigncG9pbnRlckRvd24nLCBwb2ludGVyRG93bikub24oJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCk7XG4gICAgZGlzYWJsZVNjcm9sbCgpO1xuICAgIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSgpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsQm9keVxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIHNjcm9sbEJvZHkuc2V0dGxlZCA9IGRlZmF1bHRTZXR0bGVkQmVoYXZpb3VyO1xuICAgIGVtYmxhQXBpLnNjcm9sbFByb2dyZXNzID0gZGVmYXVsdFByb2dyZXNzQmVoYXZpb3VyO1xuICAgIGVtYmxhQXBpLm9mZignc2VsZWN0Jywgc2VsZWN0KS5vZmYoJ3NsaWRlRm9jdXMnLCBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkpLm9mZigncG9pbnRlckRvd24nLCBwb2ludGVyRG93bikub2ZmKCdwb2ludGVyVXAnLCBwb2ludGVyVXApO1xuICAgIGVtYmxhQXBpLnNsaWRlTm9kZXMoKS5mb3JFYWNoKHNsaWRlTm9kZSA9PiB7XG4gICAgICBjb25zdCBzbGlkZVN0eWxlID0gc2xpZGVOb2RlLnN0eWxlO1xuICAgICAgc2xpZGVTdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICBzbGlkZVN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgc2xpZGVTdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBpZiAoIXNsaWRlTm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHNsaWRlTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KCkge1xuICAgIGNvbnN0IHNlbGVjdGVkU25hcCA9IGVtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICAgIHNldE9wYWNpdGllcyhzZWxlY3RlZFNuYXAsIGZ1bGxPcGFjaXR5KTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyVXAoKSB7XG4gICAgc2hvdWxkRmFkZVBhaXIgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bigpIHtcbiAgICBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICAgIGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duID0gMDtcbiAgICBmYWRlVmVsb2NpdHkgPSAwO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCkuc2Nyb2xsQm9keS5kdXJhdGlvbigpO1xuICAgIGZhZGVWZWxvY2l0eSA9IGR1cmF0aW9uID8gMCA6IGZ1bGxPcGFjaXR5O1xuICAgIHNob3VsZEZhZGVQYWlyID0gdHJ1ZTtcbiAgICBpZiAoIWR1cmF0aW9uKSBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTbGlkZVRyYW5zZm9ybShwb3NpdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGF4aXNcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCB0cmFuc2xhdGVBeGlzID0gYXhpcy5zY3JvbGwudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZSR7dHJhbnNsYXRlQXhpc30oJHtheGlzLmRpcmVjdGlvbihwb3NpdGlvbil9cHgpYDtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbGF0ZSxcbiAgICAgIHNsaWRlTG9vcGVyXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgdHJhbnNsYXRlLmNsZWFyKCk7XG4gICAgdHJhbnNsYXRlLnRvZ2dsZUFjdGl2ZShmYWxzZSk7XG4gICAgc2xpZGVMb29wZXIubG9vcFBvaW50cy5mb3JFYWNoKCh7XG4gICAgICB0cmFuc2xhdGVcbiAgICB9KSA9PiB7XG4gICAgICB0cmFuc2xhdGUuY2xlYXIoKTtcbiAgICAgIHRyYW5zbGF0ZS50b2dnbGVBY3RpdmUoZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvY2tFeGNlc3NpdmVTY3JvbGwoZmFkZUluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsU25hcHMsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRhcmdldFxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGlmICghaXNOdW1iZXIoZmFkZUluZGV4KSB8fCBvcGFjaXRpZXNbZmFkZUluZGV4XSA8IDAuNSkgcmV0dXJuO1xuICAgIGxvY2F0aW9uLnNldChzY3JvbGxTbmFwc1tmYWRlSW5kZXhdKTtcbiAgICB0YXJnZXQuc2V0KGxvY2F0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRPcGFjaXRpZXMoZmFkZUluZGV4LCB2ZWxvY2l0eSkge1xuICAgIGNvbnN0IHNjcm9sbFNuYXBzID0gZW1ibGFBcGkuc2Nyb2xsU25hcExpc3QoKTtcbiAgICBzY3JvbGxTbmFwcy5mb3JFYWNoKChfLCBpbmRleEEpID0+IHtcbiAgICAgIGNvbnN0IGFic1ZlbG9jaXR5ID0gTWF0aC5hYnModmVsb2NpdHkpO1xuICAgICAgY29uc3QgY3VycmVudE9wYWNpdHkgPSBvcGFjaXRpZXNbaW5kZXhBXTtcbiAgICAgIGNvbnN0IGlzRmFkZUluZGV4ID0gaW5kZXhBID09PSBmYWRlSW5kZXg7XG4gICAgICBjb25zdCBuZXh0T3BhY2l0eSA9IGlzRmFkZUluZGV4ID8gY3VycmVudE9wYWNpdHkgKyBhYnNWZWxvY2l0eSA6IGN1cnJlbnRPcGFjaXR5IC0gYWJzVmVsb2NpdHk7XG4gICAgICBjb25zdCBjbGFtcGVkT3BhY2l0eSA9IGNsYW1wTnVtYmVyKG5leHRPcGFjaXR5LCBub09wYWNpdHksIGZ1bGxPcGFjaXR5KTtcbiAgICAgIG9wYWNpdGllc1tpbmRleEFdID0gY2xhbXBlZE9wYWNpdHk7XG4gICAgICBjb25zdCBmYWRlUGFpciA9IGlzRmFkZUluZGV4ICYmIHNob3VsZEZhZGVQYWlyO1xuICAgICAgY29uc3QgaW5kZXhCID0gZW1ibGFBcGkucHJldmlvdXNTY3JvbGxTbmFwKCk7XG4gICAgICBpZiAoZmFkZVBhaXIpIG9wYWNpdGllc1tpbmRleEJdID0gMSAtIGNsYW1wZWRPcGFjaXR5O1xuICAgICAgaWYgKGlzRmFkZUluZGV4KSBzZXRQcm9ncmVzcyhmYWRlSW5kZXgsIGNsYW1wZWRPcGFjaXR5KTtcbiAgICAgIHNldE9wYWNpdHkoaW5kZXhBKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRPcGFjaXR5KGluZGV4KSB7XG4gICAgY29uc3Qgc2xpZGVzSW5TbmFwID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKS5zbGlkZVJlZ2lzdHJ5W2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxTbmFwcyxcbiAgICAgIGNvbnRhaW5lclJlY3RcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gb3BhY2l0aWVzW2luZGV4XTtcbiAgICBzbGlkZXNJblNuYXAuZm9yRWFjaChzbGlkZUluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHNsaWRlU3R5bGUgPSBlbWJsYUFwaS5zbGlkZU5vZGVzKClbc2xpZGVJbmRleF0uc3R5bGU7XG4gICAgICBjb25zdCByb3VuZGVkT3BhY2l0eSA9IHBhcnNlRmxvYXQob3BhY2l0eS50b0ZpeGVkKDIpKTtcbiAgICAgIGNvbnN0IGhhc09wYWNpdHkgPSByb3VuZGVkT3BhY2l0eSA+IG5vT3BhY2l0eTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gaGFzT3BhY2l0eSA/IHNjcm9sbFNuYXBzW2luZGV4XSA6IGNvbnRhaW5lclJlY3Qud2lkdGggKyAyO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0U2xpZGVUcmFuc2Zvcm0ocG9zaXRpb24pO1xuICAgICAgaWYgKGhhc09wYWNpdHkpIHNsaWRlU3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgc2xpZGVTdHlsZS5vcGFjaXR5ID0gcm91bmRlZE9wYWNpdHkudG9TdHJpbmcoKTtcbiAgICAgIHNsaWRlU3R5bGUucG9pbnRlckV2ZW50cyA9IG9wYWNpdHkgPiAwLjUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBpZiAoIWhhc09wYWNpdHkpIHNsaWRlU3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNldFByb2dyZXNzKGZhZGVJbmRleCwgb3BhY2l0eSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZHJhZ0hhbmRsZXIsXG4gICAgICBzY3JvbGxTbmFwc1xuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gZHJhZ0hhbmRsZXIucG9pbnRlckRvd24oKTtcbiAgICBjb25zdCBzbmFwRnJhY3Rpb24gPSAxIC8gKHNjcm9sbFNuYXBzLmxlbmd0aCAtIDEpO1xuICAgIGxldCBpbmRleEEgPSBmYWRlSW5kZXg7XG4gICAgbGV0IGluZGV4QiA9IHBvaW50ZXJEb3duID8gZW1ibGFBcGkuc2VsZWN0ZWRTY3JvbGxTbmFwKCkgOiBlbWJsYUFwaS5wcmV2aW91c1Njcm9sbFNuYXAoKTtcbiAgICBpZiAocG9pbnRlckRvd24gJiYgaW5kZXhBID09PSBpbmRleEIpIHtcbiAgICAgIGNvbnN0IHJldmVyc2VTaWduID0gTWF0aC5zaWduKGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duKSAqIC0xO1xuICAgICAgaW5kZXhBID0gaW5kZXhCO1xuICAgICAgaW5kZXhCID0gaW5kZXguY2xvbmUoKS5zZXQoaW5kZXhCKS5hZGQocmV2ZXJzZVNpZ24pLmdldCgpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSBpbmRleEIgKiBzbmFwRnJhY3Rpb247XG4gICAgY29uc3QgZGlmZlBvc2l0aW9uID0gKGluZGV4QSAtIGluZGV4QikgKiBzbmFwRnJhY3Rpb247XG4gICAgcHJvZ3Jlc3MgPSBjdXJyZW50UG9zaXRpb24gKyBkaWZmUG9zaXRpb24gKiBvcGFjaXR5O1xuICB9XG4gIGZ1bmN0aW9uIGdldEZhZGVJbmRleCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcmFnSGFuZGxlcixcbiAgICAgIGluZGV4LFxuICAgICAgc2Nyb2xsQm9keVxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHNlbGVjdGVkU25hcCA9IGVtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICAgIGlmICghZHJhZ0hhbmRsZXIucG9pbnRlckRvd24oKSkgcmV0dXJuIHNlbGVjdGVkU25hcDtcbiAgICBjb25zdCBkaXJlY3Rpb25TaWduID0gTWF0aC5zaWduKHNjcm9sbEJvZHkudmVsb2NpdHkoKSk7XG4gICAgY29uc3QgZGlzdGFuY2VTaWduID0gTWF0aC5zaWduKGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duKTtcbiAgICBjb25zdCBuZXh0U25hcCA9IGluZGV4LmNsb25lKCkuc2V0KHNlbGVjdGVkU25hcCkuYWRkKGRpcmVjdGlvblNpZ24gKiAtMSkuZ2V0KCk7XG4gICAgaWYgKCFkaXJlY3Rpb25TaWduIHx8ICFkaXN0YW5jZVNpZ24pIHJldHVybiBudWxsO1xuICAgIHJldHVybiBkaXN0YW5jZVNpZ24gPT09IGRpcmVjdGlvblNpZ24gPyBuZXh0U25hcCA6IHNlbGVjdGVkU25hcDtcbiAgfVxuICBmdW5jdGlvbiBmYWRlKGVtYmxhQXBpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ0hhbmRsZXIsXG4gICAgICBzY3JvbGxCb2R5XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgcG9pbnRlckRvd24gPSBkcmFnSGFuZGxlci5wb2ludGVyRG93bigpO1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gc2Nyb2xsQm9keS52ZWxvY2l0eSgpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gc2Nyb2xsQm9keS5kdXJhdGlvbigpO1xuICAgIGNvbnN0IGZhZGVJbmRleCA9IGdldEZhZGVJbmRleCgpO1xuICAgIGNvbnN0IG5vRmFkZUluZGV4ID0gIWlzTnVtYmVyKGZhZGVJbmRleCk7XG4gICAgaWYgKHBvaW50ZXJEb3duKSB7XG4gICAgICBpZiAoIXZlbG9jaXR5KSByZXR1cm47XG4gICAgICBkaXN0YW5jZUZyb21Qb2ludGVyRG93biArPSB2ZWxvY2l0eTtcbiAgICAgIGZhZGVWZWxvY2l0eSA9IE1hdGguYWJzKHZlbG9jaXR5IC8gZmFkZVRvTmV4dERpc3RhbmNlKTtcbiAgICAgIGxvY2tFeGNlc3NpdmVTY3JvbGwoZmFkZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFwb2ludGVyRG93bikge1xuICAgICAgaWYgKCFkdXJhdGlvbiB8fCBub0ZhZGVJbmRleCkgcmV0dXJuO1xuICAgICAgZmFkZVZlbG9jaXR5ICs9IChmdWxsT3BhY2l0eSAtIG9wYWNpdGllc1tmYWRlSW5kZXhdKSAvIGR1cmF0aW9uO1xuICAgICAgZmFkZVZlbG9jaXR5ICo9IGZhZGVGcmljdGlvbjtcbiAgICB9XG4gICAgaWYgKG5vRmFkZUluZGV4KSByZXR1cm47XG4gICAgc2V0T3BhY2l0aWVzKGZhZGVJbmRleCwgZmFkZVZlbG9jaXR5KTtcbiAgfVxuICBmdW5jdGlvbiBzZXR0bGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgZGlmZlRvVGFyZ2V0ID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3Qgbm90UmVhY2hlZFRhcmdldCA9IE1hdGguYWJzKGRpZmZUb1RhcmdldCkgPj0gMTtcbiAgICBjb25zdCBmYWRlSW5kZXggPSBnZXRGYWRlSW5kZXgoKTtcbiAgICBjb25zdCBub0ZhZGVJbmRleCA9ICFpc051bWJlcihmYWRlSW5kZXgpO1xuICAgIGZhZGUoZW1ibGFBcGkpO1xuICAgIGlmIChub0ZhZGVJbmRleCB8fCBub3RSZWFjaGVkVGFyZ2V0KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9wYWNpdGllc1tmYWRlSW5kZXhdID4gMC45OTk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbmFtZTogJ2ZhZGUnLFxuICAgIG9wdGlvbnM6IHVzZXJPcHRpb25zLFxuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbkZhZGUuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtZmFkZS5janMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js\n");

/***/ })

};
;